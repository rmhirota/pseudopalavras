<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Relatório de Análise Estatística sobre o Projeto:" />


<meta property="og:description" content="Relatório de pesquisa da disciplina MAE0413." />



<meta name="description" content="Relatório de pesquisa da disciplina MAE0413.">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","instituicao":"Faculdade de Filosofia e Ciências Humanas da Universidade de São Paulo","orientadora":"Profa. Dra. Raquel Santana Santos","link-citations":"yes","toc-title":"Sumário","lof":null,"bookdown":{"clean":"bookdown.bbl","delete_merged_file":"yes","output_dir":"relatorio","book_filename":"pseudopalavras","language":{"ui":{"edit":"Edit","chapter_name":"Capítulo"},"label":{"fig":"Figura","tab":"Tabela"}}},"preface":"<br>","fontsize":"12pt","referencia":"ALMEIDA, M.C.; GIAMPAOLI, V.; HIROTA, R.M.; VILAR, G.V. <b>Relatório de análise estatística sobre o projeto: “O processamento de pseudopalavras no Português Brasileiro”</b>. São Paulo, IME-USP, ano. (RAE–CEA-21P02)","bibliography":["assets/bib/book.bib","assets/bib/packages.bib"],"finalidade":"Doutorado","documentclass":"report","date":"São Paulo, junho de 2021","subtitle":"“O processamento de pseudopalavras no Português Brasileiro”","lot":null,"sign_page":"true","author":[{"name":"Giovanna Vendeiro Vilar<br>Mariana Almeida<br>Renata Massami Hirota<br>Viviana Giampaoli"}],"include-before":"RAE-CEA–21P02","knit":"bookdown::render_book","title":"Relatório de Análise Estatística sobre o Projeto:","site":"bookdown::bookdown_site","colorlinks":"yes","description":"Relatório de pesquisa da disciplina MAE0413.","chapter_name":"\"Capítulo \"","biblio-style":"apalike","pesquisadora":"Aline Benevides"}
</script>

<title>Relatório de Análise Estatística sobre o Projeto:</title>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  let beforePaged = PagedConfig.before;
  window.PagedConfig.before = async () => {
    if (beforePaged) await beforePaged();
    return new Promise((resolve, reject) => {
      var script = document.createElement("script");
      script.type = "text/javascript";
      var src = `https://mathjax.rstudio.com/latest/MathJax.js` + "?config=TeX-MML-AM_CHTML";
      if (location.protocol !== "file:" && /^https?:/.test(src))
        src = src.replace(/^https?:/, '');
      script.src = src;
      window.MathJax = {
        AuthorInit: () => {
          MathJax.Hub.Register.StartupHook("Begin", () => {
            MathJax.Hub.Queue(resolve);
          });
        }
      };
      document.getElementsByTagName("head")[0].appendChild(script);
    });
  };
})();
</script>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<style type="text/css">

@page {
size: A4;
margin: 1in, 1in, 1in, 1.5in;
} 

.shorttitle1 {
string-set: h1-text content(text);
}
.shorttitle2 {
string-set: h2-text content(text);
}

.running-h1-title {
position: running(runningH1Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h1-title:before {
content: string(h1-text);
}
@page chapter:left {
@top-left {
content: none;
}
@top-right {
content: none;
white-space: nowrap !important;
}
@bottom-right {
content: counter(page);
}
}

.running-h2-title {
position: running(runningH2Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h2-title:before {



content: string(h2-text);
}
@page chapter:right {
@top-right {
content: none;
}
@top-left {
content: none;
white-space: nowrap !important;
}
@bottom-right {
content: counter(page);
}
}

@page chapter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page);
}
}
@page :first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: none !important;
}
}

@page frontmatter:left {
@top-left {
content: counter(page, lower-roman);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:right {
@top-right {
content: counter(page, lower-roman);
}
@top-left {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page, lower-roman);
}
}

.level1 {
page: chapter;
}
.front-matter-container .level1 {
page: frontmatter;
}
h1, h2, h3, h4, h5, h6 {
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}
#TOC {
counter-reset: page 1;
}

.front-matter-container+.level1 h1 {
counter-reset: page 1;
}
a[href^="http"]:not([class="uri"])::after {
content: "";
}
div.dedication {
break-before: page;
}
div.abstract {
break-before: page;
}
div.preface {
break-before: page;
}
div.acknowledge {
break-before: page;
}
div.signpage {
break-before: page;
counter-reset: page 1;
}
.front-page {
padding-top: 1in;
text-align: center;
}
h1.title {
font-size: 16pt;
line-height: normal;
font-weight: normal;
text-transform: uppercase;
}
h2.degree {
font-weight: normal;
}
h1.subtitle {
font-size: 14pt;
line-height: normal;
font-weight: normal;
font-style: italic;
text-align: center;
}
p.titlep, p.institute {
line-height: normal;
}
h2.author {
font-size: 13pt;
font-weight: normal;
}
.dedication,.abstract, .preface, .acknowledge {
text-align: left;
line-height: 100%;
}
div.dedication > p {
text-align: center;
font-style: italic;
padding-top: 1in;
}
p.abstract {
line-height: 200%;
}
body {
font-family: "Trebuchet MS";
font-size: 11pt;
line-height: 200%;
}
TOC {
line-height: 50%;
}
h1 {
font-size: 14pt;
}
h2 {
font-size: 12pt;
}
ul, li, a {
color: #000000;
}
h3 {
font-size: 12pt;
font-weight: normal;
font-style: italic;
}
.caption {
font-size: 9pt;
line-height: normal;
padding-left: 1cm;
padding-right: 1cm;
}
#references p {
font-size: 9pt;
line-height: 120%;
}
span.citation {
}
code {
font-size: 9pt;
line-height: 110%;
}
.signature {
border: 0;
border-top: 1px solid #000;
padding: 0;
margin-left: auto;
margin-right: auto;
margin-top: 0;
margin-bottom: 0.6in;
width: 3.5in;
position: relative;
}
p {
line-height: 200%;
}
.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}
.chapter-ref {
font-weight: bold;
line-height: 115%;
}
a.chapter-ref {
padding: 0;
line-height: 110%;
}
#list-of-abbreviations {
line-height: 110%;
}
:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}

a[href^="http"]:not([class="uri"])::after {
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}
#refs div {
margin-left: 2em;
text-indent: -2em;
text-align: justify;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: hidden;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.toc .chapter-ref .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: " ";
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
}
pre[class] {
background: #f9f9f9;
}
table {
margin: auto;
border-top: 1px solid #000;
border-bottom: 1px solid #000;
border-collapse:collapse;
font-size: 9pt;
line-height: 115%;
}
table th {
border-bottom: 1px solid #000;
}
th {
padding: 0.1cm;
}
thead {
border-bottom: 1px solid #000;
line-height: 140%;
}
table > caption {
margin-bottom: 0.3cm;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}
.sourceCode {
line-height: 1;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });
}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>



<style type="text/css">body {
font-family: sans-serif;
}
p {
text-align: left;
text-justify: inter-word;
}
tr:nth-child(even) {
background-color: #f2f2f2;
}
@page chapter:first {
background-image: var(--front-cover-2);
}
@page {
@bottom-center {
content: element(footer);
width: 100mm;
border-top-width: 5px;
border-top-style: solid;
border-top-color: #FFF;
}
}
div.footer {
display: block; text-align: center;
position: running(footer);
}
div.unnumbered {
text-align: left;
}
.front-matter-container {
text-align: left;
}
.section {
text-align: left;
}
.titulo {
max-width: 180px;
}
.pagedjs_page {
--pagedjs-margin-top: .9in;
--pagedjs-margin-right: 1in;
--pagedjs-margin-left: 1in;
--pagedjs-margin-bottom: .9in;
--pagedjs-pagebox-width: 210mm;
--pagedjs-pagebox-height: 297mm;
}
.equipe {
text-align: center;
}
.equipe p {
text-align: center;
font-size: 12px;
margin-block-start: 2px;
margin-block-end: 2px;
}
</style>

</head>

<body>
<div class='footer'><hr> CENTRO DE ESTATÍSTICA APLICADA  - IME/ USP </div>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<!-- capa -->
<!-- <div class="front-page"> -->
<!-- <img src="assets/capa.png" height="842"></img><br> -->
<!-- </div><br> -->

<div><center>
RAE-CEA–21P02
</center></div>

<!--
Title Page
-->
<div class="front-page">
<div id="header" class="title-page">
<h1 class="title" style="font-size:18px; !important"><b>Relatório de Análise Estatística sobre o Projeto:</b></h1><br><br>
<h1 class="subtitle"><span><b>“O processamento de pseudopalavras no Português Brasileiro”</b></span></h1>
<br><p class="titlep"><p><br>
<h2 class="author"><b>Giovanna Vendeiro Vilar<br>Mariana Almeida<br>Renata Massami Hirota<br>Viviana Giampaoli</b></h2>
<br>

<br>
<br><br><br>
<h4>São Paulo, junho de 2021</h4>
</div>
<br>
<!--<p class="department">Department of </p>
<br>
<p class="titlep">Submitted in partial fulfillment of <br> the requirements for the degree of</p>
<br>
<h2 class="degree"></h2>
<br>
<p class="institute">Faculty of , <br></p>
<br>
<p class="copyright">&#169;  Giovanna Vendeiro Vilar<br>Mariana Almeida<br>Renata Massami Hirota<br>Viviana Giampaoli</p>-->

<!--
Bellow is the signature page
if the user wants one the YAML
should be "sign_page: true" -->

<div class="signpage">
<h1 class="title">Centro de Estatística Aplicada - CEA - USP</h1>
<br><br>
<div>
<p style="padding-bottom: 15px;"><b>TÍTULO:</b> Relatório de Análise Estatística sobre o Projeto: “O processamento de pseudopalavras no Português Brasileiro”</p>
<p style="padding-bottom: 15px;"><b>PESQUISADORA:</b> Aline Benevides</p>
<p style="padding-bottom: 15px;"><b>ORIENTADORA:</b> Profa. Dra. Raquel Santana Santos</p>
<p style="padding-bottom: 15px;"><b>INSTITUIÇÃO:</b> Faculdade de Filosofia e Ciências Humanas da Universidade de São Paulo</p>
<p style="padding-bottom: 15px;"><b>FINALIDADE DO PROJETO:</b> Doutorado</p>
<p style="padding-bottom: 15px;"><b>RESPONSÁVEIS PELA ANÁLISE:</b>
<br>
Giovanna Vendeiro Vilar<br>Mariana Almeida<br>Renata Massami Hirota<br>Viviana Giampaoli<br>
</p><br>
<p style="padding-bottom: 15px;"><b>REFERÊNCIA DESTE TRABALHO:</b> ALMEIDA, M.C.; GIAMPAOLI, V.; HIROTA, R.M.; VILAR, G.V. <b>Relatório de análise estatística sobre o projeto: “O processamento de pseudopalavras no Português Brasileiro”</b>. São Paulo, IME-USP, ano. (RAE–CEA-21P02)</p>

</div>
</div>




<!-- Pre content section
-Example, if user want a dedication page then they include "dedication: 'some text' in the YAML"
-If you want other pages not found in this template simply add it to this section in the same way
using the ""
-->



<div class="preface">
<h1 class="preface"> </h1>
<br>
</div>



</div>


<!-- This
Container for the table of content, table of tables and table of figures etc.
- See pagedown::html_paged for details on how to use.
-->

<div class="front-matter-container">
<div class="front-matter-container">
<div id="ficha-técnica" class="section level1 unnumbered">
<h1>FICHA TÉCNICA</h1>
<div id="referências-bibliográficas" class="section level2 unnumbered">
<h2>REFERÊNCIAS BIBLIOGRÁFICAS</h2>
</div>
<div id="programas-computacionais-utilizados" class="section level2 unnumbered">
<h2>PROGRAMAS COMPUTACIONAIS UTILIZADOS</h2>
<p>Software R (versão 4.0.5)</p>
</div>
<div id="técnicas-estatísticas-utilizadas" class="section level2" number="7.1">
<h2><span class="header-section-number">7.1</span> TÉCNICAS ESTATÍSTICAS UTILIZADAS</h2>
<p>Análise Descritiva Unidimensional (03:010)
Análise de Dados Categorizados (06:030)
Outros (07:990)</p>
</div>
<div id="área-de-aplicação" class="section level2 unnumbered">
<h2>ÁREA DE APLICAÇÃO</h2>
<p>Linguística (14:110)</p>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-collischonn1999" class="csl-entry">
COLLISCHONN, G. 1999. <em>Acento Em Português. In BISOL, l. (ed.) Introdução a Estudos de Fonologia Do Português Brasileiro</em>. 1st ed. Porto Alegre: EDIPUCRS.
</div>
<div id="ref-fiorin2019" class="csl-entry">
FIORIN, J. L. 2019. <em>Linguística? Que é Isso?</em> 1st ed. São Paulo: Contexto.
</div>
<div id="ref-petter2007" class="csl-entry">
PETTER, M. 2007. <em>Introdução à Linguística i: Objetos Teóricos</em>. 5th ed. São Paulo: Contexto.
</div>
<div id="ref-priberan" class="csl-entry">
PRIBERAM. 2021. <em>&quot;pseudopalavra&quot;, in Dicionário Priberam Da língua Portuguesa</em>. <a href="&lt;https://dicionario.priberam.org/pseudopalavra&gt;">&lt;https://dicionario.priberam.org/pseudopalavra&gt;</a>. [Acesso em: 01-05-2021].
</div>
</div>
<!--chapter:end:07-referencias.Rmd-->
</div>
</div>
</div>

<div id="TOC" class="level1 toc front-matter">
<h1 class="toc-title">Sumário</h1>
<ul>
<li><a href="#resumo"><span class="toc-section-number">1</span> Resumo</a></li>
<li><a href="#introducao"><span class="toc-section-number">2</span> Introdução</a></li>
<li><a href="#objetivos"><span class="toc-section-number">3</span> Objetivo(s)</a></li>
<li><a href="#descricao-estudo"><span class="toc-section-number">4</span> Descrição do estudo</a>
<ul>
<li><a href="#limitações-do-estudo"><span class="toc-section-number">4.1</span> Limitações do estudo</a></li>
<li><a href="#conceitos-de-similaridade-e-validação"><span class="toc-section-number">4.2</span> Conceitos de Similaridade e Validação</a></li>
</ul></li>
<li><a href="#descricao-variaveis"><span class="toc-section-number">5</span> Descrição das variáveis</a>
<ul>
<li><a href="#variável-dependente"><span class="toc-section-number">5.1</span> Variável Dependente</a></li>
<li><a href="#variáveis-linguísticas"><span class="toc-section-number">5.2</span> Variáveis Linguísticas</a></li>
<li><a href="#variáveis-extralinguísticas"><span class="toc-section-number">5.3</span> Variáveis Extralinguísticas</a></li>
<li><a href="#var-experimentais"><span class="toc-section-number">5.4</span> Variáveis Experimentais</a></li>
</ul></li>
<li><a href="#descritiva"><span class="toc-section-number">6</span> Análise descritiva</a>
<ul>
<li><a href="#perfil-dos-participantes"><span class="toc-section-number">6.1</span> Perfil dos participantes</a>
<ul>
<li><a href="#sexo-e-idade"><span class="toc-section-number">6.1.1</span> Sexo e idade</a></li>
<li><a href="#naturalidade"><span class="toc-section-number">6.1.2</span> Naturalidade</a></li>
<li><a href="#área-de-formação"><span class="toc-section-number">6.1.3</span> Área de formação</a></li>
</ul></li>
<li><a href="#variáveis-linguísticas-1"><span class="toc-section-number">6.2</span> Variáveis linguísticas</a></li>
<li><a href="#análise-de-concordância"><span class="toc-section-number">6.3</span> Análise de Concordância</a></li>
<li><a href="#resumo-da-análise-descritiva"><span class="toc-section-number">6.4</span> Resumo da Análise Descritiva</a></li>
</ul></li>
<li><a href="#univariada"><span class="toc-section-number">7</span> Análise univariada</a></li>
<li class="appendix"><span><b>Apêndices</b></span></li>
<li><a href="#tabelas"><span class="toc-section-number">A</span> Tabelas</a></li>
<li><a href="#graficos"><span class="toc-section-number">B</span> Gráficos</a></li>
</ul>
</div>

</div>

<!-- # Sobre este documento {-} -->
<!-- Este relatório foi produzido em *RMarkdown*, utilizando o software estatístico R na versão 4.0.3. -->
<!--chapter:end:index.Rmd-->
<div id="resumo" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Resumo</h1>
<p>A literatura na área de linguistíca afirma, em geral,que o acento tônico na penúltima sílaba (paroxítona) é o padrão, enquanto que acentos na última (oxítona) e na antepenúltima (proparoxítona) sílabas são desvios (CÂMARA JR 1970, LEITE 1974, ANDRADE 1994, BISOL 1992, 1994, MATEUS 1996, MASSINI-CAGLIARI 1999, CAGLIARI 1999, SÂNDALO 1999, LEE 1995, 2004, AMARAL 2002,inter alios)</p>
<p>O estudo analisado neste relatório estatístico busca entender como se dá o processo da acetuação tônica (Oxítona, Paroxítona e Proparoxíton) em falantes nativos do português brasileiro, através de um experimento utilizando pseudopalavras e se, de fato, o acento paroxítona é o padrão d alíngua. A partir desse objetivo, foram construídos modelos de regressão multinomial com efeitos aleatórios levando em conta a estrutura de medidas repetidas dos dados. Concluiu-se que, de modo geral,</p>
<!--chapter:end:00-resumo.Rmd-->
</div>
<div id="introducao" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Introdução</h1>
<p>De acordo com <span class="citation"><a href="#ref-petter2007" role="doc-biblioref">PETTER</a> (<a href="#ref-petter2007" role="doc-biblioref">2007</a>)</span>, o interesse pela linguagem é antigo e vem sendo expresso
por meio de mitos, lendas, cantos, rituais e trabalhos eruditos que buscam conhecer
essa capacidade humana como sistema de comunicação. A autora aponta que, a partir do
século XX, os estudos linguistícos passaram a ter um caráter científico, ou seja,
centrados na observação dos fatos a partir de pressupostos teóricos da linguagem, no
estabelecimento de hipóteses e na examinação mediante experimentos.</p>
<p>Conforme descrito por <span class="citation"><a href="#ref-fiorin2019" role="doc-biblioref">FIORIN</a> (<a href="#ref-fiorin2019" role="doc-biblioref">2019</a>)</span>, a linguística é uma ciência da linguagem porque,
ao contrário da gramática, ela tem como objetivo estabelecer o que uma língua é
e por que é de uma determinada maneira. Logo, a área estuda os aspectos fonéticos,
morfológicos, sintáticos, semânticos, sociais e psicológicos de uma língua, e neste
caso, o português brasileiro. Dentro deste contexto, existe o conceito de <em>pseudopalavra</em>,
que, de acordo com o dicionário <span class="citation"><a href="#ref-priberan" role="doc-biblioref">PRIBERAM</a> (<a href="#ref-priberan" role="doc-biblioref">2021</a>)</span>, é uma</p>
<blockquote>
<p>Sequência regular e pronunciável de caracteres que não tem um significado numa língua, apesar de obedecer às regras ortográficas, morfológicas ou de pronúncia</p>
</blockquote>
<p>No português brasileiro existem três classes de palavras segundo sua tonicidade:
oxítona, paroxítona e proparoxítona. Essas denominações estão relacionadas à
intensidade dada a determinadas sílabas na pronúncia das palavras. Aquela que é
pronunciada de forma mais acentuada é a sílaba tônica. Assim, oxítonas são as palavras
cuja sílaba tônica é a última; paroxítonas são as palavras cuja sílaba tônica é
a penúltima; e proparoxítonas são as palavras cuja sílaba tônica é a
antepenúltima.</p>
<p>O intuito do trabalho é investigar a maneira como os falantes nativos do
português atribuem a tonicidade em pseudopalavras parcialmente relacionadas a vocábulos
existentes no idioma. Em outras palavras, busca-se compreender como o indivíduo,
ao se deparar com uma palavra nova, nesse caso, uma pseudopalavra, define a sílaba
tônica. Além disso, busca-se entender quais são os outros fatores, tais como os
conhecimentos linguísticos do falante e as estruturas linguísticas das palavras, que
podem influenciar nesse processo de classificação e portanto da determinação da entonação.</p>
<!--chapter:end:01-introducao.Rmd-->
</div>
<div id="objetivos" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Objetivo(s)</h1>
<p>O objetivo principal do trabalho é entender o processo de acentuação no Português Brasileiro, com base em um experimento utilizando pseudopalavras. Ou seja, buscamos compreender quais as características da palavra e quais as características do falante que influenciam nesse processo de acentuação tônica quando o indivíduo se depara com uma palavra nova.</p>
<p>Algumas perguntas a serem respondidas pela análise estatística são:</p>
<ol style="list-style-type: decimal">
<li><p>A classificação tônica das pseudopalavras pode recuperar o acento das palavras-alvo
de referência? Em outras palavras, queremos entender se a tonicidade da palavra-alvo tem papel na predição do acento da pseudopalavra.</p></li>
<li><p>As características estruturais da pseudopalavra têm influência
no processo de acentuação tônico? Essa é a única característica que realmente tem impacto nesse processo?</p></li>
<li><p>A similaridade entre palavra-alvo e pseudopalavra influencia na associação acentual? Buscamos entender se quanto mais similar a pseudopalavra for da palavra-alvo, maiores são as chances de atribuição do mesmo padrão acentual da palavra-alvo.</p></li>
<li><p>As variáveis selecionadas pelo modelo estão em concordância com a literatura
da área? Existem variáveis linguísticas, extralinguísticas -relacionadas aos participantes- e experimentais -relacionadas ao estudo-, que podem, segundo a literatura da área, influenciar o comportamento acentual no português.</p></li>
<li><p>Há associação entre graduação em letras e a classificação tônica da pseudopalavra?
Há associação entre conhecimento em música e a classificação tônica da pseudopalavra?
Espera-se que indivíduos com conhecimento em música ou que entraram recentemente em letras tenham um comportamento de classificação das pseudopalavras distinto dos demais.</p></li>
</ol>
<!--chapter:end:02-objetivo.Rmd-->
</div>
<div id="descricao-estudo" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Descrição do estudo</h1>
<p>O estudo foi realizado de maneira remota com reuniões individuais entre a pesquisadora e cada um dos participantes via Google Meet. Consistiu em apresentar aos
participantes, através do software Psychopy, 372 pseudopalavras agrupadas nos
denominados grupos de classificação e registrar a forma como eles reproduziam verbalmente tais palavras criadas. A seguir, as respostas dos participantes foram classificadas de acordo com as três classes de acentuação tônica: oxítona, paroxítona e proparoxítona.</p>
<p>A coleta dos dados foi realizada no início do primeiro semestre de 2020 com 34
indivíduos que, por meio de divulgações em redes sociais e de colegas, se
voluntariaram a participar do experimento. Os voluntários tiveram como pré-requisitos,
ser maior de 18 anos, ser falante nativo do português brasileiro e não ter estudado
linguística.</p>
<p>Entre os participantes da pesquisa encontram-se estudantes do primeiro semestre da
faculdade de Letras da Universidade de São Paulo, músicos, alguns residentes de fora
do estado de São Paulo, entre outros. Supõe-se que os alunos do primeiro semestre
do curso de Letras ainda não têm conhecimento na área.</p>
<div id="limitações-do-estudo" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Limitações do estudo</h2>
<p>Identificamos dois eventuais problemas -um de caráter técnico e outro de aleatorização- na coleta de dados que tentaremos contornar nas análises. O primeiro é descrito a seguir, enquanto o outro será mencionado na seção <a href="#var-experimentais">5.4</a>.</p>
<p><strong>Problemas técnicos e interferência externa</strong></p>
<p>Destaca-se a perda de algumas respostas durante o processo de coleta de dados,
visto que ruídos externos impediram que algumas entonações fossem captadas e
registradas na gravação. Logo, na base de dados não temos 372 registros de
pseudopalavras para todos os participantes. Portanto, um total de 12.511 dados serão
utilizados na análise, em vez dos 12.648 esperados, o qual não representa uma perda
substancial.</p>
</div>
<div id="conceitos-de-similaridade-e-validação" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Conceitos de Similaridade e Validação</h2>
<p>O conceito de similaridade entre palavra-alvo e pseudopalavra foi construído com base
nas mudanças feitas na palavra-alvo até a obtenção da pseudopalavra. Essas alterações
estão relacionadas à mudanças de ponto, modo e/ou vozeamento.</p>
<p>De acordo com o tipo e a quantidade de alterações foi estabelecido um valor de 1 a 10 -chamado de taxa de similaridade- onde, para mudanças de consoantes, valores menores do que 4 determinam pseudopalavras similares a sua palavra-alvo e valores maiores ou iguais a 5 determinam pseudopalavras dissimilares a sua palavra-alvo. Já para mudanças de vogais, valores acima de 1 determinam pseudpalavras dissimilares a sua palavra-alvo.</p>
<p>Diante disso, foi necessário definir um modo de validar essa classificação em similar e dissimilar, ou seja, verificar se a pseudopalavra classificada como similiar -ou dissimilar- é, de fato, similar -ou dissimilar- à palavra da qual ela se originou (palavra-alvo). Nessa etapa -chamada de validação- pediu-se para 10 falantes do português, que não fazem parte do estudo final, listarem a palavra do português a qual eles associavam cada uma das pseudolavras.</p>
<p>Dentre as pseudopalavras consideradas similares a palavras alvo, considerou-se validadas como “similar à palavra-alvo” as pseudopalavras cuja associação foi a palavra-alvo na resposta de, no mínimo, oito indivíduos. Porém, pseudopalavras nas quais sete falantes apresentaram a associação correta foram classificadas como quase validadas e quando menos de sete falantes apresentaram a associação “correta” entendeu-se que a classificação em similar não foi validada (ela não está, de fato, parecida com sua palavra-alvo).</p>
<p>Da mesma forma, dentre as pseudopalavras consideradas dissimilares a palavra-alvo, foram consideradas validadas como “dissimilar à palavra-alvo” pseudopalavras
não associadas a uma mesma resposta por mais de dois indivíduos. Em outras palavras, se até dois falantes associaram uma mesma palavra à pseudopalavra, ela foi considerada
dissimilar à sua palavra-alvo. Pseudopalavras nas quais três falantes apresentaram a
mesma associação foram classificadas como quase validadas e quando mais de três falantes lembraram de uma mesma palavra do português ao ler a pseudopalavra entendeu-se que a classificação em dissimilar não foi validada (ela parece estar parecida com uma palavra real).</p>
<p>Ressalta-se que, nesse caso,a associação não precisava ser exclusivamente com a palavra-alvo. Por exemplo, suponha que pesquisadora criou a pseudopalavra <em>Fanama</em> através de modificações na palavra <em>Parána</em> (palavra-alvo) e definiu que essa pseudopalavra era dissimilar a sua palavra-alvo. Se, na etapa de validação, 5 dos 10 falantes lembraram da palavra <em>Canáda</em> ao ler <em>Fanama</em> então considerou-se que a dissimilaridade não foi validada, pois muitos falantes associaram a pseudopalavra a uma mesma palavra do português (ela parece ser similar a uma palavra real.)</p>
<!--chapter:end:03-descricao.Rmd-->
</div>
</div>
<div id="descricao-variaveis" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Descrição das variáveis</h1>
<p>Foram coletadas variáveis linguísticas -relacionadas às pseudopalavras-,
extralinguísticas -relacionadas aos participantes- e experimentais -relacionadas
ao estudo-, que podem, segundo a literatura da área, influenciar o comportamento
acentual no português. A seguir, listamos as variáveis pré-selecionadas para o estudo.</p>
<div id="variável-dependente" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Variável Dependente</h2>
<p>A variável resposta de interesse é <strong>Tonicidade de produção</strong>, ou seja, a
classificação acentual tônica da pseudopalavra (oxítona, paroxítona e proparoxítona).</p>
</div>
<div id="variáveis-linguísticas" class="section level2" number="5.2">
<h2><span class="header-section-number">5.2</span> Variáveis Linguísticas</h2>
<p>As pseudopalavras foram construídas com três sílabas de extensão para
que os três padrões acentuais do português brasileiro pudessem ser produzidos.
As palavras que deram origem às pseudopalavras, definidas como palavras-alvo,
foram classificadas em dois níveis de acordo com a sua ocorrência no Corpus
brasileiro, corpus linguístico coordenado pelo pesquisador Antonio Paulo Berber
Sardinha. Se a palavra possui mais de 100 mil ocorrências no corpus ela é
classificada como de alta frequência e se possui menos de 2 mil ocorrências ela é
classificada como de baixa frequência. A junção da ideia de frequência e similaridade
entre a palavra alvo e a pseudopalavra resultou na criação de uma variável com 4
categorias chamada grupo de classificação.</p>
<ul>
<li><p><strong>Validação</strong>: s = sim, n = não validada e q = quase validada</p></li>
<li><p><strong>Vizinhança tonicidade</strong>: indica qual foi o padrão acentual das palavras que os participantes julgaram similares a pseudopalavras criada; apenas para pseudopalavras não validadas</p></li>
<li><p><strong>Taxa de validação</strong>: indica quantas pessoas do estudo preliminar informaram que
a palavra era similar ou dissimilar</p></li>
<li><p><strong>Palavra alvo</strong>: palavra real que deu origem à pseudopalavra<br />
</p></li>
<li><p><strong>Tonicidade da palavra alvo</strong>: oxítona, paroxítona e proparoxítona</p></li>
<li><p><strong>Estrutura da palavra</strong>: indica qual é a estrutura da pseudopalavra (CV-CV-CV ou
CV-CV-CVC), sendo que C indica Consoante e V indica Vogal</p></li>
<li><p><strong>Pseudopalavra</strong>: refere-se a cada uma das palavras criadas</p></li>
<li><p><strong>Segmento modificado</strong>: indica qual letra foi modificada na criação da pseudopalavra
a partir da palavra real (consoante ou vogal)<br />
</p></li>
<li><p><strong>Sílaba modificada</strong>: 1,2,3 ( 1º,2º,3º) ou 0 quando mais de uma sílaba
foi modificada (caso das palavras dissimilares)</p></li>
<li><p><strong>Grupo de classificação</strong>: indica o efeito da similaridade (entre a pseudopalavra
e a palavra real) e da frequência (alta e baixa) na produção acentual</p>
<ul>
<li>1 = pseudopalavras similares de alta frequência<br />
</li>
<li>2 = pseudopalavras dissimilares de alta frequência<br />
</li>
<li>3 = pseudopalavras similares de baixa frequência<br />
</li>
<li>4 = pseudopalavras dissimilares de baixa frequência</li>
</ul></li>
</ul>
<p>Ressaltamos que essa variável não foi controlada durante a coleta
de dados, ou seja, não foi pré-definido uma quantidade de palavras de cada categoria
em cada conjunto apresentado aos participantes.</p>
<ul>
<li><strong>Taxa de similaridade</strong>: Para mudanças de consoante:1, 2, 3 (grupos similares), 5, 6, 7, 8, 9, 10 (grupos dissimilares); para mudanças de vogal :1 (grupos similares), 5, 6, 7, 8 (grupos dissimilares)</li>
</ul>
</div>
<div id="variáveis-extralinguísticas" class="section level2" number="5.3">
<h2><span class="header-section-number">5.3</span> Variáveis Extralinguísticas</h2>
<ul>
<li><strong>Participante</strong>: identifica os 34 participantes do experimento</li>
<li><strong>Idade</strong>: de 18 a 60 (anos)</li>
<li><strong>Gênero</strong>: feminino e masculino</li>
<li><strong>Escolaridade</strong>: categorizada em Fundamental Completo, Superior Completo, Superior Incompleto e Pós-Graduação (Completo ou Incompleta)</li>
<li><strong>Área de formação</strong>: 0 = outros e 1 = letras</li>
<li><strong>Línguas</strong>: 0 = não tem conhecimento em línguas e 1 = tem conhecimento em línguas</li>
<li><strong>Música</strong>: 0 = não tem conhecimento em música e 1 = tem conhecimento em música</li>
</ul>
</div>
<div id="var-experimentais" class="section level2" number="5.4">
<h2><span class="header-section-number">5.4</span> Variáveis Experimentais</h2>
<p>As palavras foram aleatorizadas no Excel e divididas em 4 conjuntos - variável Bloco
de apresentação- a serem apresentados aos participantes com um intervalo de tempo entre
cada conjunto. Por limitações do software, a ordem de apresentação desses conjuntos
não pôde ser aleatorizada, apenas a ordem das palavras dentro de cada conjunto.</p>
<ul>
<li><strong>Bloco de apresentação</strong>: indica em qual bloco (ou conjunto) a pseudopalavra foi
inserida (1, 2, 3 ou 4)</li>
<li><strong>Ordem de apresentação</strong>: indica em qual ordem a pseudopalavra foi apresentada
dentro do bloco de apresentação (1 a 93). Para os indivíduos que fizeram toda a
dinâmica no software, a ordem das pseudopalavras era diferente dentro de cada bloco.</li>
</ul>
<p><strong>Problemas de aleatorização</strong></p>
<p>Para alguns participantes o software Psychopy apresentou problemas e
eles tiveram que continuar o experimento a partir de slides com uma ordem aleatória
pré-estabelecida. Em outras palavras, todos os indivíduos que em algum momento
acompanharam o experimento pelos slides seguiram com palavras apresentadas na
mesma ordem (a primeira aleatorização retirada do Excel).</p>
<ul>
<li><strong>Aleatorização</strong>: codifica se o bloco de apresentação foi aleatorizado para o
indivíduo ou não, e portanto foi considerada a aleatorização prévia (s = o estímulo
foi aleatorizado e n = o estímulo não foi aleatorizado).</li>
</ul>
<!--chapter:end:04-variaveis.Rmd-->
</div>
</div>
<div id="descritiva" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Análise descritiva</h1>
<p>A análise descritiva do projeto foi dividida em duas partes. A seguir, apresentamos alguns gráficos e tabelas juntamente com interpretações retiradas das volumetrias vistas. Ao final, discutimos uma idéia de análise de concordância envolvendo os falantes e a classificação tônica das pseudopalavras.</p>
<div id="perfil-dos-participantes" class="section level2" number="6.1">
<h2><span class="header-section-number">6.1</span> Perfil dos participantes</h2>
<div id="sexo-e-idade" class="section level3" number="6.1.1">
<h3><span class="header-section-number">6.1.1</span> Sexo e idade</h3>
<p>Os 34 participantes do estudo estão divididos entre 21 mulheres e 13 homens, com
idades que variam entre 18 e 60 anos. A Figura @ref(fig:idade_genero) mostra a
distribuição dos respondentes segundo a faixa etária e gênero. A faixa etária
foi dividida a partir dos quartis da variável idade, para resumir as informações
da amostra. Com exceção da faixa etária de 31 a 38 anos, há mais mulheres do que
homens no experimento.</p>
</div>
<div id="naturalidade" class="section level3" number="6.1.2">
<h3><span class="header-section-number">6.1.2</span> Naturalidade</h3>
<p>A Tabela <a href="#tab:perfil-informantes">A.1</a> exibe o perfil dos informantes segundo
sua naturalidade (variável agrupada em razão da baixa volumetria de indivíduos
por UF). É possível perceber que a maior proporção (82%) dos participantes
reside no estado de São Paulo, portanto, essa variável não será considerada na
análise.</p>
</div>
<div id="área-de-formação" class="section level3" number="6.1.3">
<h3><span class="header-section-number">6.1.3</span> Área de formação</h3>
<p>Parte considerável dos participantes (11) são ingressantes do curso de Letras,
logo, essa variável foi categorizada em dois níveis. A Tabela
<a href="#tab:area-formacao">A.2</a> mostra esse agrupamento da formação dos voluntários. A
influência do curso de Letras na categorização das pseudopalavras é um dos
fatores de possível interesse na análise dos dados.</p>
<p>Analisando a distribuição por formação (Tabela <a href="#tab:area-escolaridade">A.3</a>),
19 (55,9%) participantes são de outras áreas e 15 (44,1%) são da área de Letras;
no entanto, cruzando essa variável com as informações de escolaridade, notamos que o grupo majoritário são estudantes de Letras com Ensino Superior Incompleto (11 pessoas,o que representa 32,4% do total). Também destacamos que a amostra a nível de
indivíduos é pequena e possivelmente não representativa da população brasileira,
pois apenas um indivíduo tem nível de escolaridade abaixo do universitário.</p>
<p>Outras variáveis relacionadas à linguagem (línguas e música) também foram
transformadas em variáveis binárias, pois há interesse em entender se o
conhecimento nessas áreas afeta a percepção da tonicidade de palavras. A
distribuição das variáveis já agrupadas também pode ser observada nas Tabelas
<a href="#tab:linguas">A.4</a> e <a href="#tab:musica">A.5</a>, respectivamente.</p>
<p>Observamos no Gráfico @ref(fig:area_linguas) que, dos participantes que
têm conhecimento de outras línguas, mais de metade (57,7%) são do curso de Letras,
e todas as pessoas sem nenhum conhecimento de outro idioma são de outras áreas.
Isso pode levar a um confundimento do efeito dessas duas variáveis, pois não há
nenhum indivíduo que curse Letras sem conhecimento de outras línguas no estudo.</p>
</div>
</div>
<div id="variáveis-linguísticas-1" class="section level2" number="6.2">
<h2><span class="header-section-number">6.2</span> Variáveis linguísticas</h2>
<p>A tonicidade de produção (classificação da pseudopalavra) do tipo proparoxítona
é a menos expressiva na base (4%), enquanto a categoria paroxítona aparece com maior
frequência nas respostas dos participantes (57%), como visto na Tabela <a href="#tab:tonicidade">6.1</a> a seguir. Portanto, o processo de acentuação das pseudopalavras nesse estudo parece ir de acordo com a afirmação de <span class="citation"><a href="#ref-collischonn1999" role="doc-biblioref">COLLISCHONN</a> (<a href="#ref-collischonn1999" role="doc-biblioref">1999</a>)</span> de que</p>
<blockquote>
<p>Podemos considerar que o acento proparoxítono é marcado, no sentido de que é menos usual. É um acento especial, contrário à tendência geral de acentuar a penúltima sílaba.</p>
</blockquote>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<caption>
<span id="tab:tonicidade">Tabela 6.1: </span>Distribuição das respostas nos níveis da variável Tonicidade de produção.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Tonicidade de produção
</th>
<th style="text-align:left;">
Total
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
oxítona
</td>
<td style="text-align:left;">
4904 (39%)
</td>
</tr>
<tr>
<td style="text-align:left;">
paroxítona
</td>
<td style="text-align:left;">
7163 (57%)
</td>
</tr>
<tr>
<td style="text-align:left;">
proparoxítona
</td>
<td style="text-align:left;">
444 (4%)
</td>
</tr>
</tbody>
</table>
<p>De forma geral, comparando a tonicidade da produção e a tonicidade das palavras-alvo (vide Tabela <a href="#tab:tonicidade-pseudoxalvo">6.2</a>), nota-se que aproximadamente 73% das pseudopalavras classificadas como proparoxítonas tinham uma palavra-alvo de tonicidade proparoxítona. Entretanto, cerca de 77% das pseudopalavras que têm como alvo uma palavra proparoxítona foram categorizadas pelos participantes como paroxítonas (Tabela <a href="#tab:tonicidade-pseudoxalvo2">A.6</a>).</p>
<p>Além disso, nota-se também que pseudopalavras originadas de palavras-alvo oxítonas
e paroxítonas foram acentuadas de forma razoavelmente uniforme entre oxítonas e
paroxítonas, o que não ocorre com as pseudopalavras criadas a partir de palavras-alvo
proparoxítonas. Logo, pode-se pensar que pseudopalavras derivadas de proparoxítonas
não tendem a ser acentuadas com a mesma tonicidade da palavra-alvo (11,4%), enquanto
pseudopalavras lidas como proparoxítonas tendem a ser derivadas de proparoxítonas (73%).</p>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<caption>
<span id="tab:tonicidade-pseudoxalvo">Tabela 6.2: </span>Frequência da Tonicidade de produção por nível de Tonicidade
das palavras-alvo.
</caption>
<thead>
<tr>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="3">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Tonicidade da palavra-alvo
</div>
</th>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
</tr>
<tr>
<th style="text-align:left;">
Tonicidade produção
</th>
<th style="text-align:left;">
oxítona
</th>
<th style="text-align:left;">
paroxítona
</th>
<th style="text-align:left;">
proparoxítona
</th>
<th style="text-align:left;">
Total
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
oxítona
</td>
<td style="text-align:left;">
2642 (53.9%)
</td>
<td style="text-align:left;">
1939 (39.5%)
</td>
<td style="text-align:left;">
323 (6.6%)
</td>
<td style="text-align:left;">
4904 (100.0%)
</td>
</tr>
<tr>
<td style="text-align:left;">
paroxítona
</td>
<td style="text-align:left;">
2154 (30.1%)
</td>
<td style="text-align:left;">
2824 (39.4%)
</td>
<td style="text-align:left;">
2185 (30.5%)
</td>
<td style="text-align:left;">
7163 (100.0%)
</td>
</tr>
<tr>
<td style="text-align:left;">
proparoxítona
</td>
<td style="text-align:left;">
49 (11.0%)
</td>
<td style="text-align:left;">
72 (16.2%)
</td>
<td style="text-align:left;">
323 (72.7%)
</td>
<td style="text-align:left;">
444 (100.0%)
</td>
</tr>
</tbody>
</table>
<p>Observa-se na Tabela <a href="#tab:grupo-producao">A.7</a> que os grupos de classificação 2 e 4
(ou seja, os grupos em que as palavras sofreram mais alterações em relação à
referência original) apresentam uma proporção menor de proparoxítonas
produzidas quando comparados aos grupos 1 e 3.</p>
<p>O fluxo entre tonicidade da palavra-alvo e tonicidade da produção pode ser analisado graficamente por grupo de classificação na Figura <a href="#fig:tonicidade-fluxo">6.1</a>.</p>
<div class="figure"><span id="fig:tonicidade-fluxo"></span>
<img src="data:image/png;base64,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HRs3bjx8+PCIiAidTmd4tcC/w1JtcMA2OWo3Z169evWmTZsmhFi9enVubq60Mf/bwoMHDxYvXtyrV6+AgIAWLVq8+uqr+/fv1+v1xrt6YhmT3dKfWoj+lP4UAOCECBBhx3744YecnJyGDRsOHz5crkyDBg127969bds26S5gA41GM3LkyD179iiVyipVqhT20O+8886GDRsyMzOrVq2akpKyf//+UaNGff7558ZloqKigoKC9uzZc/369cqVK8fFxW3ZsqVXr15//vmn+Z1LS/YkJSUZPqA21qxZs3Pnzj1xJ9HR0TNmzMjNzW3ZsqWLi8tvv/02duzYL7/8sk+fPt9991358uW9vb0vXLgQEhKyf/9+y0987ty5I0aM+PXXXx8+fPjss89mZGQcOnRI2rNJSQtbWK/Xz549e+rUqb/99ltGRkZGRsbu3bsHDhx47Ngxk5InTpzo1avX5s2b4+Pjq1atmpSUtHv37t69e+/bt8/Cyu/du1ev13fp0uWpp57q06ePm5vb3bt3//rrLzM/0qlTp6FDhwoh3Nzchg8fPnjw4MK2Q3EU2IYWtsPy5cvHjx//008/paam5uTkREdHjxo1asGCBUWrieWNf+XKlddee+3y5csNGzYMCAhISEiIiIgYO3as8Xhm+/btAwcO3Lt3b0pKire3d2xs7KJFi0aOHJl/XGRQNg0O2BpH7eaeaNiwYT4+Pnfv3j179myBBe7evduzZ89169Zdv369WrVqeXl5x48fnzRpknGCY0kZS9Cf5kd/Sn8KAHBCBIiwY9Inuj179jQZNZlo165d165dn3rqKeONmzZtSktLi46OvnDhwuuvv17YQx84cKB58+Z//PHHmTNnLl68OGPGjLy8vNDQ0Li4OKnA7du3Z82apVar33777StXrvz5558XLlzo37///fv333rrLY1GY2bnzZs3f+qppzQazUsvvRQeHm7y2GUXFxdfX19fX1/zNTx58mRQUNDp06f37dt3/Pjx//znP3l5efPmzXvuuef++uuvH3744cSJE3369BFC7Ny508KzPnPmzJYtWzw8PLZv3x4XF3fkyJFz58599NFHQgiTUaWwuIX37du3fft2pVIZGhp6+fLl+Pj4n376qWLFitu3bzculpOTM3ny5JSUlClTply+fPmPP/64evXqu+++q9Vq33rrrYSEBEvqL91v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P/7445AhQ6RnrUhMhnzS7WZ28eg087ja4GoDsBf+/v5CiBs3bsgVSEhIMBQzdvbs2cWLFwshXFxcsrKyDE8ssUplLHTo0KF3331Xp9M1btx43759GRkZp06d2rVr16JFi3r37u08N8g7DGlu/p07d5xqZQ8AZSM6OrpZs2ZhYWEXL17MysrKysq6cuXKunXrmjVrZrzWqqen5+bNmxUKxfXr16VrcoOHDx9OmzZNCNG5c+epU6eWQWWMZWdnd+nSJSIiIiMjQwihVqsvXry4devWRo0aHTx40LikVqsdNWpU165d169ff/jw4bt37z569OjSpUs//vjjoEGDevbs6WwPNwcAG2HTAeKvv/4qhBgwYECeDKlYYGBg/fr109LSwsLCpJAoNzd32bJlGo2mc+fOcqsvbd++vVKlSn379jVsCQwMvHv3bkxMjPRtYmLiwYMH69SpY8n6TbaMqw2uNgA7Uq9ePSHE5cuXpeW0TGg0GumxyCar02o0mrFjx2o0mlatWkmfc8TExGzZssUqlbGctFyjSqU6cOBA//79TRbSMjx0C/aCufkASkl0dHS/fv3u37+vVCrHjRu3YcOGyMjISZMmqVQqnU43d+7c7du3Gwp37tw5ODhYCLFixYrTp08bts+aNSspKal8+fJffPGF+Zny4eHhWq12wYIFQggfHx+tVqvVamfNmlWEyhjMmzfv77//DggICA8PP378+I8//jh48GAhhEajGTlypHGXt2rVKmkPderUWbJkSVRU1DfffBMaGiqtL3z48OGlS5cWoy0BAEVkuwGiTqe7c+eOEGL+/PkDCmJ8c9DMmTN9fHxiY2NHjBgxa9asESNGnDt37plnnhk3blyBO09ISDhy5MiIESOMJzYOHDjQz89vzZo177777ocffhgSEpKbm2vvtyBxtcHVBmBf2rVrJ4TIzMyMiIjI/+qXX36ZkpIihDB5EsXSpUtPnz6tVCo3bdo0efLkDh06CCFmzpz577//ln1lLJeYmCiEqF27dv41E/V6/YkTJ4q2W1iCufnMzQfshU6nmz17thDC19f3wIEDkZGRr7/++rhx4yIiIo4cOSI9XnLBggVqtdrwI8uWLatVq5ZOp5swYYJ0tXz06NGNGzdKLz3xIWMuLi6urq7SzVgKhcLV1dXwJOIiVEbyzz//dOzY8eTJk8HBwW3atOnTp09UVNSoUaOEEMnJydIHcpK1a9cKIerVq3fq1Km5c+cOHjx40KBBc+bM+e9//ytN+TeZQwAAKBu2GyDeu3fP8nuHq1evvnr16hdeeMHT0/PatWsVK1YcMGDAypUrvb29Cyy/ZcuWmjVrdu3a1XijSqVasWJF375909PTr1y50qRJk5UrVxb4JE17wdUGVxuA3Rk5cqS04u3ixYuPHTtm/NLJkyfff/99IUStWrWM71COi4tbsmSJEGL27NlNmzZVKBQRERFubm6pqanTp08v1NFNJv0VoTKFIr01JSQkJCcnG2/Pzc196623pACRiKc0MDefufmAHdmxY4d0xTtv3jyT1ZnatGnz4YcfCiESEhIiIyMN2728vKQL+NOnT69cuTI3N3fSpEl6vb5Lly5Tpkwp48pIXFxcwsPDK1SoYLzR0IEaPv9Qq9VarbZGjRrBwcEmj0j28vLq0aOHEOKff/4pzikAAIrGdp/C/PTTT3///feWl69UqZLlV/AmwwCDcuXKvfnmm5Yf1MY9sYOfPHmy1MEbzlq62njhhRekq42QkJAyu9rIXxmJ3NXGtm3bhBDXrl1r2rSpsOBq4+rVq1xtALZPqVQuX7785ZdfTk1N7d69+9ixY9u3b+/i4nL8+PHIyEjpcSWhoaGGu30NNy8HBATMnz9f2ti4cePZs2cvXrw4KipqxIgR/fv3t+S4QohHjx5FRUUFBgb6+Pj4+fkVtjKFFRQUtHbtWrVa3aNHj/nz5wcGBqampsbHx4eFhV27ds3Ly+vRo0fJycl79uzp1auXydsgikyaDi+EUCqVo0aNateunVKpPH78+JYtW3Jzc+fOnfvss8+OHDlSKizNzQ8PD1+xYsXQoUNbtGghbS/U3PzPP/980aJFixYt8vHxefDggfjfIsuFrYzBvHnz/vnnn4CAgJCQkP/85z+pqalffPHFN998I83Nv3XrlvT3LP7v3PyJEydKEyqvXbv25ZdfXr58WZqb/8EHH5RU2xqM+mCw8bdqtVrKOj09Pe19ZRjLpaamenh4GK+17dgePHig1+tdXFwqVapk7bqUkaysLLVa7evrm/+l1cf/MHyt26IU94p1IOkTLG9v7wLHKePGjZs/f/6DBw+OHTtmXKBXr14TJkzYvHnzwoULz58/f/ny5fLly0dGRhbz2cdFq4wQonXr1tJFuzHDA6ANSzG4u7vfunVL7uj37hWvKQEAxWC7ASKKj6sNA642ADvSv3//1atXv/POO2q1esOGDRs2bDC85OPjExER8dprrxm2LFmy5MyZMwqFYuPGjcZB3rx583bt2nX16tXg4OAuXbr4+PiYP+jzzz8vfSHtfNmyZdKk6UJVprD69u0bHBy8du3aixcvGj92Q6FQhISE9OzZU4qWpJlihiV6URzG0+G//fZbwwda48aNGz9+fP/+/VNSUhYsWDBkyBB3d3fppWXLlkVHR9+8eXPChAknTpxQKpWFnZtv+Feam1+cykikufn79+83xMp9+vQZPXr0tm3bpLn5hn7TMDf/5MmTxp+uTZ069fnnn7969erBgwdLI0Dc9uE3xt/qdDrpSXdKpdLkXES+tBGwWcaxoBBCrVbrdDpPT8/SPq40Oy8gIKDA/F2lUjVq1Cg2Nvb69esmL61YseKnn35KSkqSltz9+OOPn/iWVXqVKfC+LsOnKXL0en1ycnJCQsKlS5diYmL27NlT1IoDAIqLANGRcbXB1QZgp6ZPn96nT5+wsLADBw7cvn1br9f7+fn17Nlz9uzZhs8PhBBxcXHS2qavv/56586djffg4eERERHRvXv3xMTE2bNnr1+/3vwR+/TpExoaun79+uTk5CpVqlStWrWwlSma8PDwvn37hoWFXbp06d9//61WrVr37t2nT58uzXQLCQnZunVrdnZ28Q8ECXPzDSdlO3PzTdJGE8SLKEsmEaGNkK6i69SpI1egdu3aBV5F+/j4hIeHv/LKK0KIVq1alcja7kWuTP7Vfs24ePHiunXrYmNjL1++nH8JWgCAVRAgOjKuNopWVQC2wN/f3/jZFAVq1qxZ/oVTDbp165b/6bQdOnSQe2TtnDlz5syZU+TKSDIzM+Ve8vPzK/DQQUFBQUFBBf7IqlWrVq1aZclxYSHm5hvYy9x8M/Ei2SKKzDaDQjlPfNK6tGqBtLCGibNnz0pfXLhw4ebNm7Vr17ZWZSx/w/z000/nzJkjLQHs5ubWokULf3//+vXrt2/f/vvvv1+3bl3haw0AKAEEiI6Mqw2uNgAAxpib70hz8/Nni0SKyM++ssIC+fv73759+8aNG3IFEhISxP8ezGXs7NmzixcvFkK4uLhkZWVNmjTp119/tVZlLHTo0KF3331XCNG4ceOlS5e+8MILxuuT/PLLL0XbLQCg+AgQHRlXG4ZXudoAAAjm5jv63HwiRQiHSAxN1KtX7+DBg5cvX378+HH+x/JoNBppMYSAgACT7dJDxlq1ajV27NgpU6bExMRs2bJlzJgxZV8Zy0kf0qhUqgMHDuR/r9NqtUXbLQCg+AgQHRlXGwbWutpwknGLTqdLS0vz8fFxc3Ozdl3KglarTU9PF0KoVCpvb29rV6eMpKenK5XKzefOmimTlf5QfFxmNQKKgrn5zjY33zhSdJJO2Qk5XmJool27dhs2bMjMzIyIiJgxY4bJq19++WVKSooQom3btsbbly5devr0aaVSuWnTpiZNmnz11VfHjh2bOXNm7969q1WrVsaVsVxiYqIQonbt2vmv5/V6/YkTJ4q2WwBA8REgOjKuNiRWvNowvzC8CQY2sKInjr5ycnJcXFzyPz4VsC/MzTe86oRz8006Zbpdu+bwoaGxkSNHLl++/NKlS4sXL27dunWHDh0ML508efL9998XQtSqVWvSpEmG7XFxcUuWLBFCzJ49W1oyNSIiokWLFqmpqdOnT9+1a5flRzf5GL4IlSkUf3//mJiYhISE5OTk6tWrG7bn5ubOmjVLuqSXPhQBAJQxAkRHxtWGsKurjSemjQx1UBxONdYC5DA334A7AQ3dLt2rHXHOvkypVC5fvvzll19OTU3t3r372LFj27dv7+Licvz48cjISGmScmhoqOETAsNbVkBAwPz586WNjRs3nj179uLFi6OiokaMGNG/f39LjiuEePToUVRUVGBgoI+Pj5+fX2ErU1hBQUFr165Vq9U9evSYP39+YGBgampqfHx8WFjYtWvXvLy8Hj16lJycvGfPnl69epk8jB4AUKoIEB0ZVxsOdrUhlzAy8oEJ5xxfAZZgbr6EOwGNkSTaPvq1/v37r169+p133lGr1Rs2bNiwYYPhJR8fn4iIiNdee82wZcmSJWfOnFEoFBs3bjS+tJ43b96uXbuuXr0aHBzcpUsXHx8f8wd9/vnnpS+knS9btmz27NmFrUxh9e3bNzg4eO3atRcvXhwxYoRhu0KhCAkJ6dmzZ79+/YQQgwYN6tmzZ0xMTJEPBAAoLAJEB8fVhjNcbbBmvJNjWAVYjrn5wq7m5pcxFky0KfRuJqZPn96nT5+wsLADBw7cvn1br9f7+fn17Nlz9uzZtWrVMhSLi4tbunSpEOL111/v3Lmz8R48PDwiIiK6d++emJg4e/bs9evXmz9inz59QkND169fn5ycXKVKlapVqxa2MkUTHh7et2/fsLCwS5cu/fvvv9WqVevevfv06dNbtGghhAgJCdm6dWt2dnbxDwQAKBQCRMfH1YYTXm0QKTowBlRAcTA338Hm5pceqSel97QKejo5/v7+a9asMV+mWbNmarVa7tVu3brlf3xThw4d5J7pNGfOnDlz5hS5MpLMzEy5l/z8/Ao8dFBQUFBQUIE/smrVqlWrVllyXABAySJAdApcbQinv9pgVoVdYygFlCDm5jvD3PySwt3NZYnODgAAW0aACDgdHkNpFxhHAaWHuflOODe/mEgSSxVdHgAAto8A6wLOeQAAIABJREFUEXB2DIpsCoMooGwwN184/dz8ouHW5hJElwcAgB0hQATw/3Gbs7UwggIA+8Jnb8VExwcAgN0hQARQAIZGZYMRFADYNSYkFhYdHwAAdooAEYA5JImlgeETADgSYsQnouMDAMDeESACsAhJYvExfAIAB0ZHWSD6PgAAHAMBIoDCYYBUWIydAMCpSB1l0LQe1q6IldH9AQDgSAgQARSRIUkcPn+gdWtisxg7AYDT2v1xtFKpHL94uLUrYgV0fwAAOB4CRADFtX3R7pycHJVKNXbRUGvXxVYwdgIACOdbHnFD3GlPT09r1wIAAJQ8AkQAJYa7m8kNAQD5OUP/uCHutBBCoVBYuyIAAKBUECACKHnOMFIyQXQIAHgih5yQSA8IAIAzIEAEUIqcIUlk4AQAKBSHiRHpAQEAcB4EiADKgsMMlgw2nj3j6uqqUqmsXREAgF2y656R6BAAAGdDgAig7DjGhMQ1J47n5ORYuxYAAEdgdzEi0SEAAM6JABGAFdhpksioCQBQGuwiRqQTBADAmREgArAme0kSGTUBAEqbzcaIdIIAAIAAEYBNYNQEAICwsQ6RThAAAEgIEAHYEJuakMioCQBgLVaPEekEAQCAMQJEALbIukkioyYAgC2wVoxIPwgAAEwQIAKwaWU5dmK8BACwQXSFAADA6ggQAdiB0p6QyHgJAGDjSjtGpCsEAABmECACsCclPnxivAQAsCOlESPSFQIAgCciQARgf0pkQiLjJQCAnSqpGJGuEAAAWIgAEYAdK1qSyHgJAOAAihMj0hUCAIBCIUAE4AgsHEQxXgIAOJjCxoh0hQAAoAgIEAE4DjMTEhkvAQAcGB+kAQCAUkWACMABGSeJDJYAAE6CD9IAAEApIUAE4LAOqdIPLdsohGjWtbG16wIAQNkxnpBIdAgAAIqPABGAAzqkSjf+Nu7weekLkkQAgPMYz6doAACghBAgAnAoJtGhCZJEAIAzMO4Npb6Pjg8AABQHASIAB2E+OjTBaAoA4JDkekM6PgAAUBwEiADsXqGiQ2NMSAQAOAxLekNiRAAAUDQEiADsWJGjQxMkiQAAu8Y0fAAAUKoIEAHYpZKKDk0wpgIA2JdiTsOnywMAAJYgQARgZ0opOjTGhEQAgO0rkQ6RGBEAAFiCABGA3SiD6NAESSIAwAaVeIdIjAgAAMwjQARgB8o+OjRBkggAsAWl2iESIwIAADkEiABsmtWjQxNxh8/r9XqtVtuoQ4C16wIAcCJl1iESIwIAgPwIEAHYKFuLDk1cOHbFxcXl+R5NrV0RAIDjs9YiHsSIAABAQoAIwObYeHRojFubAQClyrp9IjEiAACQECACsCF2FB2aIEkEAJQs2+kTiREBAAABIgCbYDvDpGIyJImCsRYAoEhss08kRgQAwJkRIAKwMtscJpUIpiUCAArF9vtEYkQAAJwTASIAq7H9YVJJIUkEAJhnX30i/RoAAM6GABGAFdjXMKkEcYMzAMCEXfeJTEgEAMBJECACKFN2PUwqWYSJAODkHKZPjDt8XqPRNOoQYO2KAACA0kKACKCMOMwwqTQQJgKAU3HIPvHCsSsKheI/PZtZuyIAAKDkESACKHUOOUwqPcZhoiBPBADH4vB9Ijc1AwDgkAgQAZQWhx8jlQ3yRABwGM7TM/KUFQAAHAwBIoCS5zwDpLJnkidKGJ4BgI1z2p6RCYkAADgGAkQAJclpB0jWVWCqKGHMBgDWRc8oiBEBALB/BIgASsYRzwyFQmHtWsCUmWzRwPyILqRteyFEenq6Uqn08vIybNc/WmNS8v6DrHlCCCGuXbv2xhtvFL6yKHnHjh2zdhUA53W0XKaLi4u1a2FDuK8ZAAD7RYAIoLgOezzUKrVK3k/sULfcikII8UuimTLbfvlGCNGw2S8KhcLV1VXaWODYT6PWSl/cvXt3w4YNJVtVFFPi/2PvzuObqvP9j3+SphttKUUQBGWTglAFgUEQelkEvYMoM16X0QuoLFZakTqLgIMLKpu7woACgoDiIIqCF/zNqJdFbhXEKkUpi0BZpChCrdA1bZrfH1/nTEzabE1yTpLX8zGPeaQnp+d8c4r55PvO9/s9J939lQEE1pb40tqYWrOQHtaPAYkAAIQdOvwA/PTvOVl2XdsBT35JCX1xRZ//ddpSW/urHx0HNn6dP0w9OFfexOfGIVQcR48CCBJmK/uEAYkAAIQRAkQAPqODZFh+ZIWKa2JYLy0rrJc2h71Dhw7Z2dn+tQSB9c477+zatUtEUlNT9W4LEMmojI1BkggAgPERIALwAR0kQ/E7LlQ8hoaOcWFVVZXZbI6L8+rIF1988dSpUxvTNgTKgQMHVIAIIEiojAFEkggAgGERIALwjN6RQTQyMRRPoaH7AYYAAEcUx+AhSQQAwGgIEAG4Q+9Id40PDaXh3JDEEAD8QHEMGZJEAAAMggARQD3oGumL0BAADIjiqCPHm3cRJgIAEHoEiAB+hd6RjsgNAcCYKI6GQpgIAEDoESACEKFrpKuA5IZSX3RIaAgAjUFxND7HMFF0yhNz+w9w2mIvW6A9XhJf9X1o2wMAQDAQIAJRja6RjsgNAcCwqI9hyilPlEZHiq7hoKa8vNxUsTAxMdFelt+YUwAAEBYIEIFoRL9IR4HKDYXoEAACjfoYeVwjRXFJFd2khI4cxxWKiMVqtTWmZQAAhBUCxEA6d+6c3W53v4/awW63//zzz252q6qqCmTLEDh2e537v472b8BqtZpMppA0ylvbk8p+eVQb+IPbbFH3Kdput9fWensp/6M8WT2okgD8192r3zYR0U7+1c7B/3omWG8ddXV1drvd/T/+6mreuIyrrKzMfd1Rf2L3+yixsbFNmjTx8rwVFRU1NTXu99HePcrKyty8bZaVlTX0FHRXXV1dFeP5HcBmsxnzE04w6qPdbq+rq6urqwvYEcOBT5VRF7+U4w2HHTcu/fWPt00fpR7E1Sxxcyi73e6xMorDJ0MYTVVVlfuqp/527muTYjKZmjZtGsjGAYDxECAGktls9v4jgtlsdvOs0YInODC5/+to/wZMJg97hsa/O0UiJglWe9SrNsLrDQ3Hv7LHnX/pqwTo2qjoUDucig5DcOHVK3X/eqPnH0A4MpvN7uuO3W43mUzu91F8+kN7c0wtYXG/szdtg17clzzHT0eGeqPQSmQw6iOVUXfaV3e/4ql1vfptO7T1E/f7ZGR2Fa//xD+VVqoHMTExHs6N0CotLfVYGUXEbDZ7EyAGsmUAYEgEiIGUnFzfx5RfKykpUZ20lJQUN7vFx8cHrl0IJJPJ5P6vY7Va1XfvsbGxen1SdJyBFSNBb4MaZBETExMlH57U6xURk8nk5k/876nKAfqv+V8TlmPEYapyyN4qqqqqzGZzXFycm32sNmuIWgPfNWnSxH3dqaysrKiocL+PHxITEz3uc/78eTUIMSkpyWJp8JOJ98MeEXpxcXFuiqPNZquurhaRmJgY928jIRCyEmm32z0G95HEm8oYbM6LhHhXIl3WA/Hc/v2fHRIRm81mt9vdvGspP/1U4VU7EHJHjx51X/Vqa2utVmuTJk08/pUBIBrwVgiEPRZsMpoArnKoOPZtWOUQAPxArYxUftdc13WEG6/eGp2c8E619ayIxMbGBvyM8ENdXZ361uryyy/Xuy0AEE4IEIHwQy/IsIgOAcAgqJURzAih4df5w6xWq81m8zjOOiH+lx3UWP5ANQB+W7Fixbhx48S72WMAAA0BImBo9H/CQsBzQ4X0EAC8R8WMbI0ptY3PDanCAAAQIAL6o88TvogOASD0qJvRQ6/ckOILAIATAkSD+umnn9SD+++//y9/+Yu+jYGjiqpyn/ankxOpMsuSYmJiAnWDFEdah4feCwBQRqNTI7+f8y86pOwCAOAGAaJB7d+/Xz2oqKioqODebQZSVlXu2JnpOSTDaQftLszx8fExMTGylZ5PpBlSlVpVVRWMIzPwEPDG119//dRTT+ndCoiInDhxovEHISKEoxAPOaTaAgDgJQJEg7r88svXr18vIjExMSy3bBA1NTUikpzWzDU0LNi6Vz1wfcp1S0O0g8CYtC5NndQF4/gMPATcO336tHqQn5+fn5+vb2PgpNZmUw/GPnartvGlHZ+qB7u3fFMbWysiZrM5JiYm9M2D8YVyyCF1FgAAPxAgGlRKSop6sGTJkvHjx+vbGCgmk0lEEpo0cX3KKSUszDsoIhaL5cqhl3t/fI9RIwmjXoK00KEj0kPAI4InI/t5SGtp2bJg694t85Y6PdVzSMYVg7pVV1eLiMViiYuLa+gglLnoFLLokAoLAEBjECACgdd9YBcRiY//ZXk8N+MTfdLQr9PjCh6iQ8A4LrjgAvWgU6dOAwYM0LcxUD788EM1MjTGYpH66lTB1r0FW/fa7Xa1uEePwd3dHM19laTYRZjGV1gvo0PKKwAAAUGACASdY48oUGFiQ8d3Ogv8FoLoUEgPAb8MGjTotdde07sVEBEZPHiwNrW8XqpC2Ww2NQLxm+37HUeS+lQK+RYtYoQmOqSwAgAQWASIQEgFO0xs6ID0r7wXmuhQSA8BRJ/L/+MybQqzGpyoPeV3KaTkhZGAVFiP6SFVFQCAYCBABHTjGiYGPEl0cy64Cll0KP/q/9DJARC1nEpeAL9Ua+jI0BHRIQAA4Y4AETAErbcT7CTR9eD0rCS00aGQHgKAC6c66LQxIEd2PT5CIFAV1k16SD0FACAECBABYwllkljvGaONLtGh0NsBgAY4VqVgLxwcnYUvNAJYXokOAQAwAgJEwKAce1AhiBEl+vpUIY4OhfQQAHwRgoU+ovwrtCAJTXQoFFMAAEKLABEwOtW9CdmARMeTSoT2qUIfHQrpIQA0gmMplCDffCwiC19oZJYlmUwmSQzM0Rh4CACAoRAgAuEh9AMSXc8bspMGjy7RoZAeAkAghGaVD6ewEt4YWt2soqIigAdsKD2kjAIAoBcCRCDMaB2bUMaIEv5Jol7RoZAeAkCgBXtAooR/1QuZYJTXetNDaigAAPoiQATCkl4xooRhn0rH6FC44TIABE0oByRK+FS9kAlZdCiUUQAADIAAEQhjOsaI4tCn2r3lm9Cf3Rv6RodCeggAIRGaxYJJEjVBKq8MPAQAwMgIEIGwp2+MKCI9BnevqqqKj4//Zvt+XRrgSvfoUEgPASC0QnbPsWheJDF45ZX0EAAAgyNABCJEzyEZIb5Tc71tUA907FYZIToU0kMA0EnIvlSLwhgxlAMPhRoKAIDBECACkUP3oYhOLZHQ9qwMEh0K6SEA6C1kX6oZ4ZuzEGDgIQAAIEAEIo1xYkQJVc/KONGhkB4CgDGEbEaz6+kiSVArLOkhAABhxKx3AwAEhTb4wiB6DskIRv9taHUz0kMAQENCnOsFqdjpItgVlvQQAIDwwghEIGIZsA8TwAGJhsoNFdJDADCgEA9F1M5SWVm5/7NDIThdwIWgwpIeAgAQdggQgchnkOnMjhqTJBowOhTSQwAwNjUwP8QF8fL/uCw2NtZQEwLcC02FdU0PqZ4AABgfASIQ+VSvyWgZouJTkmjM6FBIDwEgHOi1RnBYLI8YsgpLeggAQJhiDUQgKhhtSURX7teNMtpah45IDwEgjOhVEA27PGIoKyzpIQAA4YsRiEC0MGa/xYnrgETD5oYK6SEAhB0tQwx9ZTTUaMQQV1jSQwAAwhoBIgAj6jkkI7f/ABF5/fG39W5Lg3r12yYSQ/8HAMKOXtOZnc4e+lNrSA8BAIBPCBCBaGTYJREVFR0qYx+7VQwZI/bu/wmrQABAWNN3jeDG3E+sMUI/tJ/0EACACECACEQjY95WxTE3dKJiRDFMkti7/yfqAV0gAAhrRiiIIRuQqMuqIE7pIXUTAIAwxfAZIEoZ6rYquf0HuEkPHY197FYtTNTdVzsH690EAEBjGaQgBvUuK3rdi4z0EACAiMEIRCB6GWHYhZe5oRN9ByT2+M3m2lr5csegmJjQnxwAEHhGKIhaSySgoxF1vBcZ6SEAAJGEABGIajp2mfyLDp2EPkm8os//2u3y5Y5BoTkdACA0jJMhSoBiRB2jQyE9BAAg4jCFGYh2oZ+65f2EZe+FZmqz6g7t+eKaYJ8IABB6BpnLrGnMpGbSQwAAEFiMQAQQumEXAc8NnQR1QKLqDn2dP0ykLuAHBwAYgaHGISq+jkbUNzoU0kMAACIUASIAkeB3mYIdHToJeJLokB4CACKZATNE8S5G1D06FJHe/T9x7F9QNwEAiBgEiAB+EaQuU4ijQycqSWxkjEh6CABRxZgZojQcIxohOpRf0kOT9iN1EwCASEKACODfAttl0jc6dNSYAYmkhwAQhQybIcqvY0SDRIfyS3r4b9RNAAAiDAEigF8JSGfJONGhE1+TRNJDAIhaRs4QRWT59HskOGv++uGKPv9bU/PvH6mbAABEHgJEAIFk2OjQiTdTm0kPASDKGTNDdCy1AVmpo5G4awoAANGAABFAANzT48rU1NTY2Fi9G+KboN61GQAQAYyWIdb7RZ2OMaJTevjljkGJiaFvBQAACDoCRACNktt/gM1m++mnn/RuSKO4JokMPwQAKAbJED2O8Q99jOiaHppMDe0LAADCGwEigAa57y+Fy2xln6je1+6Nk4T0EABgDD4V3JDFiK7pYbDPCAAAdESACKBBDY25iMjoUGMvW9BzSIYp+f4rb2BqMwBARL9BiH4X3GDHiPWte1gRpHMBAAAjIEAE4I5jlymyc0PFXrZAREzJ96sfWSQRAKCEOEMMSM0NUozIXVMAAIhCBIgAPOg5JKP5P09qUVoEc0oPHZEkAgBCkyEG/Ou6wMaIpIcAAEQnAkQADfp3H6a/ru0ICTfpoaOxj91aW1tbWlq67plNIWkXAMBAgpohBnWkf0BiRNJDAACiFgEigHpEw2xlR16mh45ufnBkfHz8+uf/EbRGAQCMKEgZYmgqb2NiRNJDAACiGQEigH9z33t5/fG3o2Eis0+Y2gwAaKTQf2nnR4xIeggAQJQjQATgbddl7GO3RmSG6MfwQ1ckiQAQPQI1CFHf8f7ex4hO6SEAAIhCBIhA9PKj3xJ5GWJA0kNHjheHMBEAIlUjM0TjLBXiMUZ0TQ8ZfggAQBQiQASiTiM7LaSH3mNYIgBEMP8yRONEh468H41IeggAQHQiQASihTF7LDoKdnroiCQRACKST+mh8Quxa4zI0ocAAEAhQAQiWfD6KuE+kTmU6aEjJjgDQITxZhCi8aNDR1qp2r1xkuN20kMAAKIZASIQUULWRQnrxRD1Sg+dECYCQARwP5E5vKJDR/ayBepFFWzdK6SHAABEPQJEILzp2DMJ6wzRaAgTASB81ZshZvXslZCQoFeTGkl906b0HJJhSr7/63xqEwAAUY0AEQgnRhvIEI7poUGGH7rhdFXJEwHA+BzTQ1WsS0pK9GtOozimh/Kviun9XVYAAEBEIkAEDMpoWWFkMH566Io8EQDCQsHWvcun36N3Kxqr3vRQQ4wIAEDUIkAEdBMxEeEbT7wz8v4wWBopHNNDV/WO+qQvBwD6yu0/QPoPCPeVPdynhxpiRAAAohABIhB49/S4UkSaNm0aFxend1tCYcyjt7z61zfGz/pvvRviTmSkhw1x01+lgwcAweP0XWBYrw7sZXqoIUYEACCqECACgbd0z24RiY+Pj4mJ0bstjeXlMMmbHxwZ7JY0RmSnh+5504+l+wcAvmqoPkZJeqghRgQAIEoQIAJw56Udn3rcp66urqqqyrCB6VXN1ovI56W/F/H8WryhXq+IxMTExMfHOz4VptPSvenulpaWWiyW5ORkbQvdRQDRyeNbfdgNQnRKD/0w9rFbz549a7fb3332g4A0CQAAGA0BIoCAKdi61/E2lFHIm7w1TFVVVZnN5l/Nyv/Ptk77lJf+LE+HtFUAEEpefkukJjKHxerA9WrMgP1bpt7QvHlzvmECACDymPVuAIDI0XNIRsHWvXq34lcchh8CAOCP3P4D1P+8/5Wxj936ztMbg9ekAPJ78rIbYx+7NbzGYAIAAI8YgQggkAw1ApH0EADQGGG6MIX3gpEealgeEQCASEKACCAykR4CAPwTkNzwlqk3rJmzfvys/278oYIkqOmhRhuKSJIIAEBYYwozgMDTfSIz6SEAwFd+TFV27/a//t6wqVlo0kNHzGsGACCsMQIRQOCpxRD1ms5MeggA8F5Q5ykbMzILfXqoYUAiAABhigARQFDouxgi6SEAwL2QrW/4+uNvGypG1DE9dMQKiQAAhBcCRAARRQ0/BADAlS43RRn72K3GyRANkh5qGJAIAEC4IEAEEEQhnsjM5GUAgBMj3EnZIBmi0dJDRySJAAAYHAGis++++05ELr74Yr0bAkSCUC6GSHoIABBjJIbwG0kiAADGFE4B4ubNm1955ZX58+e3bt3a9dmqqqo33nhjx44d586du/TSS6+88spbbrklJibGcZ/Kyspt27YdPXq0RYsW/fr1u+SSS5wOcvr06SlTptx5550EiECgkB4CAIIqLBJD3QchGnn4Yb1IEgEAMJRwChA/+uijqqqqep86c+bMk08+WVRUJCKpqal79+7du3dvQUHBQw89lJKSovY5duzYk08+efr0afXj6tWr77nnnuuvv97xOKtXr05LSxs5cmQwXwcQdYI9CJH0EACiRFhkhQ3RMUMMu/TQEUkiAABGEB4BYkVFxZo1a/bu3dvQDi+88EJRUVFGRsaf//znFi1aFBcXz549+5tvvlm2bNkDDzwgInV1dc8+++z58+enTp3ap0+fU6dOLVq0aOnSpZdddlmnTp3UQY4ePbp169bc3NzY2NgQvTAgOgR1IjPpIQBEnrAOCt0gPWwMp6tHnggAQCgZPUD8+OOPP/zww6Kiourq6ob22b9//9dff52cnPzXv/5VjTds06bNo48+OmnSpC1btowePbply5bHjx8/duzYnXfemZmZKSKdOnWaOnXqxIkTP/vsMy1AXLlyZbt27YYOHRqalwZl4sSJy5YtE5Hp06fPnTtX7+YgWEJ5KxUACGvRUBkjNR/0RogHIUZMeujK8TISJgIAEGxGDxCPHj1aXFwcHx8fHx9//vx5u93uus+nn34qIr/5zW+02coi0qpVq27dun3zzTc7duy48cYbz58/LyLNmzfXdmjWrFlMTExpaan68euvv87Pz3/00UdNJlNwXxIcbNq0SfWR5s6dO336dLXxxIkTx48fj4mJ6d+/v66tQxhg+CGACBO+ldFNJmi1Ws+dOyciiYmJSUlJIWyUEYVyInMEp4dOGJwIAECwGT1AnDhx4sSJE9XjMWPGqE+fTg4fPiwivXv3dtreu3fvb775Rj176aWXxsfH/8///E///v2bNGkiIu+8847NZsvI+GVU1MqVKzMyMn7zm98E77XAydmzZydOnGg2m//2t79lZ2dr25cvXz5z5sxmzZr99NNPOjYPwRDYicykhwAiTFhXxpd2fNrQUzabTU0lsVgscXFxIWxUcPk9jpL0MNhcrzCRIgAAjWT0ANEbxcXFItKiRQun7WrLyZMnRaRJkyYTJkxYtGhRVlZWt27dvv/++2PHjvXo0WPw4MEikpeXd/DgwWeeeSbkbY9q2dnZZ86cWbVq1ejRo/VuC0IkgIshkh4CiDxUxvDiJjMVkcrKSovF0tDK2v5VQ+8jy2hOD+vVUGhLsAgAgJciIUAsLy8XEcf5y0pycrKIVFRUqB9/+9vftmjR4p133vn6668vuOCC22+//dZbbzWZTDab7Y033hgwYEDXrl0b2ZLS0tJ6J1k7qqurExG73e5+EEFlZWUjG2Nwdrv9mWeeWbBgQatWrfRui2/q7HXu/zravwGr1RqSFhmFl6+3S79Ojf/nPbDFxtoayTtzg4ie/6XYbLaI/09VY7fb6+rqbDabm30qq6LlaoSj8+fPu687drvdY21SYmNjVYX1RllZWU1Njft9VGUUkXPnzrlZSEStRhLBwrcyikhlVVWMF++HtbW17t9GIondbq+tra2tra332S79OuV/XNB9YBefjjlvy/96s9vAFhsdf8w7c4OIV7+oufdK55k9HqnPP3V1dUYeJ+vqhinD3Tz79lP/4/7X7Xa7x08CdZ56B9BLZWWlx8oonmqTYjKZmjVrFsjGAYDxREKAqHomiYmJTtvVVGXHu6/85je/cZ2k/OGHH546derhhx9ufEtsNpvHANFxZzfPar0pJ2VlZYmJiTExMT43zmt1dXU//vhjsHsvJpOpffv2QT2Fk5qaGqvV2qRJk8Yvc+nlX9n7fwyRwfvXW5h30Ncuk6OBLTfZRfJ+HCmi/xXmr+z9s9CXx/xX8WYfn2qQl+fVdnbzbEPHoTL6LbCVkeLoyv2L7TYgPUhXw+mgfpzlla/yA9UYn9zT40pdztuQ//rL9d7stu6ZTe6ejqZ/8+HFywrlvjYpLKMPIBpEQoCYkpJSWlrq+u2fGnvoOjLRUXV19Zo1a6699tq2bduqX1m1atWXX35ZXl7etWvXu+66K8Qf5V1NmDDhmWee2bdv3+rVq2fNmrV//34RadGiRUZGxujRo8ePH19vl2nbtm1r1qzZv3///v37y8rKLr744k6dOo0fP/73v/+90/6xsbG1tbUbN24cOXLkhg0bHn/88W+++eaZZ57Jzc3V9ikuLn7qqac++uij48ePi0jbtm2HDRt23333aStIikhlZWWPHj0OHTp06aWXfv3110557rvvvnvzzTeLyPz58++//5dJNHl5eeqm2F988UWfPn1EJDs7+5VXXlHPlpaWqko8b968adOm+dQYJSUlpaysbP369cOHD//zn//897///dy5c3FxcZdeemnfvn0feeSRzp07+3Tp3P6h4IPuA7s0MkMEEM1WrFixY8cOKqNPjVGojEYTjGo4sOWvwqy8H0cG9vhBtXTPbr2b4JcgHk5CAAAgAElEQVT/bOvmSdtbsXI2ZE0BACBYIiFAbN68eWlpaVlZmdN2tSUtLc3N727YsKGiouKOO+4Qkerq6j//+c8nT57s3Llzq1atCgoK/vjHP86bN69LF28/2F1wwQUe9ykpKamrqzOZTO53drpH4ezZsx3HSJ45c2bbtm3btm1btmzZpk2bHA9VW1s7bty4N954w/HX1Yf+Dz74YMiQIR9++GG9y/EsWbJk0qRJrt9Rb9y4cdy4cWfOnNG2HDx48ODBg0uWLHnyyScfeughtTExMXHZsmVDhgw5fPjwzJkzn3rqKW3/n3/+WXWNBg0aNHnyZDev2iMvG+OosrJy8ODB+fm/fJFutVr37du3b9++v//97//4xz+uueYabU+Pl05tMZvManBrQ6xWq5qvFB8fH9QRMcZRV1dXVVXl0+v9zbV+DjG4qtl6kdjPS3/v9o8QXOr1ikhMTEx8fLxu7Qitqqoqs9ns/u4HdquHmarQUWpqqutiwY4qKysrKiq8KWQ+adq0qcd9zp8/r6YLNGvWzGJp8JOJ0+wwKqNPjXEUwMqoXZwmiYluimOk3kTFPfdrICq/ufbKINxe7N9nDGW5VN/cm0wm11lBkcpqtdpsNo+v12xmbJpBJSUlua+MtbW1paWl7msTAESPSHgrVD2KkpISp+1qSQs3faFz5869++67o0aNat68uYi8++67J0+evO+++/7zP/9TRI4fP/7ggw++8sorzz//fBBb74Vjx4498sgjItKnT5/f/e53HTt2/PLLL9euXXvy5MmdO3feeuutmzdv1nZ+8cUX1Qf9jh07Tpw4MT093WQyHTp0aMWKFQcOHNi6deucOXMee+wxp1N88cUXs2bNuvDCC6dMmdK5c+eBAweq7Rs3brzxxhtFxGKxjB079uqrr7ZYLDt27Fi5cmV1dfVf//rXSy65ZMyYMWrnQYMG5eTkLFy48Lnnnrv99tt79eqltk+dOrW4uDgpKem1115zP7x/4cKFf/vb35544oknnngiNTX17NmzImI2m/1ojGbGjBlHjhzp0qVLbm5unz59SkpKXnvttbfffrumpmbMmDHHjx/XPhB4vHQ+/dUQDNw4BYBCZfSjMZoAVkbdJ2pEgECnh/9GuQQAAAEUCQFiu3btvvzyy927d//Hf/yH4/aCggIR6dixY0O/uHbt2piYGDWBSES++eabVq1aqfRQHfaaa6754IMPKisr9f0qVc3OHjdu3OLFi9X32GPGjJk+ffpNN9306aefbtmy5eOPPx4+/JcVoBctWiQinTt33rVrl+NgjcmTJ/fu3fvbb7/dvHmzazdp9uzZAwYMWL9+veOATZvNpmZIpaWlvffee+qO1aol48ePHzVq1OnTpx999NHbbrtNG00wb968jRs3Hjt2bMKECZ9//rnFYvnkk0+WLl2qnurUqZP7V6p6ROr/TSaT43A2PxqjHDlyJDMzc9OmTdoomBEjRtx5552vv/76qVOnCgsLe/To4eWlc994+MGnYRekhwA0VEb/GqMEsDKWlpa6bz+8EZBBiKSHAAAgqMx6NyAArrrqKhH54osvHO+Xcu7cua+//jouLk77PO3k9OnTH3zwwW233eY448ZpFID6vO7NurnB1q5dO62PpFx44YVr1qxRXQKt26Mmz1588cU5OTlOU72Sk5OHDRsmIkeOHHE9fm1t7fz5852me69evbqwsFBEZsyY4XQZ+/Xr9/jjj4tIUVHR8uXLHc+iOkVfffXV888/X11dnZWVZbfbBw8efN999zXmCvjRGMVsNi9cuNBpDl1WVpZ6cOjQIfXAm0uHgCM9BOA3KqMRKqNazwGN1HNIRsHWvY05AukhAAAItkgIEC+//PKuXbv+9NNP8+fPVzfSqq6unjdvXk1NzaBBg5wWE9S88cYbzZs3v/766x2P8/3333/00Ufqx5MnT27evLljx44NHSGUHnjgAdc1dC655JKxY8eKyGeffaY+wcfFxR0/fvzEiRN//OMfXQ/y448/NnT8fv369ezZ02ljXl6eiKSkpEyaNMn1V8aNG6emh6vdNNdee+2ECRNEZObMmVlZWQcOHEhKSlq+fHkj703mX2NE5KqrrtJGUmi0KVfa4k1+XzqEAOkhAFdURipjJGnMCETSQwAAEAKRECCKyJ/+9KfU1NTt27ePHj166tSpo0eP/uabb9q0aTNu3Lh69y8qKtq2bdvo0aMd+x7/9V//1bZt2wULFjz44IOPP/54bm5udXV1dnZ2qF6EO3379q13+4ABA0TEbrcXFRW5Pmu324uLi/Py8pYtW3b77bevW7euoePXO4VKjUHo0qVLvRFqfHx89+7dReTw4cNOTz333HNt2rSprKxctWqViDz99NMep2h55Hdjunbt6rq/tnpUQ7y/dGg898MuSA8B1IvKSGWMMP4NQiQ9BAAAoREJayCKyEUXXfTSSy+9+eab+fn5hw4dat68+YABA26//faGbgi4cuXKdu3aaffVVeLj45977rlVq1bl5+cXFxdfccUVd911V4cOHULQfo8aWslR634cPny4W7du6vG+fftefvnl7du3HzhwQK0S5VG7du1cN6qeiZtFJDt06LB9+3bXnklqaurChQtvuukmEenbt29AQli/G9O6dWvvz+LHpUPjqalbAVxFHkA0oDJSGSOMH9WQ9BAAAIRMOAWI6j6ADWnevPnkyZO9PNTMmTPr3d6kSZN65wEZljaCUvtM/+yzz06fPl1N5Y6Nje3Vq1d6enrXrl0HDBjw/vvvv/zyy/UeJyEhwXWjNompIeoujfWuf7Rnzx71oLCw8NixY43PYf1ujPcTxPy7dAiIhvpLDD8E4Csqo8fGUBkNi+/SAACAYYVTgBjNioqK2rZt67pdW+k8PT1dRLZs2fLggw+KSEZGxpw5c6677jrH/s8///lPn06anp5+4sSJo0ePummVdmpHe/bsmTVrloiYzeby8vKsrKwPP/zQp1MHsDFeCuylQ0CQHgJwg8pIZYxI3g9CZPghAAAIpQhZAzHi5efn17v9888/Vw86d+4sImplpfj4+I8//njUqFFOoydqa2t9Oqk65oEDByoqKlyframpUTd/7NKli9P2u+++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mz179sMPP6z9eObMmW3btm3btm3ZsmWbNm1yvNtvbW3tuHHj3njjDcdf379///79+z/44IMhQ4Z8+OGH9d7JdMmSJZMmTXIdoLdx48Zx48adOXNG23Lw4MGDBw8uWbLkySeffOihh9TGxMTEZcuWDRky5PDhwzNnznRM/X7++ef7779fRAYNGjR58mT/r4LXjXFUWVk5ePBgLaO0Wq379u3bt2/f3//+93/84x/XXHONtqfHS9ehQ4fGNN6Yfvvb37722mt6twIIItfbLvcc8ssdmfVqEgAAiHIEiAB04Gt6SK8p7Bw7duyRRx4RkT59+vzud7/r2LHjl19+uXbt2pMnT+7cufPWW2/dvHmztvOLL76oIrCOHTtOnDhRjQo8dOjQihUrDhw4sHXr1jlz5jz22GNOp/jiiy9mzZp14YUXTpkypXPnzgMHDlTbN27ceOONN4qIxWIZO3bs1VdfbbFYduzYsXLlyurq6r/+9a+XXHLJmDFj1M6DBg3KyclZuHDhc889d/vtt/fq1Uttnzp1anFxcVJS0muvvWYymdy80oULF/7tb3974oknnnjiidTU1LNnz4qI2Wz2ozGaGTNmHDlypEuXLrm5uX369CkpKXnttdfefvvtmpqaMWPGHD9+3GKxeHnptFcEIFy4pofqAXUQAADoiAARQKj5MfaQXlPYUTOCx40bt3jxYjV4cMyYMdOnT7/ppps+/fTTLVu2fPzxx8OHD1c7L1q0SEQ6d+68a9euZs2aaQeZPHly7969v/32282bN7sGiLNnzx4wYMD69evT0tK0jTabbdq0aSKSlpb23nvvDR48WG0fN27c+PHjR40adfr06UcfffS2226Li4tTT82bN2/jxo3Hjh2bMGHC559/brFYPvnkk6VLl6qnOnXq5P6VqqxQ/b/JZHKcV+tHY5QjR45kZmZu2rSpadOmasuIESPuvPPO119//dSpU4WFhT169PDy0p06dcp9+wEYSkPpocLXaQAAQC+sgQggpJi5HD3atWunpYfKhRdeuGbNGhWWaYGg1Wqtra29+OKLc3JyHCMwEUlOTh42bJiIHDlyxPX4tbW18+fPd0wPRWT16tWFhYUiMmPGDC2wU/r16/f444+LSFFR0fLlyx3PouLCr7766vnnn6+urs7KyrLb7YMHD77vvvsacwX8aIxiNpsXLlyopYdKVlaWeqCthOjNpTt//nxjXgKAUHKfHopIzyEZ3FsMAADoggARQOg0Mj2k1xReHnjgAdeFCy+55JKxY8eKyGeffVZVVSUicXFxx48fP3HixB//+EfXg/z4448NHb9fv349e/Z02piXlyciKSkpkyZNcv2VcePGqbUX1W6aa6+9dsKECSIyc+bMrKysAwcOJCUlLV++3P3kZY/8a4yIXHXVVdoYQ0379u3VA23NR78vHQAD8pgeKoxABAAAuiBABBAijR97yMiL8NK3b996tw8YMEBE7HZ7UVGR67N2u724uDgvL2/ZsmW33377unXrGjp+vZOL1ei8Ll26JCUluT4bHx/fvXt3ETl8+LDTU88991ybNm0qKytXrVolIk8//bTHycse+d2Yrl27uu6vravYEO8vHQCjcUoP3aMUAgCA0GMNRADhhJEXYaRjx471bteCucOHD3fr1k093rdv38svv7x9+/YDBw6o9RM9ateunetGldk1dGoR6dChw/bt210zu9TU1IULF950000i0rdv3+zsbG/a4J7fjWndurX3Z/Hj0gEwOPdftqmv0yiIAAAglBiBCCAUArj0ISMvwp02r1lLu5599tkrrrhiwYIFu3fvrq2t7dWr12233fbII4/8v//3/9wEeQkJCa4btem9DVH3L1azp53s2bNHPSgsLDx27JgXL8UDvxvj/dRp/y4dAEPxcvKyI9JDGM3EiRNNJpPJZHrooYf0bgsAICgYgQgg6AJ74xRGXoSLoqKitm3bum7X7gGSnp4uIlu2bHnwwQdFJCMjY86cOdddd51jMvjPf/7Tp5Omp6efOHHi6NGjblqlndrRnj17Zs2aJSJms7m8vDwrK+vDDz/06dQBbIyXAnvpAOjCj/RQoRTCODZt2rRs2TIRmTt37vTp09XGEydOHD9+PCYmpn///rq2DgAQGIxABBBcwbjtMl2msJCfn1/v9s8//1w96Ny5s4ioNQfj4+M//vjjUaNGOY0rrK2t9emk6pgHDhyoqKhwfbampkbdFrlLly5O2+++++6ampq+ffsuWLBARD766KOVK1f6dOpANcZ7gb10AELP7/RQWBcYhnH27NmJEyeazeZFixZp6aGILF++PDMzc8SIETq2DQAQQASIAIIoGOmhQq/J+F544QXXDKu4uHj58uUi0qNHj+TkZBE5efKkiHTo0MF14T+73a6ljV66+uqrReT8+fOLFy92fXbFihWnT58WEafREHPmzPnqq68sFsurr76anZ09cOBAEfnTn/70ww8/+HT2gDTGe4G9dABCrDHpocLXaTCC7OzsM2fOrFq1iqUzACCyESACCJbgpYfCyItwcOzYsZycHMcM8cyZM3fccYda8u/JJ59UG9UE3qKiolOnTjn+enV19QMPPKBSMJvN5uVJx4wZc9lll4nIrFmz8vLyHJ/atWvXI488IiLt27fPysrSthcUFMyePVtEpk2b1qNHD5PJtHjx4tjY2JKSkilTpvj0kp0CUz8a4xNvLp3HdRgB6KLx6aFCKYS+7Hb7M8888913340ePVrvtgAAgosAEUBQBDU9VBh5YXCJiYlLly7NzMycN2/eW2+9NW3atD59+nzyyScikpmZOWrUKLXbyJEjRcRqtQ4bNuzNN9/cs2fP1q1bFyxYcPnll8+fP1+NUjx16tS6devOnTvn8aQWi+Wpp54SkZKSkmuuuebee+9duXLl66+/ft999w0aNEiNKJw7d64221ebvNylS5eHH35YbczIyJg2bZqIrF279v333/fmxarboZSVla1du7awsFCNDfS1Mb7y5tLVO3sagL4ClR4KX6eFrbKyMu+/G/NPXV1dI8fRe8NkMrVv375Vq1bBPpGmpqamvLycr8cAIPQIEAEEXgjSQxjfe++9l5aWtnPnzoceeuj2229/+umnjx8/LiI333zzpk2btN2uv/76nJwcEdm3b9/o0aN79uw5dOjQKVOmHD58ODc39+9//7va7ZZbbrn55pu9Oe+oUaNeeuml2NhYq9W6ZMmSu++++84771y0aFFVVVVqauqaNWvuuOMObefZs2fv3r3bZDItXbrUMcibMWOGGt+Xk5Pz888/ezxp79691YM//OEPGRkZb7zxhh+N8ZWXlw6AoQQwPVT4Oi1cZGRkiMjq1au7deuWkpJisVhatmw5ZMiQpUuXNhQmbtu2LTs7e+jQoRdddFFKSkq3bt1Gjhy5bt061/1jY2NNJpMqrxs2bOjdu3dCQsKaNWsc9ykuLs7Nze3evXtycnJycnLXrl1zcnL27v1VAF1ZWZmenm4ymTp37lxZWel0lnfffVfdalmtF6zk5eWpjdrax9nZ2SaTaebMmSJSWlqqnlXfqPnUGCUlJcVkMm3YsKG8vHzSpEktWrRITk5OSEjo3r37XXfdpd2Zze9LBwDwEgEigABz6hoFGyMvDCszM7OwsDA3N/fSSy9NSEhIS0vLzMx89dVX33nnnaZNmzruuXDhwo0bN1533XXt2rWLj49v167d3XffnZ+f/+KLL95www25ublpaWkJCQnt27f38tRTpkzZu3fv5MmTL7vssqSkpCZNmqSnp2dnZxcUFPzhD3/QdisoKJgzZ46I3HPPPYMGDXI8QkJCglq48OTJk2o0onsjRoyYO3du+/bt4+Li2rRp07JlS18b4x+Ply4+Pr6RpwAQQAFPDxVKYbiYPXv2mDFj9u/fr348c+bMtm3bsrKyBg4cePbsWcc9a2trx44dO2TIkFdeeWXr1q3ff/99WVnZ/v37P/jgg1tuuWX48OE1NTX1nmLJkiU33XTTV1995bTDxo0be/bsOX/+/H379pWXl5eXlx88ePDll1/u2bPn3Llztd0SExOXLVtmMpkOHz6sEkDNzz//fP/994vIoEGDJk+e3Jjr4GVjHFVWVg4ePHjx4sVqOoLVat23b9+qVau6d+++efNmxz09XjoyRADwj4nh3yFWUlJSV1dnMpkuuOACN7s9/fTTqsu6bNmy8ePHh6p1cMdkMolIq/btH1rzppvdrFarWgctPj4+JiYmRI3TVV1dXVVVlfZ6I374oXq9IhITExM96UxVVZXZbI6Li3OzT3npzzNGXK/9WFZWlpSUFPymwZ0JEyaou9bk5eUNGDDAzZ6VlZUVFRXua1OQnD9/vrq6WkSaNWumJoPXa8eOHeq+NHffffdrr70WuvahYYMHD1brEsz6YGNyWlpDu9lsNvUntlgs7t9GIkllZaXFYomNjdW2BCk9VAq27tV3KKJaMMFkMiUmJurYjFCyWq02m83j653336O/LzoqIomJiVVVVXa7vU+fPr/73e86duz45Zdfrl27Vq16MXToUMcg7Nlnn33wwQdFpGPHjhMnTlSjAg8dOrRixYoDBw6IyMyZMx977DFt/9jY2Nra2pkzZ86aNeuCCy6YMmVK586dBw4c2LZtWxHZuHHjjTfeKCIWi2Xs2LFXX321xWLZsWPHypUr1X+br7/++pgxY7SjTZ48eeHChTExMbt27erVq5faeO+99y5ZsiQpKWnPnj2dOnXSds7Ly8vMzBSRL774ok+fPiJSV1dnt9ufeOKJJ554IjU1VWWjZrNZfZb2tTEpKSllZWWdOnU6cuRIly5dcnNz+/TpU1JS8tprr7399tsictFFFx0/flwrHx4v3e9///v169eLyNy5cx1vG+2qtra2tLTUfW0CgOjBWyGAQIr49BAAAD8ENT1EWFAzgseNG6du1SUiY8aMmT59+k033fTpp59u2bLl448/Hj58uNp50aJFItK5c+ddu3Y1a9ZMO8jkyZN79+797bffbt682TFAVGbPnj1gwID169enOQT6NptNjUtIS0t77733Bg8erLaPGzdu/Pjxo0aNOn369KOPPnrbbbdp+f68efM2btx47NixCRMmfP755xaL5ZNPPlm6dKl6yjE9rJfZbNb+32QyOX6h7kdjlCNHjmRmZm7atEmbxDBixIg777zz9ddfP3XqVGFhYY8ePby8dPv27XPffgBAvZjCDCBgdEwPmb0FADCsECzuwd1UwkK7du209FC58MIL16xZo8IyLRBU01kuvvjinJwcxwhMRJKTk4cNGyYiR44ccT1+bW3t/Pnz0349HHj16tWFhYUiMmPGDC2wU/r16/f444+LSFFRkRqurp1FxYVfffXV888/X11dnZWVZbfbBw8efN999zXmCvjRGMVsNi9cuNBpCZSsrK7xW8gAACAASURBVCz1QFsJ0ZtLd/r06ca8BACIWgSIAAKjf9oG0W9IBUvIAwCMyTU9DFKtpBQa3wMPPOCYHiqXXHLJ2LFjReSzzz5Ta6TExcUdP378xIkTf/zjH10P8uOPPzZ0/H79+vXs2dNpY15enoikpKRMmjTJ9VfGjRunFq9Qu2muvfbaCRMmiMjMmTOzsrIOHDiQlJS0fPlyNQ3Zb/41RkSuuuoqbYyhRlscWVuVy+9LBwDwiAARQAAMbLlJmJAFAMCvhSw9VBiEaHB9+/atd7tao9ZutxcVFbk+a7fbi4uL8/Lyli1bdvvtt69bt66h49c7uViNzuvSpUu9CxPHx8d3795dRA4fPuz01HPPPdemTZvKyspVq1aJyNNPP+1x8rJHfjema9eurvurWdJueH/pAAAesQYigMbql7ahtlZ2/PQ73e8Zo/sS8lBSU1N79eoVJTcRAoCGXN38fZFfvRMG+5s2NZGZUmhYHTt2rHe7FswdPny4W7du6vG+fftefvnl7du3HzhwQK2f6FG7du1cN6rMrqFTi0iHDh22b9/umtmlpqYuXLjwpptuEpG+fftmZ2d70wb3/G5M69atvT+LH5cOAOARASKARrmq2Xq7XfJ+HGmE2xHTcTKIK664YsuWLXq3AgD0NLDFRqe5PqEZp08RDEfavGYt7Xr22WenT59us9nUs7169UpPT+/ateuAAQPef//9l19+ud7jJCQkuG7Upvc2RN1iWM2edrJnzx71oLCw8NixYx06dPDm5bjhd2O8nzrt36UDAHhEgAjAf2pm1s6ffidSz4dOXdBxAgDo7qpm62trfrUllKt88F2aYRUVFbVt29Z1u3YPkPT0dBHZsmXLgw8+KCIZGRlz5sy57rrrHJPBf/7znz6dND09/cSJE0ePHnXTKu3Ujvbs2TNr1iwRMZvN5eXlWVlZH374oU+nDmBjvBTYSwcAcMQaiAD8pOM9l91jBSgAgI5CvO6hK+7IbFj5+fn1bv/888/Vg86dO4uIWnMwPj7+448/HjVqlNO4wtraWp9Oqo554MCBiooK12dramrUbZG7dOnitP3uu++uqanp27fvggULROSjjz5auXKlT6cOVGO8F9hLBwBwRIAIwB+GTQ+FjhMAQD+6p4cKIxCN6YUXXnDNsIqLi5cvXy4iPXr0SE5OFpGTJ0+KSIcOHVwX/rPb7Vra6KWrr75aRM6fP7948WLXZ1esWHH69GkR6d+/v+P2OXPmfPXVVxaL5dVXX83Ozh44cKCI/OlPf/rhhx98OntAGuO9wF46AIAjAkQAPjNyeqjQcQIAhJ5B0kOF79IM6NixYzk5OY4Z4pkzZ+644w615N+TTz6pNqoJvEVFRadOnXL89erq6gceeEClYGqNP2+MGTPmsssuE5FZs2bl5eU5PrVr165HHnlERNq3b5+VlaVtLygomD17tohMmzatR48eJpNp8eLFsbGxJSUlU6ZM8eklOwWmfjTGJ95cOo/rMAIA6kWACMA3xk8PAQAIPdf08LOSUbq0RGE8vgElJiYuXbo0MzNz3rx5b7311rRp0/r06fPJJ5+ISGZm5qhRv/yDGTlypIhYrdZhw4a9+eabe/bs2bp164IFCy6//PL58+erUYqnTp1at27duXPnPJ7UYrE89dRTIlJSUnLNNdfce++9K1eufP311++7775BgwapEYVz587VZvtqk5e7dOny8MMPq40ZGRnTpk0TkbVr177//vvevFh1O5SysrK1a9cWFhaqsYG+NsZX3ly60tJS/w4OAFGOm6gA8EF4pYesIg8ACA3X9DDvzA0WvT9oUwSN5r333rvjjjt27ty5c+dOx+0333yzmsWsXH/99Tk5OYsWLdq3b9/o0aO17SaTKTc3d/jw4TfeeKOI3HLLLcOHD//oo488nnfUqFEvvfTSX/7yF6vVumTJkiVLlmhPpaamLl68+A9/+IO2Zfbs2bt37zaZTEuXLnUM8mbMmPHWW299++23OTk5gwcPTk1NdX/S3r17qwfq4PPmzVMRpE+N8ZWXlw4A4AdGIALwVnilh0LHCQAQEoaaueyEQYiGkpmZWVhYmJube+mllyYkJKSlpWVmZr766qvvvPNO06ZNHfdcuHDhxo0br7vuunbt2sXHx7dr1+7uu+/Oz89/8cUXb7jhhtzc3LS0tISEhPbt23t56ilTpuzdu3fy5MmXXXZZUlJSkyZN0tPTs7OzCwoKHAO7goKCOXPmiMg999wzaNAgxyMkJCSohQtPnjypokD3RowYMXfu3Pbt28fFxbVp06Zly5a+NsY/Hi9dUlJSI08BANFJ7y9GAYSJsEsPAQAIASOnh/Kvicx8o2YcrVu3fvHFF1988UWPe44cOVJNyHXleoSamhqPB0xPT1f3U3ajZ8+eVqu1oWeHDh3quoDgwIEDG1pVcPr06dOnT/e7Mcr58+cbeqpt27b1ntr9pbvyyivHjRvnzakBAI4YgQjAs7BODxl8AQAIEoOnhwrpIQAAaDwCRAAeuPaOwgsdJwBAMIRFeqjwXRoAAGgkAkQA7mhjDw3bKQIAIPTCKD0U7sgMAAAajQARQIPCeuayEzpOAIBACa/0UGE8PgAAaAwCRAD1i6T0UBh8AQAIkHBMDxXqoL4GDx4cExOjdysAAPATASKAekRYeqgw+AIA0Ejhmx4K36XpbfPmzQkJCXq3AgAAPxEgAnAWkemhQscJAOC3sE4PAQAAGoMAEcCvRHB6KAy+AAD45apm6yMjPaQOAgAA/xAgAviF1jsKxx6R95jIDADwiWt0KOFcK8kQAQCAHwgQAYg49I7Ct0cEAEDARVh6CAAA4B8CRADRmB4y+AIA4FG905YjoFYyCBEAAPiKABGIdlGYHgoTmQEAnkTGoocNoQ4CAACfWPRuAAA9RcOihwAA+CRKpi0XbN1LjAgAALzECEQgSkXJLVPcYwIXAMBJlKSHwkRmAADgCwJEIBpF57RlV/SdAACOoic9VBiBCAAAvESACEQd0kNH9J0AAOIwMN9JxNdKvkgDAADeYA1EIIoQHdaLRaAAIMpFZ3SoqMH41EEAAOAeIxCBaEF62BAmMgNA1IragYeOSA8BAIBHBIhA5HPsHUVVj8h79J0AIArVGx1KVNZKvkgDAADuMYUZiGSOXaMo7A4BAFCvhqJDidZyyURmAADgHgEiELFID31F3wkAIh7RYUOogAAAwA0CRCACER36h74TAEQwN9GhUC5FhC/SAABAwwgQgYhCdAgAgCsGHnqDicwAAKAhBIhAhCA6DBT6TgAQMdyPOhQqpgsqIAAAqBcBIhDenLpGdIQaj/EXABABiA79RhEEAACuCBCBcOXaNaIvFCh0nAAgfBEdNhJfpAEAAFcEiECYITcEAMCVx9xQoWh6g/QQAAA4IUAEwgbRYYgx/gIAjM/L3FAomj6iCAIAAEcEiIDRkRvqhTlcAGBY3ueGQt30C0UQAAA4IkAEjKihfhFdoBCj4wQAxuFTaKhQNxuDIggAADQEiIBREBoaE+MvAEBf5IY6oggCAACFABHQk5tOEZ0fg2AOFwCEmB+JoYbqGVgUQQAAoBAgBlJFRYXdbne/j9rBbreXl5e72c1qtQayZQgcu93u/q9TV1enHtTW1tpsNqdnr77gfxx/dHlePjt7478ehtm/gXpfb2ToNiDd8Y+u/WdeV1cXPf+p2u12j6/XWhMtVyMcVVZWuq87tbW1IuJ+H8ViscTHx3t53urqanVkj6dWjTSbzQ3tVllZ6eVJEXpWa42b9wePb5sei6NHBqyedrvdZrN5/GRofE5F0D2PH5MiSV1dnTevNwL+DUQqq9XqvuqpT/Xua5NiMpmaNGkSyMYBgPEQIAaS1Wr1MkAUTxFhpAYxEcAudvd/HcdukohMuTz/18+3ctq/2nKP448ZbRrdRD3YbDaz2WwymUJ50sW7vwzl6VypzqG+bQgZ+7+42Sd6rkY4qq2tdV931N/Xm56/3W73PkCsqampqalxv4/2vUtNTY2btxGPQSR0ZKuzae8A917Z2+lZ9Q2EiJhMJtUPj69d+utdnIujl7QaqlVP3UuDo4gpE4V5B7sP7OLlzpHxkr3n8fWSHxqWzWbzpup5U30IEAFEAwLEQGrWrJnHfUpKSurq6kwmU1pampvd4uLi1INVq1bt3LkzMO1DINTZbImJiQ09e1Wz9TabTXWTLDExJrO54Gw9u/16gtU+EcntPyDQLQ0dm832008/paSkxMbGhvK804cOC+XpXn/87bGP3SoitbW1paWlIhIfH5+SkhLKNvjEXrYggEerqqoym83aW1O9zpwtnxXAUyKgUlJS3NedysrKiooK9/v4ITk52eM+58+fr66uFpGmTZtaLA1+MtH+c/v000/vvffeQLUQjfHtt9+qB4kJCVpxXHVgn9NufZu+W2uziYjZbI6JiXF8qv/Fl/hxXlPy/eqBa389xKXBjZKSkoSEBC1TeGnHp/q2pzH6DO/pcSJzRUWFiJhMJjcfkyKM1Wq1uf1YqJjNIf16Fd5LTEx0X/XUR76UlBQ3tQkAogdvhQa1e/du9WDbtm3btm3TtzFwdO5siXrg0wpNHpdkct+vCOt4Maw5ZnBj/iy7N07qOSTDVFeXWFclIjHWGHuZt+OwADRScXGxenDw4MGDBw/q2xg4qbVapeHKaK9r8Bd3fHfCzWEd40UtNAxToSzlwQgrWQYRAIAoR4BoUAEfA4JAaRJn+tes5PoHTVit1vN1dy3dszs+Pt5pnIXfGuoJREmwGNiRdI1B9wnQkZEH/CLr8sLWrb5rqDJ+dvyYf4ed/00fh59+VQqjpAL6J0gXRxuJ7yisR1YCAADvESAaVKdOndSDW265pW/fvvo2Bsq0adNEpHWrpo4bXQdE1JaXS2XlPT2ubNq0qfv5nhq/P3zX+4sB7DZ4m9zV1SXWVZkq4u0BCkwBwJUWIPbp0+e2227TtzFQXnnllaKiIvE0SfOqtherWeoWi8VNZVSjEb28jXKwKyBcjX3sVtcMUbvmZ8+etdvtZrO5efPmerTOGckmAACBRYBodCNGjBg/frzerYDIvwJEp/X9XSM2i9WaWFcrIubKeLvVq0BtyuXunnU/vcvVZ/t/NYPMv+Wl4MaebYVd+nXSuxVA9LriiiumTp2qdysgIrJp0yYVIPrN8Xu4qy8TEbm6gT29yYOc9iFPDLh6M0QvhXg+gfsPVwHh5RqIS+Krvg96WwAACDoCRMDoGkoAvQwWHXcjTAyIHoO7f/m/e7y/HyUAQOP3Uob1poHuU0XyRCWwyd0Vffbay+oJxBJsFSJispvsZdFyExUAAKIKASIQrupNA92nioSJgUJ6CAAeaVlhndVaWXNORBLjEwN75ymfUkXH7SELE42zjG+g9ByS4fGOzAAAIPIQIAIRxSkWdJMnEiYCAIJKy87MNltiXbWIWKotdrtXqwM3htPc1XpLobbcR/AqYIKt0lJtkdjYIB1fR2SIAABEIQJEIJJ5mSdq20kSfbL3/w70HtZD71YAANxxLG2udZCv0/xDeggAQLQhQASiiPtOlJAk+igjsytDMAAgjHgZJlIEvUEFBAAgqhAgAlFK6x2RJDYG07gAIEy5CRPVj1RA96iAAABEFQJEINoxHKOR6DsBQLir90s1KqBHVEAAAKIHASKAf3MzLJF+FAAg4pEk+opBiAAARAkCRAD1IEn0FT0oAIgkbpJEyp8jJjIDABAlCBABuONNknhVm7YhbZMh0YMCgIik6iADEt1QFTD9qo56NwQAAAQRASIAr7hJEnee/K62tnZAu/Yhb5SxkB4CQKRiQCIAAIhyZr0bACDM9L/4kno7S5+f/G7HdyfqvaczAACRwbUIUvtEpOeQjMK8g3q3AgAABBEjEAH4w+PU5qgdkcFEZgCIeK5FkHnN3Qd2Kcw7mJHZVe+GAACAoCBABNAo/S++pK6urqqqquDMj47bo7YrxWKIABA9GlohMdpqn9J9YBe9mwAAAIKFKcwAAuOqthfX21+KwrldKkPUuxUAgBCpd15z/ven9GqPjpjIDABApGIEIoBAamhqc7QNSGQcIgBEG9cKuKv4pDkmJkoKn9J9YBfKHwAAEYkRiACCQg3HcO01Rc+ARLpPABCdnMpf9BQ+hWH4AABEJEYgAggu1/WhJPoGJAIAok2f1hdZLJb8H75XP0bz2ogAACACMAIRQChE7YBERmEAQDSrdzRiZBc+YRAiAACRiAARQEi5iREjskNFJwoAUO9dViKy6mkofwAARBgCRAA6iKoBiXSiAAASfTEi5Q8AgEhCgAhAT1EyIJFOFABAibYYEQAARAYCRAD6qzdGlMjqU5EhAgA0URIjUvsAAIgYBIgAjCLi5zXTjwIAOIqGGJHaBwBAZCBABGA4ETyvueeQDL2bAAAwloiPEckQAQCIABa9GwAA9dN6U06dKPVjvVOeAQAIU65Vj3oHAACMgxGIAIwuggckAgDgxKnqRUaxYxAiAADhjgAR4W3ixIkmk8lkMj300EN6twXBFQ03WgGAxqMyRobIixHJEAEACGtMYUYY27Rp07Jly0Rk7ty506dPVxtPnDhx/PjxmJiY/v3769o6BAXzmgHADSpjhFF1LWImNasMkeWAAQAIRwSICFdnz56dOHGi2Wz+29/+lp2drW1fvnz5zJkzmzVr9tNPP+nYPASbU59K0X4M384VAPiNyhipIilGJD0EACBMESAiXGVnZ585c2bVqlWjR4/Wuy3QDQMSAUBDZYxsERMjMggRAIBwxBqICEt2u/2ZZ5757rvv6CNB4UYrAKIclTFKRMDaiCyGCABAOCJADLXy8nKbzebTr9TV1f3www8BOXtZWZmvZ/dVAFvrhslkat++fatWrYJ9Ik1NTU3IzgW/hfWNVuhNIWpRGQNCl8oY7EuHhoR7jEiGCABA2CFADK6FCxeaTKZu3bqJyOrVq7t169auXbvWrVt37dp1yJAhS5cudf3kHRsbazKZ9u/fr358/PHHExIS1qxZ47hPcXFxbm5u9+7dk5OTk5OTu3btmpOTs3ev8+cw17OnpKRYLJaWLVs2dHZl27Zt2dnZQ4cOveiii1JSUrp16zZy5Mh169Y11NpNmzaJyIYNG3r37u1faysrK9PT000mU+fOnSsrK53O8u6776obSi5YsEDbmJeXpzbm5+erLdnZ2SaTaebMmSJSWlqqnn3qqaf8uHQikpKSYjKZNmzYUF5ePmnSpBYtWqjtR46evfveNw4d+bH+S/d/h+7/y7oRNy259IrZaW2nd+8z+/+zd99hTV3/48DfFwJhynCgLEEZIipVHGVUwFVHRax1/XDgQsGBdqitVlHBWVtFQQGhuFrrKK668OMsigMHyhJZgoAyhUAg8/fHae83TUIIMez36+nTJ5x7cs65V8jJfd8zvvjq4Jlzz/h8gdT8qCmQ26r6BiS2SJPkgXdTqIOQ7Jt69OhBesaRI0fK6Bnj4+PJj+fPn8eesZX0jPQ/yopvT8voGZd+fYr0jF3M12HPqERiPV0r7+bEYK+HEEIItS0YQGwmwcHBs2bNosOCpaWlt2/f9vX1dXFxKS0tlfHGN2/eiI19u3jxooODQ0hISGpqanV1dXV19atXrw4cOODg4LBt2zZ5ai8pKamvdh6PN3v2bHd394MHD966dauoqIjFYqWlpV26dOmrr74aNWpUfQPxIiIiJk+e/PTpU8Vaq6mpGRUVRVFUZmYmuc+hffjwYfny5QAwfPjwZcuWybhWDVLg0rHZbDc3t/Dw8MrKSpLC4fCO/PbQfvDWG7dfiebk8QRzFh31GBcS+ev9u/ey3r2vYlXXpb16d+lqytRZ0aMnhnK5OEyjubW5ec14N4U6FLG+qays7M6dO/L0jGVlZdgztqqeEQBO/vlURs8YEX0Pe8YmItnTtdo+ThL2egghhFAbgpuoNIfc3Nwff/wRABwdHceMGWNmZvbixYvz58+/ffv2wYMHU6dOvXHjhthb8vPzyYsvv/xy+vTpLi4u5MeLFy9OnDgRABgMxuzZs52cnBgMRkJCwuHDh+vq6n744QczM7NZs2bVV/ukSZMsLS2fPHly8uRJqbXv2bPn2LFjAGBpablw4UIy9uH169cxMTHp6em3bt3aunXrxo0bxVr7+PHjoKCgbt26rVixwsrKSrHWDh8+3N/fPzQ0dPfu3TNmzBg4cCBJX716dUFBgba29q+//kpRlIzrHBoaun///s2bN2/evFlPT4/cAaqoqCh86QBg3bp1WVlZNjY2AQEBS5cuBQBdXY2qqloulz974ZHc1M0Mxj/l7wm9dezEIwCw6Gk413uIlWUXNXW1rJzSw8cepGe8v3U3Y+tP1zZ+P05G+1ETaVsbrZC7KVxdHrV7on3T2LFjTUxMkpKSLly4IKNnpIN9gwYNWrNmDfaMraFnPHTo0NOnT0m6zJ6x81zvwVaWXVQZqjlvyrFnVDqx/VWgtfZxkrC/QwghhNoKSigUtnQb2rPQ0FB6aMC8efPCw8OrqqoEAgFFUXw+f/Lkyffu3QOAuLi4UaNGkWxqamo8Hk9VVZXMioqKipo/fz45xOfzBwwYkJKSYmBgEBsb6+bmRlf04MEDT0/P9+/fW1papqWlqaurS61dTU2N/Pj+/Xuptffq1Ss7O9vKyurRo0f6+vp0+SwWa9CgQRkZGcOHD799+zadTlqrpqbm5OR09uxZAwMD+lBjW0tq6devX25u7sCBAx8+fMhgMO7cuePu7i4UCvft2yc2yCI+Pt7V1RUAHj9+7OjoSKdv2rQpMDBQX1+/vLz8Yxqjq6vLYrEAwNXV9a+//urUqRO5SetjYzTE0fzo748A4Nn9tQP6GZP8vfttys4tterV9e/rK3S01QCAyWSqqqqyquscXXZmZBYPd+l960qAlN+Stk8gENTW1pLzbem2NKy+cRny32WR8wUAVVVVJpOptJaJaIUxxNraWhUVFfoPRKqS0upuFt8DgKur6927d5uraUiWBQsWREdHA0B8fLyzs7OMnGw2u6ampnPnzk3dJMm+qba2tq6uDgA4HM7UqVPr6xkZDAaPxwMAHx+fX3/9lRzCnlH02jZ/z+jm5nbnzh0AmDp54KnYp1BPz3j/5ipNDRUAYDAY6urqHaFnBAA2m81gMOhfsGYj2c01TxixpqYGACiK0tTUbNQbW2GXJycOh8Pn8xs8335DtqakFQEAn8+nw/eoBcXExMybNw8Atm3btnbtWhk5eTxeRUWFvr4+g4HDbhBCCKcwNxdzc3PRuxQA6Nat24kTJ8iXcsmRCwKBlIWBjh8/npKSAgDr1q0T/aIPAMOGDdu0aRMAZGdnk3tFBWrncDg8Hs/U1NTf31/0HgkAdHR0Ro4cCQBZWVmSDePxeCEhIaL3SIq1VkdHJzIyEgCePn36888/19XV+fr6CoVCNzc3MvpPYQpfOhUVldDQ0E6dOokmLpr3z0ASer0nDofP4wtMTfT9Frnq6/3ne6SONnOkuy0AZOXImpGHmk2bWCGR3ErhxC7UvjW2Z5S6OiH2jApTbs84a+YQ8gJ7xhbX5iY140RmhBBCqE3AAGIzWblypeQjaDMzs9mzZwPA/fv3yYAm0UOShZClynV1dZcsWSJ5dN68eWTkCL2ieWNrV1dXf/PmTV5e3qpVqyTLLy6Wvjg6AAwbNszBwUEprR09evSCBQsAIDAw0NfXNz09XVtbOzo6WvYUrQYpfOmGDh06YMAAscSeZv/cENIDeNXVVXNTN71J27xqmYdk+cUlrI9pPGoirX+FRLynQu1bY3tGe3spY5SwZ1SYcntGM5N/oqvYM7YSUsOILdWYBmF/hxBCCLV+GEBsJkOGDJGaTiaUCYXC7Oxs0XRDQ0PJzK9fvwYAGxsbbW1tyaNMJrNv374AkJmZ+ZG1E0KhsKCgID4+PioqasaMGWfOnJFaCAD06tVLia3dvXu3sbExm80+cuQIAOzcuVNq+Y2icGNsbW0l8zc4/UQoFBYWVd5LyI46cn+mT8yZc88UbDdqelLDiNBqxmvgPRVqxxrbNxkbG0tmxp5RYcrtGRuMZpKe8f6DHOwZm5NYH9dKujapsL9DCCGEWjlczaGZWFpaSk2nbwAyMzPt7OzodLF5UgT5rl9fUQBgYWFx9+5dye/6jao9NTX1wIEDd+/eTU9PZ7PZ9dUlytzcXImt1dPTCw0NnTx5MgAMGTLEz89PnjbIpnBjunfvLn8tqenvDh66eyf+9auMYnat9E05Ueske6MVaNF16OnpzG10iSiE6tPYnlHqBzL2jApr3p4x81XGe+wZW4rYFiutdn8V3EYMIYQQas0wgNjC6PlTYjckUpfcbnDHG7K+r9icr0bV/tNPP61du5asM6WmpjZw4EBra2tbW1tnZ+fz588fOHBAajkaGhrKbW1SUhJ5kZKSkpuba2FhIc/pyKBwY+SfIPbT3hvfbzzP5wsAQE1N1aG/sY1Vtz423Z2GWV649OLAob8b32rUAiQ3siRa/HYLb6tQx1Ffzyh1Dx/sGRXWIj2jde+udrY9sGdsEW0ijIidHUIIIdRqYQCxmWRnZ5uYmEimk+f/AGBtbd1gIdbW1nl5eTk5OTJqkVqUnLXfvHnzu+++AwB7e/utW7eOGTNG9P7n6tWrDbZQKa1NSkoKCgoCABUVlerqal9f32vXrjWqaiU2Rk4372SsXn8WAOztemxaP9b9s94aTAa9K/G1/6UqVixqKbIHJAqFQofOXZq/VTgUEbUz2DPK39q23jNu2TB+uIulBpNBdmEG7BlbTusPI2IMESGEEGqdcA3EZpKYmCg1/eHDh+SFlZVVg4WQPOnp6TU1NZJHuVwu2U7RxsZGsdrJykpMJvP69euenp5ioyd4PF6DLfz41nK5XB8fHy6XO2TIkH379gFAXFzc4cOHG1W1shojv6O/PQQAJpMRd2HpF2PtNZj/0mmd6AAAIABJREFUCc3zeFL21EZtQn0rJCa+K0p8V/S4sKD5m0TurHChKNQOYM8oZ2vbQc84cVw/7BlblVa+NiKuh4gQQgi1QhhAbCa//PKL5G1GQUFBdHQ0AAwYMEBHR6fBQpycnACgqqoqPDxc8mhMTMz79+8B4NNPP1Ws9rdv3wKAhYWF5PJGQqGQvqeSk2Kt3bp169OnTxkMxqFDh/z8/FxcXADg66+/fvfuXaNqV0pj5Pe28AMAWJgbdjfqJHZIKBQ+fJyrWLGolSA3Wq1nrxUHd3u8uULtAPaMcrYWe0bURFpzGBG7OYQUEBUVRTVSVFRU07WntLT0I2tRrISuXbtSFPXjjz8qVmmLl9/a6v1IfD6f/CPu3r27pdvSwtrBpcAAYjPJzc319/cXvVcpKSmZOXMmWVpoy5Yt8hQya9asPn36AEBQUFB8fLzooUePHpGPkp49e/r6+ipWO5mmlJ2dXVhYKPr2urq6lStXktsksghUE7X2+fPnwcHBALBmzZoBAwZQFBUeHq6mplZWVrZixQo56yXEbgsVvnRysu7dFQCyc0sLiypF0+vqeKvW/PkwMRcAyCJQqE0j91rDTEzF0slNVzPfd9EzmpuzUoSUCHtGeVqLPSNqaq02jIgxRIQQQqhVwTUQm4mmpmZkZGRSUtKYMWPMzc2TkpLOnTv35s0bAHB1dfX09JSnEAaDsWPHjkmTJpWVlY0YMcLHx8fZ2VlFRSUhISE6Oprc82zbtk1y4Xa6di8vL0tLyydPnpw4cUKy9gkTJoSFhXE4nJEjR65fv75fv35lZWUvXrwICQl5/fq1jo4Oi8UqLCw8c+bM6NGjO3USH1Dwka2lp2jZ2NisX7+eJNrb269ZsyYoKOjkyZPe3t7yXCiy6DuLxTp58mS/fv309PRMTEwUvnRyGv+5fVjkXQ6HP+qLfWu+HtXHpkt5BTv9Vcn+8Luvs4p1tJms6rrCosoz556NHtGnk66CtaDWw9GoOwA8fS8+/Kf5d23GhRFR20X3TePGjTMxMcGesR33jN9/O8bGyrC8gp2a/j4sIh57xlaoda6NiOshItQoLi4uBw8eFEt88ODBr7/+CgBz584lY8/F3tJMjUMItX0YQGwmsbGxM2fOfPDgwYMHD0TTp0yZQmZLycnT03Pv3r3ffvsth8OJiIiIiIigD+np6YWHh0+fPl3h2sePH+/v7x8WFpaamurt7U2nUxQVEBAwatSoiRMnAsBXX301atSouLg45bY2ODj42bNnFEVFRkaK3q6sW7fujz/+yMjI8Pf3d3Nz09PTk13poEGDyAtS+Pbt29esWdPYxjTW+M/7+i/6LCzybmr6O5/Fx+l0iqIC/N1Heth4To0AgKmzokd52F47v1ThilCrMriHMZPJhPp3bYbmuvsSHY2IN1qorcCeseP0jHMWHaXTsWdszaSGEaFFI4kYQ0RIfn369CFDy0Xp6OiQAKKHh8fcuXObsz2GhoZFRUUA0OADtqYrASGkRDiFuZm4urqmpKQEBARYWloymUx9fX1XV9dDhw6dPn26sZ+GK1asSE5OXrZsWZ8+fbS1tbW0tKytrf38/J4/f17fF3269t69e2toaBgYGNRXe2ho6MWLF8kwSSaTaW5u7uPjk5iYuGfPni+++CIgIMDAwEBDQ6Nnz57Kbe3z58+3bt0KAIsWLRo+fLhoCRoaGmR5prdv35IbHtnGjRu3bdu2nj17qqurGxsbd+3a9WMunfz2/zz1wunFY0b2MTPVZ6ozzEz05/y/oY/vfvfLji+/GNsvwN/dQF9LQ0Otp5nhR1aEWqEGF0lsnulg9NqIOOcLtQmSPaOLiwv2jHS29tQzmpsakJ5x9swh2DO2fpI9WsvOa8a5zAi1URRFGRkZGRkZaWpqtlQJCCElwhGIzad79+579uzZsGGDQCCgKKpz585Ss3G5XADYuXOnjIEM1tbWZB/Gxta+Z8+eBnNOmDBhwoQJUg9JlkBaK5s8rXVwcOBwOPUd9fDwEAqFYokuLi6SicTatWvXrl2rcGOIqqqq+g6ZGOsJqkIk0yd8bj/hc3sOh0PWmWIymaqqquTQLzu+/GXHl/LUi9o0+o6rBcck0sM0cMgGav1I37Rly5a6ujoA0NfXJ5NtxZC+JiEh4dChQ/UVhT0jtGjP2KN7Jxk9I5/PJ//EDAZDXV2dHMKesZUTG40ILTqvmY4hYr+GUKvC5XK5XK6mpiZFUS3dFqQ0LBZLU1OTvpNtH/h8fmlpabdu3Vq6IW0bjkBECCHlq29AIjTjmER6XjMO3EAIIaSY1jMaEbcOQ6jp5OfnL1++3M7OTkdHR1dX187Obvny5a9evZLMqaurS1HUX3/9xWKxFi1a1LlzZ21tbQ0NDXt7+wULFuTk5Ihmrq6ulrGHclJSkq+vb+/evTU1Nbt16+bm5rZ//36xJ2eyS7h48eKECRO6d++uoaFhaWm5ePFiqW2m3bhxY8mSJe7u7t27d9fV1e3bt+/EiRPPnTsnEEjf0aux5VdXV+/atcvJyalz5866uroODg5+fn7p6eky3qKUeht7XmJCQ0Mpiurfvz8AHD582MbGRldXl8FgdO3adcSIETExMfWV85H1yl/IN998Q34NEhMTpRYyefJkiqLU1NSKi4tJipqaGkVRV69eBYAzZ8588sknGhoasbGxSm//RxalwKlBY/5glQ5HICKEUFORMSBRLLHpBnSIDkgEHLuBEEKo8VrJaETcNwyhpnDu3Ln58+eXlZXRKWlpaWlpaeHh4bt27QoICJB8S3V19Wefffbs2TPyI4fDSUlJSUlJOX78+M2bNyW3apG0ffv29evX8/l88mNtbW1xcfGdO3f2799/9erVBlcF4fF4a9eu3b17N52Sk5MTERFx9OjR48ePS+bncrlz5879/fffRRNTU1NTU1MvXrw4bty4CxcuiA64a2z5APDs2bOJEyfm5+fTKUlJSUlJSeHh4cHBwd9//73sM2qe85ItMDBw06ZN9I8lJSU3b968efNmTEzM+fPnRRd4UUq98hcyffr0n3/+GQBiY2MdHR3Fyqmqqrpy5QoAjB8/XnSRFiI0NHTZsmUKV92gjyxKgVNT4A9WiTCAiBBCTU70FqulgokYSUQIIfQxWk8YEWOICCnL+fPnvby8AEBdXd3Hx8fJyYmiqHv37sXExHA4nJUrV/bs2ZNkEPX9999nZWWRcU+DBg0qLS2NiIg4d+5cXV2dt7d3VlaW7EoPHz5MAmrdu3efM2fOkCFDPnz4cObMmcuXL6enp3/++ecvX76UuqQJzc/Pj6xqYmBgMHPmzGHDhr19+/avv/6Kj4/39vam45K0n3/+mYR4bGxsFi1aZGVlJRQKX716FR0d/erVq8uXL4eEhKxatUrh8ouLi0eMGFFeXg4A06dPHzFihL6+/uPHjyMiIj58+PDDDz9QFFXfQiLNeV4yZGZmbt68GQAGDx48adIkCwuLxMTEP/74o7Cw8Pbt23PnzhUdvqeUeuUvZOjQoRYWFjk5OWfPng0KChIr58KFC7W1tQAguUfQ/fv3g4KCjI2Nly1bZmVl5erqqvTr9pFFNfbUFPuDVSIMICKEULOSPSwRmj6YKBZJBAwmIoQQkptkL0ZeDDCUvrp3U8AYIkJKwefzyU5cXbp0OX/+PD1ycO7cuXPmzPH09CwrK1u3bt3EiRPFhlBlZWW5u7ufP39eV1eXpIwfP37KlCl//vlndnZ2VlZWr1696qu0trZ2/fr1AGBnZ3flyhVzc3OSvmDBgh9++GHbtm3p6em//fbbnDlz6ishOTk5OjoaAGxtbS9evGhlZUXS16xZs3LlSqmr+h44cAAA+vTp8/DhQ7rNAODn5+fg4JCTk3Pr1i06yqNA+Vu2bCkvL2cwGKdPn540aRJJnDZtmr+//9ixY9PT0zdv3jxz5kzZIyub+rxkY7PZALBgwYKDBw+S6O2sWbO+++47T0/PxMTEs2fPPnz4cOjQoUqst1GFTJs2befOncnJyRkZGdbW1qLlnDp1CgAMDQ2/+OILsSqCg4Pd3d3PnDmjp6encNVKPAup5D81hf9glQjXQGxaJiYm7u7u7u7uLbIEacvWjhCSTcbezTR6wcSmWHOK7NqMSyWiZoY9I0Ltg1gXlviuKPFdUbPVTmKI2HMh9DGOHTuWlpYGABs3bhSbd+zi4rJu3ToASElJEZueCQCqqqqhoaGi4RIAWLRoEXnx+vVrGZWGhYWReb779u2jo4fE5s2bDQwMAODGjRsySggMDCRLyx0+fJiOsgGAiorK3r17+/btK5a/rq5OIBCYmpr6+/uLtblTp07u7u4AIDpqsrHl5+TkhIeHA0BAQAAdPSQsLCzCwsIAgM1mR0ZGyjipZjivBpmbmx84cEB07KexsfHvv/9OvjIFBgYqsd7GFjJt2jTyQmwdQ3qS74wZM+hd2mgCgWDv3r1i0UMlXjelFCX/qSn8B6tEOAKxaXl5eTXpCNLWXDtCSE4NTnCWcVRZQxRFx3HgyETUpLBnRKg9EZvXnFhUyFBTa55JzaLbqmCHhZAC4uPjAUBfX3/BggWSR319fTdu3MhiseLj42fNmiV6yNnZWTKeRQ+vEwqFMiqNi4sDAHt7+5EjR4odYjAYBw4cyMnJMTExkVHC33//DQCjRo0aNmyY2CGKolatWkWHMgkmk/nmzZv6ShPdm0Kx8i9dukT2flm5cqVk+SNGjLC2ts7IyCBXuwXPq0ErV65UU1MTS7S2tp46deqJEydu3bolFAopilJKvY0txNHRsXfv3pmZmWfPnl29ejWdTk/ylTpk1cXFxd5evHdQ4nVTSlHyn5rCf7BKhAFEhBBqReQPJsrO8zE3b1KDibaf9la4QIQQQu3bp6ZmNTU19AhEum9qhkgiPRQRY4gINRYZKtinTx9NTU3Jozo6OtbW1k+fPs3MzBQ7ZGNjI5lfRUWu2Y0ZGRkAMHDgQKlHp0+fLvvtVVVVRUVFAPDpp59KzTB8+HDZJQiFwoKCguzs7NTU1KtXr/71118fWT45IxMTE1NTU6lv6du3b0ZGxsuXL2W0qqnPSx5DhgyRmu7k5HTixAk2m11UVNSjRw+l1ytnIdOmTdu2bVtCQkJhYSHdjJMnTwKAjY2NZNQVAGRMpZe/6rKyMjK/W5ShoaHkX43Cl0LOU1P4D1aJMICIEEKtlNh9V6OmMMvI3KjbOfp+jDwBE50sJuNW7fXr14sXL5a/FtR0GnzcjRBCyuJo1J2iqOelJXRK8+yygkMREVIMiUdYWFjUl8HCwkJqPKJ79+6K1cjj8XJzcwHAzEzBjwV6fnR9sSGxadG05OTkgwcP3r1799WrV5LxoI8pn7zl7du3FEXJaLnotrlKqZeQ87zkUd9vAt2kzMxMOryllHobVcj06dO3bdsmFArPnz9PbjSqqqquXr0K0rZPIWT8mslf9dKlS0+cOCGWePr06SlTpihwFlLJeWoK/8EqEQYQEUKobZC8AVNsVUQ53yX1fk/sxkxs8amuNv/MNykqKoqIiFCgbajp5OUpeQ1NhBCSqqU2a6bDiBhDRKhRZIS9yHJ45CmynG+RjcPh8Hg8AGAymYqVQL+xvjZoaGhoaWnV1NSIJu7cufOHH34guxirq6sPGjTI2tra1tbWxcXljz/+IFuXKFz+u3fv5Gm5QCDg8Xj17S7d1Oclj/qqpuc107Urpd7GFuLg4GBra5uenh4bG0uibOfPn6+traUoqr4ZuxoaGkqpWolnIVWjTk2BP1glwgAiQgg1LUpneROV7NRHSuLehHtKKfxhxX9+rK2tVVFREV+cuIuj6E+szP++B7Um+vr6Ld0EhFAHUt9mzdDEkUQyoxlwKCJCcrCyssrLy8vJyakvQ3Z2NgCI7Qz7MbS0tIyNjQsKCsg4RAX06tWLoiihUFjfMKvi4mKxKNuNGzfI3rX9+vXbtm3b6NGjRcOXYjtXKFC+paXlo0ePnJyc7t1T/Et4U5+XPOpbfZIeHUmmriulXsUKmTZt2pYtW27cuPHhwwc9PT2ySbGHh0d9wzOVUvXvv/9e37YkSvwnkOfUmv8PVhIGEBFC7VlTBO+EPB6bUwEATHWmho5ug/mbWcCnzvUdUlZssT70AzELCws/P78mrauNqqmp+fnnn1kslpeXl+gaN9evX4+Li9PU1KR3uFOW06dPP3r0CADE9oZDCKHm0fwDEnFGM0JysrKyunnzZmpqam1treRYLTab/erVK6hnxUOF2djYFBQU1LcgYHBw8NmzZ42MjC5evCg1g4aGRo8ePQoKCh48eCA1w7Nnz8RSYmJiAEBTU/P69etGRkZiR8mIyI8p39bWFgCysrLIHiOSbyHD0yiKkrFMZFOflzwSExNdXFwk0x8+fAgA6urqJJillHoVK4RE2bhc7qVLl7744guySXF985eVW3VTFyXPqbXIH6wYDCAihJpW042/Q40lI7Yo6uPjjKampqKbiCHatGnT2Gz20aNHvb29RdPZbHZcXByTyVT6dUtPTycBRIQQakH1hRGhySKJGEZEqEFOTk6RkZEVFRVRUVFLly4VOxoREVFZWQkAUren+JhKb9269ejRo3v37jk7/+erqUAgiIyMzM3NnTp1qowS3Nzcfv/997i4uIcPHw4dOlTs6M6dO8VS8vPzAaBXr16SIR6hUPj48eOPLN/R0REA3r17d/78+UmTJokdLSkp6dWrV1VV1bp164KCglrwvBq0Z88ef39/sUnWWVlZZPzdsGHDSABUKfUqVki/fv369u2bkpISGxsrEAjq6uq0tbW//PJLuU7v46pu6qLkObUW+YMVgwFEhNqA1h6D4/PZnHJ1LT3q3wUyUJsmNc5YUVHBYDB0dHSkvqWpxza2D0KhcNeuXfv27ZP8koEQQh2B5LxmaOIBiRhGREiG2bNn79ixIz09fdOmTUOGDBENWiUkJGzZsgUAbGxsGjvCS7Zvv/32wIEDFRUVS5cuvXTpkuiuvsHBwWRq85gxY2SUsHHjxpMnT/L5fB8fn4sXL4ruOrJz587r16+L5SfjtjIzM9+/f9+tWzc6vba29ttvvyUj+8ggQcXK9/T0HDJkyKNHj+bPn//nn3+6ubnRhzgczvz586uqqiiKmjdvnuwr09Tn1aDs7Ozly5fv379fVVWVpLx7987b25vL5QLA5s2blVivwoVMmzYtMDDw8uXLHz58AIApU6bUd3ui9KqbtCiQ49Ra5A9WDAYQEWoDhKx9Ld0EmQQCTUEtVcMU/tvZtG+UQKApqAUAVY6qkKXgCtBtC6u6jgF8NQFDyFKXmmFFPwCAktLqdf+mCASC4uJipUTKWCyWpqamalP+dimxtTJQFNWzZ88mrUIMl8tVYAILQgg1tWYekCgaRgSMJCL0LwaDsX379smTJxcXF7u5uS1cuNDJyQkA7t27d+jQobq6OgDYuXNnfft+KMbQ0PDHH3/85ptvnj175ujouGDBAkdHRxaLFRsb++effwKAi4uL7Fibra2tj49PVFRUamrq0KFDZ82aNXTo0OLi4kuXLl27do3JZPbq1Ss1NZXOP378+MjIyNra2hEjRqxfv75v375lZWVJSUl79+7NysrS1taurq5OT0+/evWqs7Ozrq5uY8unKGrv3r0uLi5lZWWjR4+eOXOmk5OTmZlZRkZGeHh4WloaAPzwww+9e/eWfWWa+rwa/KfR1NQ8ePDgs2fPvLy8LCwsEhMTf/vtt7dv35K63N3dlVivwoVMnz49MDCQxWJdu3YNAObMmdPgeSmr6iYtSp5Ta5E/WDH1TsJHCCHUMYVG3FXRXdHXMRgAjv/xuK9jcKfu3+l2X2tis9FjXEhkzD0+XyD2FnWDlSq6K+JupJEfnz17pqGhceLECdE8BQUFAQEBffv21dHR0dHRsbW19ff3T05OFisqNDSUoig7OzsAOH78uJ2dna6uLoPB6Nq1q7u7e2RkZH3P8W7fvu3n5+fh4dGjRw9dXV07O7sJEyacOXNGMr+amhpFUX/99RcAnDt3btCgQYq1ls1mW1tbUxRlZWXFZrPFavnzzz8piqIoat++/3sAEB8fTxITExNJip+fH0VRZOnDiooKcnTHjh0KXDoA0NXVpSjq3Llz1dXVS5Ys6dKly5EjR8ihoKAgeg1sqZdu7Nixffv2lX3pEEJIiT41NSP/iSYm5OeR/5RenYO7Pfnv+a1k8p/Sq0CozfHy8vrll18YDEZtbe3+/fu9vb29vb1DQ0Pr6uoMDQ1jY2Ml5+R+vK+//nr//v1MJrOwsDAoKGjy5MmzZ88m0cNPPvnk2LFjDT423r9//xdffAEApaWle/fu9fb2Xrly5bVr1zQ0NI4ePerg4CB2jgsWLACA5OTkmTNnOjg4eHh4BAQE5OTkrF69+tdffwUAgUAwduxYOmTTqPIBwMnJKS4uzsTEhMvlHjlyxM/P74svvli1alVaWpqKisry5ctlT15utvOS7c8//9TX109ISFi7du2MGTN27dpFooezZs0ie3oosV6FC+nTp0///v3Ja1NTUw8PD3lOTSlVN2lRcp5ai/zBisIAIkIIIemCd12bvfBI2qt35MfS0urbf79evPyE66hfSsuqZbyRxWKRyQ60ixcvOjg4hISEpKamVldXV1dXv3r16sCBAw4ODtu2bZNee3DwrFmzyGNbACgpKbl9+7avr6+Li0tpaaloTh6PN3v2bHd394MHD966dauoqIjFYqWlpV26dOmrr74aNWqUWGNoERERkydPfvr0qWKt1dTUjIqKoigqMzNTbPOTDx8+LF++HACGDx++bNkyGdeqQQpcOjab7ebmFh4eTlZCIS5fvty3b98bN26I5hS9dHfu3Hn//r2clw4hhJRIMowITR9JBAAMI7YeCxcuJI/Qvv/++5ZuS4ezcuXKly9f+vv729jYaGtra2tr29raLlu2LCkpycvLq4kqXbp06YMHD2bNmmVubs5kMi0sLMaOHRsaGvr48WMLC4sG366hoXHhwoVTp06NHz++W7du6urqJiYmc+bMefz4sdT1Ew8dOhQbGztq1CgzMzNS3YIFC549e7Zjx44pU6YsXrxYX19fU1OT3vG2seUDwMiRI1+8eLF69er+/ft36tRJV1d30KBBPj4+SUlJISEhcl6Wpj4v2T777LPk5OTly5f36tWLyWQaGhq6ubkdPXr06NGjWlpaSq9X4UKmT59OXsyePVvGvjRNUXWTFiXnqbXIHyyNEgqFTV0HElVWViYQCCiK6ty5s4xsO3fuJDuCR0VFzZ8/v7lah2Qhm2r1sTFKSVwnIxuHwyFzBplMZpNOumw9BAJBbW1tRztfAFBVVWUy2+EU5tCIu8u/OaWpqVZbyxMKhY4DzTwn9Dc17vT8RcGZc8/fFnwAAI/h1v/76/+W5lQ3WMnjCb5bOWrXnusA0LNnz507d7q4uJiYmADAxYsXJ06cCAAMBmP27NlOTk4MBiMhIeHw4cNksP3Ro0dnzZr1T+2hocuWLdPU1KytrRUKhY6OjpMmTbK0tHzy5MnJkyfJg1APDw/RQNhPP/303XffAYClpeXChQvJqMDXr1/HxMSkp6cDQGBg4MaNG+n8ampqPB4vMDAwKCioc+fOK1assLKyUqy1ALBs2bLQ0FBVVdVHjx4NHDiQJC5evDgiIkJbWzspKUl0CZv4+HhXV1cAePz4MVlyWyAQCIXCzZs3b968WU9Pj8RGVVRUyAdOYxujq6vLYrF69eqVlZVlY2MTEBBw5cqVCxcu0Bl69Ojx5s0bemqD6KWbO3eumZlZp06dZFy6JlJVVUVOR19fX8a0i4SEBDJTw8fHhzzURS3Ozc3tzp07AFCUFdyta71zc/h8PvknZjAY6urSV0Jof9hsNoPBUOswqwPX1NQAAEVRmpqaH1mUjKBhU0xwVnhqM4fD4fP5DZ5vvyFbU9KKAIDP5yt2r9vu/fXXX2TU1bZt29auXUsS8/Ly3rx5o6qq+umnnyq3upiYGDJDVrQ6qXg8XkVFhey+CaG2jnz3BgAWi6Wtrd3SzUGtGn4UIoQQkoLN5gLAvFmfHgyZrqamWltb6z198A/fff7lzEP3HmTfvJNx/Wb6KA9b0bfs2X+TvDAzM5s2bRp5zefzyeMQAwOD2NhYemHpefPmzZ8/39PT8/379xs2bJg2bZpoWIHMCJ43b154eDi5/Z41a9batWsnT5587969mzdvXr9+fdSoUSRzWFgYAFhZWT169EhfX58uZNmyZYMGDcrIyLhx44ZkFCw4ONjZ2fns2bMGBgZ0ogKt3b59+8WLF3NzcxcsWPDw4UMGg3Hnzp3IyEhySDR6KBW5mST/pyhKNAqv2KUDgKysLFdX17/++qtTp070XOmxY8deuXKlsLAwJSVlwIABkpeOyWTW1NSQh1uyLx1CCDUpqXutSKYoK5hIxw1FRyPiOonNprS0dOHChSoqKvv37/fz86PTo6OjAwMD9fX1y8vLW7B5CCGEaPgQDCGEkHTmZgYkekindOuq+3uMj7q6KgAEBl8Sy8+TWBsRAI4fP56SkgIA69atE92WDgCGDRu2adMmAMjOzo6Ojhav3dycjh7+U3u3bidOnCDBMjqqRcb8mpqa+vv7i0YPAUBHR2fkyJEAkJWVJdkwHo8XEhIiGj1UrLU6OjokXPj06dOff/65rq7O19dXKBS6ubktXbpUsl75KXzpVFRUQkNDO3XqJJpIL4lCr4So8KVDCKHmIXWRRBo9x1lZ05zpRRLh39nNOMG5Gfj5+ZWUlJBl41q6LQghhGTBACJCCCHpAvzdRaOHhJmpwewZQwHg/sOc2tr/LJA36BMp93jx8fEAoKuru2TJEsmj8+bNI0PeSDZRK1eulJz6Z2ZmNnv2bAC4f/8+mUiurq7+5s2bvLy8VatWSZZfXFxc39kNGzZMcg1sxVo7evRosoJyYGCgr69venq6trZ2dHQ0mYad3jx4AAAgAElEQVSsMIUv3dChQ+kxhrTu3buTF/TSJQpfOoQQamZ0JFGeYOLHxxPpSKLojisYTGwKQqFw165d+fn53t7eLd0WhBBCDcApzOLy8/MBwNTUtKUbghBCLWyIY0+p6U6fWkYduS8UCrNzy+xsjeh0C3PDxKdvxDKT8W5klV/JophMZt++fe/evZuZmSle+5AhUmt3dnaOiooSCoXZ2dlks2ZRQqGwsLAwOzs7LS0tLi7uzJkz9Z2d1MnFCrd29+7dly9fLigoILse79y5s8HJyw1SuDG2traS+RuMZgqFwqKiorS0tAYvHUIItSDRGGJ9sULJdIXnO4vOZRaNIfYeYqWq0ril5AUCQXFxsZGRUcNZG8JisTQ1NZt07WkltlYGiqJ69pT+ZaOJcLlcsiQrQgihxmo/AcTa2tpjx44lJCRUVlb27t37k08++eqrr8S6VTabffv27ZycnC5dugwbNszMTPybxPv371esWDFnzhwMICKEkGVP6Xs99bL4Jz0zu1g0gGhirC+ZmUTBLC0t66vFwsJCahSsvrfQgbnMzEw6gJiamnrgwIG7d++mp6eT9RMbJHU3NIVbq6enFxoaOnnyZAAYMmSIUuZhKdwYerChPBS4dAgh1EqIhQVljD2Uekj+qCLZXozspHf8j8fBO6+mvXoHAPqdNHqbG4x3t94Q9KWq6n+mdpHtxS6cXkynaGpq+vr6kp6CKC0t/eOPPxITE9+/fw8AXbp0GThwoKenp9gutOfPn9+3b5+ZmVl0dPT//ve/48eP5+XlAYCenl7Pnj1Hjhw5duxYqduzJCUl3bx5My8vLy8vj81md+nSpUePHmPHjnVxcRHLP3bsWD6fHxQUNGzYsHv37h09ejQnJ0eB1pJ1PAoKCoyNjSMiIsT2mvv777/J+htLly6ldwtNTk5euXIlAISFhVlbWwPA3r17L168SI5WVFSQB2ALFy6k9yeV/9IBgKenJ5vN3rRp06BBg8LDw2/cuEE2/AGAU6dOffXVV1ZWVpKX7vbt2ydOnEhNTU1NTa2pqTE1Ne3Vq9f8+fO9vLw6yJ6BqOMwNTUlC4vj7zZqUDsJIJaUlGzZsiU7OxsA9PT0kpOTk5OTnz9//v333+vq/rMnYG5u7pYtW0gfAwDHjx9ftGjR+PHjRcs5fvy4gYHBhAkTmrn9CCHUhtDzmslGKzQmU0qfQk+YrQ/Z2ZDMR5avdrV/a/8n2vXTTz+tXbuWz+eTowMHDrS2tra1tXV2dj5//vyBAweklqOhoaHc1iYlJZEXKSkpubm5kvcwjaVwY+SfOi126fr3729nZ9fgpUMIodZJ/niiPBmkhheDd137cfNF+seKytrEl4WJLwvPxqXt2zhOT1dKz5Lzpoy84PF4YWFhZPcqqfLz8/Pz8y9cuCD1aF5e3ujRo0VTPnz4kJSUlJSU9Msvv8g4EdES8vLyHj58WF+G9evXi/74Ma0tKCggGytLFRoaGhoaKpbo7+9fX34AOHTo0KFDhxRrDIgsnSzqyZMnffv2vXLlyogRI+hEHo83b968Y8eOieYkw/MvXbrk7u5+7dq1jrO7OuoIJk2aRK+UjZBs7SSA+Msvv2RnZ9vb23/zzTddunQpKCgIDg5++fJlVFQUeaIlEAh++umnqqqq1atXOzo6FhYWhoWFRUZG9unThx7MkpOTc+vWrYCAAOwSEEIIALJzS02M9STTX2eWkBfWvbs1WIi1tXVeXl5OTk69tWRnk2yS6SYmJlJq/3cPEPKWmzdvfvfddwBgb2+/devWMWPGiEYGr1692mALldLapKSkoKAgAFBRUamurvb19b127VqjqlZiY+Qkduk+++wzgUBA1lWExl86hBBqZpTOctkZnPpISdybcE/O8h9W/N/rvwtyACAzt2LDlr8AwKyPbb/PPtPr1s2grPz8+fNv3759kf5+U+SbGzdukPxHN50SCg4BQPT+spoajpw1oubH5XJnzZr15s0b8kwOAPbs2UOih5aWlvPnzzc2NtbW1s7Ozo6JiUlPT79169bWrVulhiMRQqjdaw8BxLS0tBcvXujo6Pzwww9kvKGxsfGGDRuWLFly8+ZNb2/vrl27vnnzJjc3d86cOa6urgDQq1ev1atXL1y48P79+3QA8fDhw+bm5h4eHi15Mggh1GokPn3j6iRlIb9HibnkhVXvLg0WYmVldePGjfT09JqaGi0tLbGjXC6XbDRsY2MjXntiIvnEFkMPnSBzjsiag0wm8/r165JTd3k8XoMt/PjWcrlcHx8fLpc7ZMgQHx+fpUuXxsXFHT58eO7cuY2qXSmNkZ/YpWOz2fSsLmj8pUMItTMNhufE1NaVCoVCFRUVLR3DJmqSUgR86iw1XZ7AIreuDgCGfTFh2prVqgwGh8Ph8/l+EydErfk++8WLmzdvLt2314Ys4Pu5iXALAMD5v2PVmEzyxj59+tAjxLOysurq6lRVVU1NTUU/4dlsdn5+Po/HU1NT6927N8lfXl5eVFREMujr63fv3p0uh8fj5efnkyH55ubm9Jq5r1+/5nK56urqFhYWotMSBQJBdnY2h8PR0tISXXwwLS1NKBRSFKWpqWlqaio2k7FRrSW1ZGVlcblcDQ0NCwsLiqJqampyc3MBoHv37gYGBqKFs9ls8qjM0tJS9BFgSUlJcXGxqqqqWDfX2Makp6cLBAIA0NLSMjMzU1FR+fDhQ0FBAQB88sknz549KywsTElJoTcfI4MuraysHj16pKOjU1FRoa+vz2Awli1bNmjQoIyMjBs3bmAAESHUMbWHAOK9e/cAYPDgwfRsZQAwMjKys7N7+fJlQkLCxIkTq6qqAMDQ8P++0Ojr66uqqlZU/PNs8cWLF4mJiRs2bPjITTMRQqjd2BN6a6nvcAbjP8skFRR+iD6aAAAD+hnraDPreev/cXJyioiIqKqqCg8Pl9ztNyYmhqws8emnn4od+uWXX5YuXUqPCPin9oKC6OhoABgwYICOjg4AvH37FgAsLCwko4dCoVDGRC0ltnbr1q1Pnz5lMBiHDh3q37//b7/9Fh8f//XXX48dO/Zjlp9X+NLJSbmXDiGkXI2N36GPVF9gkfj79D/7ShkYGZHoIX1Ix8Bg7pbNW6ZO43O5lyOjbP67A5iAzzcw6lbytgAAkpOTycqDR44cIU+YduzY8c0334jVdfDgQT8/Py6XGxAQsGTJEgAIDQ1dtmwZAJibm79+/VpsslReXp6VlRWHwzE1NY2PjwcADodjZWUlFAq//vprye7Dz8/v4MGDhoaG5CkUoaamRp4b3bt3z8HBQTR/Y1tLxMXFjRkzpra2dt68eQEBAaRMNze3mzdvit1txcfHk+eFp06dcnR0pNM3bdoUGBioq6sr2k4FGqOrq8tisVRUVO7fv0+ihDExMfPmzQOAYcOGPXv2DABev35NDnE4HB6PZ2pq6u/vr6+vL/osTUdHZ+TIkRkZGVlZWYAQQh1SewggkvXjBw0aJJY+aNCgly9fkqO9e/dmMpkXLlz49NNPyaOq06dP8/l8e/t/NlY7fPiwvb394MGDm7ftCCHUeuW+KVu66mToL9PoGGJJafX/mxdTW8sFgM0/yrVc7KxZs3bs2JGWlhYUFDR06FAXFxf60KNHj3788UcA6Nmzp6+vr3jtubn+/v5hYWF0DLGkpGTmzJlkyb8tW7aQRGtr67i4uOzs7MLCwh49etBvr6urW716NYmCkTX+mqi1z58/Dw4OBoA1a9aQ24/w8PCBAweWlZWtWLHijz/+kLNqkBj0p/Clk5NyLx1CbVcThepqOWUaTA11ieHDqC1yt+x1GgAAflyzZpXrcJJYXV3N4XDIeLq8OXOioqJyXr7kcjhq6ur0G3va962trhYrjYT5dHV1RSNutHnz5q1fv760tDQ+Pl4sw8qVKyWXWjIzM5s9e3ZUVNT9+/dra2s1NDTU1dXfvHlT37kUFxfXd2jYsGFi0UOFWzt69OgFCxZERUUFBgYmJyenp6dra2tHR0d/5FgNhS/d0KFD6TGGNHosJL3osMKXDiGEOoL2EEAkQ9C7dBGfSUdSyAgLLS2tBQsWhIWF+fr62tnZFRUV5ebmDhgwwM3NDQDi4+NfvXq1a9euZm87Qgi1XpqaapEx95Jevp00cYCpcafnLwpOxT57k1cOAK5OvTzH95enEAaDsWPHjkmTJpWVlY0YMcLHx8fZ2VlFRSUhISE6OppEA7dt2ya5pYmmpmZkZGRSUpKXl5elpeWTJ09OnDhBvta7urp6enqSbBMmTAgLC+NwOCNHjly/fn2/fv3KyspevHgREhLy+vVrHR0dFotVWFh45syZ0aNHd+rUSbmtpScv29jY0GvP29vbr1mzJigo6OTJk97e3nRTZdcLACwW6+TJk/369dPT0zMxMVH40slJ7NJZW1sXFhbm5uYqdukQaruErH1NUawGn82oYwgFHWVlbQ1+DQBQQkrI0mzptiifsO4ueTG43xv6F4bB4VB8PjlfJ0d2VBQIhcLx2tftbI0A4FtKKABw7qv5LKm06L+lkcV8bWxs6BnHophMZt++fe/evUuGQYga8t/hjTRnZ+eoqCihUJidnW1nZyfeeKGwsLAwOzs7LS0tLi7uzJkz9Z0mvbKTUlq7e/fuy5cvFxQUkBUzdu7cKbX8RlG4Mba2tpL5G4xmCoXCoqKilJSUjIwM2ZcOIYQ6gvYQQKyurgYA0fnLBJndRq/oNHbs2C5dupw+ffrFixedO3eeMWPG1KlTKYri8/nHjh1zdnaW2q80CovFanDTTJJBKBSSWdX1qaurIy8OHDhw5cqVj2wYUiKhUEj/60hFllkBAC6X26EWEeto5wsAAoFA9i9DG0X/O/5xeO4c3+MPHuc+eJwrmsFrYv/wkGmS587n//PGtLS0adOmiR765JNPkpKSOBxOREREREQEna6mpubo6BgbGxsbG0tS6D1SBg8e/OBfokWZmpp26dJFtPzevXtnZmampqZ6e3uL5rS2tjYyMvr7778B4KuvvjIyMho+fDj8O6ru1KlTycnJUq+A/K1NTk4mU6uMjY3nzJkjcin4JAA3Y8aMzz//nB4wUlLyz/4za9euFV0Eil7cavr06QDQv3//Pn36NLYx8O+OzGfPnqXvnR4/fkxe0JtWs9ls0gF99tlnixYtioyMFLt0FEX5+fl5eHiQi/zVV195eHicO3eOzsBgMDQ15Q0QsNnsBj8Z6AzV1dVkfp9UdId+69YtsV8w1FJSU1PJCw6HI+PzkP52xOfz2+XHplRCoZDP59PfCjqIBr8mtVH0x5RJDx36BAUCAX2+Zib/PGVJe1XYy0KffqNxD92nz//5/Z8+fTqJWCUkJADAu3fv6vsoI0/Lnjx5QjLQPeOOHTtCQkIk89Mj43x9fekR5ZWVlZmZmSUlJVVVVZLDyUtLS0VrJxnoGkU1trWiLCwsyFAPQ0PDW7du3bp1S/Lt9fWMpHutrq4WLVaBxpCe8cGDB3QKvTsZ/U9J94xEenr6oUOH7t+/n5GRQfeeNKn3cRRFkXtPhBBqx9pDAJHL5QKA5M0Mmaos+iVm8ODBkpOUr127VlhYSI8c+Rh1dXUNBhBFM8s4Sn/dfPz4MX37h1oJOef0dbR7ho52vvDvzWFLt0L5hP/+Uw4bYp549+vdIbcux6UVFn7Q0FSzszWaNcNx7v8bAtL+EOgPwJKSklOnTslTF5fLTUhIIPcDYu7evSv1Lfn5+fn5+fIUnpGRkZGRQf/47t070VYlJyfXF0BUoLVSb4oAgM1mnz17VjL9+vXrMip68eLFixcvFG5MWlpaWlqaWCJ998vj8egOaOvWrR4eHpGRkRkZGe/fv+/WrZurq6uvr2///v0BwNfX9+TJk2w229jYWLTPEgqF8gcQuVwuhyPvDqSkQ2/waE5OjozNqVGLEAgE8nwettePzfp0wJ4R2unSB3TPyOeL/6qTH1VV/hnLVlNdJ5pBXf3/diM5ffq06Bvz8/Nl95V1dXViGS5evCi7neSZmTzYbLZk7VK7D0KB1ooqKytr8IuB1J6Ry+VKvlGBxkg9Nfp7i2jPGBoaumXLFvKPqKam1r9//169ellZWQ0dOvTKlSu//vqr1Cg5BhARQh1Bewgg6urqVlRUSD4dIkMVJEcmiqqrqztx4sTo0aNNTEzIW44cOfLkyZPq6mpbW9u5c+eKbk/WnJycnNTV1eW/6ULNxs3Di62yoKVbgVAT4lAAcA4AalXmduqutWnryk1b/5NB/NMWoLBwAQAIhcKbf48h65GjVsXY2NjZ2Vnq4k2jR48ePXq01HcFBweT5R1bCRsbGxMTE7IyCWpVBgwYoNVlORu3oUPtF90zvsp3NjAZJpkhNecEeWFqtZCt0g8AANYDCHjUIDcPq9T0g83WVCQndXV10T1biL///jswMBAA+vTps27dOg8PDybz//aLu3HjRnO2ECGEWpv2EEA0NDSsqKhgsVhi6SRFdCS8pHPnztXU1MycORMA6urqvvnmm7dv31pZWRkZGT1//nzVqlXbt2+3sbGRsyV6enoN5qmsrBQIBBRFyc48YsSI7OxsOUfZtHJ1dXU8Hk/qSiVtjpaWFj2vsD5sNps8ltTW1pZc6LpdEggElZWVOjo6Yhvmtld8Pp9MXVFXV9dqj6vj0yelp6dH/+VWVVWpqqo2eL737t1LSUn5mOEnp0+fJivS3rp1S/5hbkpXXV1Nhg7JfgrVJlAUZWtr2+C/XV1dXW1trTwdWaOWwNfW1m6w6pqaGvLATFdXV1VVtb5s+vr6KSkp6enp8g/2b7V4PB6bzdbW1pYxZbutUFVVtbOzUxfZNUISl8slC84wmcwW/LtuZpWVlerq6gqvUtrmfPjwQSgUqqiotMslU+nPsVevXn3++efkNZvN5nK55HzpIe2ffPKJ6Eg0DQ2N4ODgpUuX0oswAMC2bdvOnj2rpaV1+fJlyd8QHo/3xRdflJeXjxkzhuwYRveMX3/9NVnpQsyuXbvI8EbSdW7ZsuXixYvq6upnz57t3LmzWOaffvrp1KlT3bp1u3DhAp3o7OzM5/MXLVq0cOFCsfx0a2NjY8lHtJaWFv1ZLdlaOn3+/Pnp6el9+/adMGECaf+GDRsmTBDfge358+dkN7DDhw+Lfs0+dOhQZGSkrq6u6MjExl46AHB3d2ez2XPnzvX39xfNbGpqSg9s19LS0tfXBwCyKgiTyYyLi+vevTv5ykf3TeT/KioqJDNCCHU07eFun3yCl5WViaWXl5cDgGSvSausrPzzzz89PT0NDQ0B4M8//3z79u3SpUvJ14I3b9589913Bw8e/Pnnn+VsSaOiJw1mNjY2NjY2lr/AVqumpqa2tpZc5I6AvhtUVVXtOAE16EjnS6Moql2eMv07zGAw6BOkKEpFRaXB82UwGJLP8xvl0aNH5MXgwYNb8MFDeXk5+cWW3KGrvSL3UUr/lZYREKTREckGP0Y6depU3x4CbQuHw6msrDQwMJDn+rQD9ExeeT5G2pOOdr5Euzxlumfcu3fv8uXLyTmqqKiQbwIFBQUxMTEAMGDAALHQEvkd6Nevn2jipEmTzp49W1NTk5iYuGrVKrG6IiMjyV3MhAkThg4dCiI945kzZ3bs2CF2hQsKCsjUZnp/SPIk29LScty4cWKFC4XC3NxcAFBXVyeFE+Rz2MTERDRRrLVPnjwh4UU9PT36Gblka4lNmzalp6czGIzff/+9f//+9+7di4+P379/v7+/v5GRkWj5dBTP3t5e9CvE5cuXAUBVVVW02MZeOvi3G+rRo4fkqdFD2unep7CwEAAsLCxMTU3pbOSoUCik15Vql7/kCCHUoDb/3BsAzM3NAUBy0tzz588BwNLSsr43njx5UlVVdcqUKeTHly9fGhkZ0Q8Vzc3NR4wYkZmZKTk5GiGEEEIIIdTR5Obm+vv7i+4NVVJSMnPmTLJTh+gQPBlmzZpFhtoFBQXFx8eLHnr06NGPP/4IAD179iTj8hSo3draGgCys7NJOIxWV1e3cuXKhw8fQmOWqqRbu3PnTvLeBlv7/PlzsgLGmjVrBgwYQFFUeHi4mppaWVnZihUr5KyXENuGS+FLJyflXjqEEGpn2sPDk6FDh549e/bx48d1dXX0KhWVlZUvXrxQV1cnD+IkvX///tKlS3PnzhWdWiU2LYs8bOyYC2AjhBBCCCGERGlqakZGRiYlJXl5eRkbGycmJp49e5bs/Ovq6urp6SlPIQwGY8eOHZMmTSorKxsxYoSPj4+zs7OKikpCQkJ0dDSJBm7btk1yiq5o7ZaWlk+ePDlx4oRk7RMmTAgLC+NwOCNHjly/fn2/fv3KyspevHgREhLy+vVrHR0dFotVWFh45syZ0aNHNzjlnG5teXn55MmTZ8yY4ebmpqamVl9ruVyuj48Pl8u1sbGht6m0t7dfs2ZNUFDQyZMnvb295blQZJQfi8U6efJkv3799PT0TExMFL50chK7dHZ2dm/evMnJydm/f78Clw4hhNobYbvw7bffTpw4cefOnTweTygU1tbWfv/99xMnTty7d299b9m9e/eCBQs4HA6d8ttvv02cOPHatWvkx/z8/BkzZgQEBCi3qaWlpcXFxSUlJcottjWrrq4uLS1t6VY0HxaLVVxcXFxcTHbl7gh4PF5xcbHoX1P7xuVyyT9xZWVlS7elScTGxrq7u5M1g+jE8vLyqqqqlqq9+ZWVlZF/5RZsQzOrqalpqb6psrKSXG0ul9siDWh+dXV1xcXF5EtLR0DOt7i4mMVitXRbmk9paWl1dXVLt6L5lJSUFBcXt9evfPv37ye3TleuXJG6wPqUKVPIKpA0Ev8KDAysr8y9e/dKXSxbT0/vxIkTH1m72Hp/BEVRAQEBoksfjho1Sumt3bhxI6nr9u3boulsNpuM7zMxMamoqKDT6Z2jHz9+LJr/0qVLohVt375dgcYIhUKyJOXatWslT4pebv706dMKXzqEEOo42sMIRAD4+uuvV69efffu3cTERHNz86ysLA6HY2xsPG/ePKn5s7Ozb9++vXLlStG+58svv7xz586+ffuuXbumo6Pz4sULgUDg5+fXXCeBEEKtgpeXl5eXV8esHSGEEJLB1dU1JSVl+/btFy9efPv2rYaGRr9+/Xx8fBYsWNDYolasWDFu3LiQkJDr16/n5eUJhUITE5NRo0atWbOmZ8+e8tSuqalpb28vtfbQ0NDx48eHhISkpaW9e/fOyMhoxIgRK1asGDhwIAAEBAQcOXKEzWbXV5HU1rq5ue3fv//27dsFBQX1tfb58+dbt24FgEWLFg0fPly0BA0NjfDw8BEjRrx9+3bNmjUHDzawM/W4ceO2bdt28ODBwsLCLl26dO3a9WMunfzELl3Xrl1HjBixcuVKhS9d8zsSeLIFa58TOK0Fa0cINSlK2Pa3MiTKysp+++23xMTEDx8+GBoaOjs7z5gxo76dHwMDA0tLS0NCQsTmLNfU1Bw5ciQxMbGmpsbGxmbu3LkWFhZKbyfZhVnG7i7tTEfbRKW6upqsm9mpUyfZu1K2G3w+v7y8XHRF7faNx+NVVFQAAJPJbAdb9MqpoqKCwWCI7izZvnXATVTYbHZNTU2L9E1VVVVkyX99ff0OsjJ9R9tEhZwvAGhqarbg5kjNrKysTENDo8FdyNsNMvZQRUWlXX7lCw0NXbZsGQCwWCz6d7i6uprD4UgdEtgMtTc/FotF5gh3tK98ba5vwgAiQqiJtKWPQtkMDQ1JzyqPwMBAqelaWlpLlixRWpsQQgghhBBCCCGEEGrj2sMuzAghhBBCCCGEEEIIoSaCAUSEEEIIIYQQQgghhFC9MICIEEIIIYQQQgghhBCqV/tZAxEhhBBCCCGElM7ExMTd3R0AWmTjo5atHSGEECIwgIgQQgghhBBC9fLy8vLy8uqYtSOEEEIETmFGCCGEEEIIIYQQQgjVCwOICCGEEEIIIYQQQgihemEAESGEEEIIIYQQQgghVC8MICKEEEIIIYQQQgghhOqFAUSEEEIIIYQQQgghhFC9MICIEEIIIYQQQgihNm/27NkURY0dO7a8vBwAhELh4cOHf//995ZuF0LtAQYQEUIIIYQQQggh1Lbt3r372LFja9euvXTpkoGBAQAIBAIfHx9/f/+WbhpC7QGjpRvQ4aioqFAURVFUSzek+VAUpaLSgULVFEWpqqqSFy3dluajqqracc6X/ifuUL/Y5LOrpVvRfDrUPy7Rgp/VHfBjkz7lDgI/NjsC8o/bof6J8StuR9ChPqvbuoyMjNjY2NOnT0+ZMqWl24JQ+0QJhcKWbgNCCCGEEEIIIYQ+1pHAky1Y+5zAaS1YuyQ+n89gMPT19cmMZoWx2WwNDY0OFT1HSFIHemiGEEIIIYQQQgih1iYpKWn27Nn9+vXT1dUdNmzY0qVLi4qKyKH8/Hw9PT01NbXnz5+LvuXbb7+lKGrOnDl0ypAhQyiKyszMJD9OnTqVwWAAQEVFBUVRurq68lRHHD9+nKKovXv3JiQkODg4aGlpqaur29rafvvttxUVFWKNv3r16qRJk/r06aOpqdmzZ89x48ZduHBBedcGodYCA4gIIYQQQgghhBBqGTExMcOGDTt27NirV6+6du366NGjsLAwBweH27dvA4Cpqen27dt5PJ6vr69AICBvefbs2Z49e4yMjPbs2VNfsSNHjpw/fz4AqKurL1y4cO7cufJUJyo5OXnUqFEvX74cMGCAvb19RkbG7t27PT09+Xw+nWfp0qVjx449f/58eXm5hYVFRUXFlStXPD09Q0NDlXuVEGpxGEBECCGEEEIIIYRQC8jJyVm8eHFdXV1gYGBlZWVWVlZZWdn06dPfv38/d+5cDocDAEuWLHF1dX348OGBAwcAQCAQ+Pr68vn80NBQQ0PD+kpesmRJREQEAGhpaUVGRu7fv1/O6miRkZHm5ubp6enPnz9/9uzZzZs31S1HfHAAACAASURBVNTU7t69e+/ePZKBBB81NTUvX7787t271NTU0tLSkJAQANi+fXuTXTOEWgYGEBFCCCGEEEIIIdQCNm3axOFw5s+fv3HjRg0NDQDQ19f//fffHRwccnNzDx06BAAURR06dIjJZP7www8FBQVhYWGPHj2aOnWqAvulyFMdjaKo48ePW1lZkR/d3Ny8vLwAICUlhaQ8f/5cR0fHx8dn7NixJIXBYCxfvrxr1675+flVVVWKXxeEWh8MICKEEEIIIYQQQqgF3LhxAwBWrVolmkhR1IoVKwDg5s2bJMXW1vbHH3+srKz08fFZt25d586dyYjCJqqOGDhw4MCBA0VTLC0tAYDH45EfFy5cWFVVFRYWJpqnqKiosrISAOgJ1wi1D4yWbgBCCCGEEEIIIYQ6nLq6uvz8fAaD0adPH7FD/fv3B4CsrCw6ZfXq1SdPnoyLiwOA48ePd+vWrUmrAwBra2uxbCoqUsZgCYXC5OTklJSUrKys9PT0uLi4urq6xrYNodYPA4gIIYQQQgghhBBqbkVFRQKBoFu3bqqqqmKHevToAQB5eXl0ipqa2rx581atWqWpqTlu3Limrg4ARDdurs+ePXu2b9/+7t078qOBgcHw4cNZLNaHDx8UaCFCrRlOYUYIIYQQQgghhFBz6969u4qKSklJiei+xsT79+9JBjqlpKRk69atAMBms7/77rumrk4eO3fuXLVqFZvN/v777//3v/8VFxeXlZWdPXvWwMBAgeYh1MphABEhhBBCCCGEEELNjclkmpiY8Hi8tLQ0sUMvX74EAHoDEwBYvnx5cXHxhg0bunXrFhUVdevWrSatTh779u0DgNOnT2/dunXEiBFdunQh6fQiiQi1JxhARAghhBBCCCGEUAvw8PAAgD179oil7927FwDc3d3Jj+fOnTtx4sSgQYM2bNjw888/A8DixYsVWGpQzurkVFxcDACDBw8WTczMzHz79m1jG4ZQ64cBRIQQQgghhBBCCLWAwMBAdXX1qKiorVu3cjgcAKisrPT29n7y5EnPnj0XL14MABUVFX5+fqqqqhEREaqqqt7e3iNHjnz16lVwcLA8VbBYrJqaGvmrk5+dnR0AREZG0inXr18fPXq0UCgEgPLy8kaVhlArhwFEhBBCCCGEEEIItQBLS8uwsDAmk7lu3bpOnTrZ2NgYGhr+9ttvRkZGR44cYTKZALBq1arCwsLly5c7OjqSd5G37NixIyUlRUbhqqqq/5+9+4xr6vz/x38dCEu2iGhBEctSUcSiOBBx0IK4anEiLhAVRKQqbsQJ2GoBBasMF2ilah1YB26rUqkWHChaRARZyhBkZf5unP8n/3wDgSSMILyeN3yYK1fO9b5OSK6c9znnurS1tdls9qBBg8aPHy9mc+ILDAwkhKxZs8bMzGzs2LGGhoYODg5GRkaDBw8mhHz77bdxcXFS7RWAtggJRAAAAAAAAACQDXd39+TkZFdXV2Nj4/z8fCsrKy8vr7S0NDs7O0LI5cuXDx8+bGBgsG3bNv5LTE1N161bx2QyPT096cv9RNm/f7+hoWFWVlZmZqY4zUlk8uTJV69etbe3Ly4uTk9Pt7CwiI6Ovnr1akhIiLW1dU5ODu5lhvaEavjDBgAAAAAAAABfhKOBCTJsfW7gdBm2DgAtClcgAgAAAAAAAAAAgEhIIAIAAAAAAAAAAIBISCACAAAAAAAAAACASEggAgAAAAAAAAAAgEhIIAIAAAAAAAAAAIBISCACAAAAAAAAAACASAyJamtrazexvdLS0iZuAQAAAAAAAAAAAFqNZAnEsrKyFooDAAAAAAAAAAAA2iDJEohz5syRtIH379/fvHlT0lcBAAAAAAAAAABAWyBZAvHYsWPiV+ZyuRERERs3bqQfqqqqbtmyRaLmAAAAAAAAAAAAQLYkSyCK79GjR0uWLPnnn3/oh5MnTw4PD+/Zs2cLNQcAAAAAAAAAAAAtoflXYa6oqFixYoWNjQ2dPezRo8fZs2fPnj2L7CEAAAAAAAAAAMAXh+LxeM24uTNnzixfvvz9+/eEEHl5eV9f361bt6qqqjZjEwAAAAAAAAAAANBqmu0W5uzsbG9v74sXL9IPbWxsDhw4YGlp2VzbBwAAAAAAAAAAgNbXDLcws9nsn376qW/fvnT2UEtLKzIy8v79+8geQrPLzc0NCAiYNm2atbW1iYnJ2LFjFy5ceO7cOS6XK+vQpJeUlLRw4cIxY8YYGxv379/fwcEhKCjo7du3QtUOHDigr6+/a9euprcotKm4uDh9ff3AwMCmb1lS58+f19fXX716ddM3lZmZqV+fQYMGTZ069dSpU9Jdbd2Mu10c1tbW9faCj78sVVvDZrOnTJmir69vaGj4+PHjlmuold8RAFlpZ+Nd//79hb7NDAwMBgwY4OLicuTIETabLVS/hT7pGEkbhpFUtjCSAgBAG9fUKxDv37+/ZMmSp0+f0g9nzZq1Z8+ebt26NTkwgP+DzWYHBQXFxsYymUy6REFB4eXLly9fvrxy5cru3bv379/fr18/2QYpqaqqqtmzZ6ekpBBCFBQU9PT0Pn36lJ6enp6eHh0dHRQUNH36dFnH+OVRV1enKIr+P5PJLCwsLCws/Pvvvy9evBgbG8t/qi3r1KkTg1H/l7OysnIrByOmXbt2PX78eOvWrXFxcUuWLElKStLU1JR1UABfpHY53tEEv9xqamqKi4sfPHjw4MGDI0eOHDt2TF9fX7bhAR9GUpnASAoAAG2c9AnE0tLStWvXRkVF0WcjjY2NIyMjHRwcmi82gP8Pm81evHjx5cuXCSFz5syZMGGChYWFlpZWUVHRzZs3IyIiMjMzXV1dz507Z2hoKOtgJfDjjz+mpKT06tVr69ato0ePlpOTI4Tk5eUdPHgwKipq1apVvXv3tra2pivb2NisX7+e/7ApmnFTbdCTJ08UFRX5D8vLy0+ePLl169arV68ePXp03rx5Em1NJvsqKirK3t6+NVtsohs3bhw4cCA0NHTq1KlTpkyZMWOGr6/voUOHWuIgs33/9QK01/GOdujQIVtbW/r/HA4nMzPz/v37O3fuzMjImDFjxs2bNxUUFOhnW+iTjpFUTBhJWx9GUmhGocn3Zdj6iqHDZdg6ALQoKROI8fHxP/74Y1FRESFEUVFxzZo169evb7Mn9OBLFx4efvnyZQ0NjYiIiDFjxvDL9fT0Zs6c6ezs7Orq+ujRo3Xr1h0/flzURsrLyzU0NKRonb61StR5bKmVlJRcuHCBoqjjx48LHgd+9dVXgYGBHA4nNjY2ODj41KlTdPnAgQMHDhxY76Z4PF51dXWnTp3EbLqBTTWF1Hu4RWloaCxatCg7O/vQoUPXr1+X9LCnhfZV85L5nh8zZkx2djb9fx0dnWvXrjVcv6amRklJSbqDoi/iHQGQWrsc7+olLy9vampqampqa2s7ffr0rKysEydOzJ07l362hT7pGEmlg5G0FWAkBQCAtk/iORBfv349bty4OXPm0NlDe3v7J0+ebN26FdlDaCEFBQURERGEkA0bNggeTfGpq6vT07jcvXu3oKCALjxx4oS+vv7hw4crKiqWL19uampKbyQ8PFxfX5/+v6Dly5fr6+tfv36dfjhz5kx9ff0PHz5s2bLFwsLC0NDQ2tra09Pz1q1bdQN48eLF8uXLx4wZY2pq6uzsvH79evrT0bDU1FRCSM+ePeu9imTq1KmEkGfPnvFLoqOjBSesOXPmjL6+fnR0dEJCwsCBA01MTPr16zd37ly6Czk5OStXrhwzZoyJiYmDgwM/C1nvpup169atBQsW2NnZ9e7de8iQIXPmzElKShKsIGoPN+CPP/6YO3fugAEDRowY4evrm56eXm+1jx8/BgQETJgwwcTEZPjw4b6+vi9fvmx4y43q378/ISQ/P1+ovNFuCu6r/Px8c3NzQ0NDoci3bt2qr6/v6+sr/mabouE9L+beu3LlioeHh5WV1ZAhQxYvXnzjxo3c3FzBWbTE/KSI2Sj/z/Xx48fjxo37+uuve/XqNXLkyK1bt5aXlws18fjxYx8fH1tb2379+s2ePfvAgQMcDof/bL1/vS26wwFaTXsd7xpmbGzs4+NDCAkLC6utraUL637Si4uLt2/f7uDgYGpqamVl9cMPP1y8eFFoSr5G62AkbQqMpEIwkgIAQEcjWQJx69at/fv3pwc8XV3dw4cP37x508zMrGViAyCEkAsXLtTU1PTp02f27Nmi6pibm586derYsWP0XcB8LBZrzpw5p0+fZjAYXbp0kbTpVatWHTx4sKKiQldXt6io6OLFi25ubvv27ROsk5CQ4OzsfPr06czMTB0dnbS0tCNHjjg4ODx48KDhjdM597y8PP4JZ0GWlpbPnj1rdCOJiYl+fn61tbXW1tZycnLXr1+fP3/+4cOHnZyczp49q6qqqq6unp6e7uvry18hXRzr1693dXW9evXqp0+fevToUV5efvPmTXrLQjXF3MM8Hm/NmjXLli27fv16eXl5eXn5qVOnpk6deu/ePaGaDx8+dHBwiImJefr0qa6ubl5e3qlTpxwdHc+dOyd+/HU9f/6cECI0a5j43aR17959/fr1bDZ79erV/HUMnj9/Hh0drauru2XLFuk2K51697yYey8kJGThwoWXLl0qKSmpqalJTEx0c3MLCAiQLhLx37JXr17NmDEjIyOjT58+pqamWVlZBw4cmD9/vuBRTVxc3NSpU8+cOVNUVKSurn737t2tW7fOmTOn7tERX+vscIBW0F7Hu0bNmjVLU1OzoKDgyZMn9VYoKCgYN27c/v37MzMz9fT0uFxucnKyp6enYGpGnDr1wkgqJoykgq/FSAoAAB2QZAnEzZs3808Oa2ho7Nu3b7CEWqAL0M7RCetx48YJHSwJGTZsmL29fdeuXQULo6OjS0tLExMT09PTFy1aJGnT165dGzhw4P3791NTU1+8eOHn58flcoOCgtLS0ugKOTk5/v7+TCZz5cqVr169evDgQXp6+qRJkz5+/LhixQoWi9XAxgcOHNi1a1cWizVhwoSIiAihZZfl5OS0tbW1tbUbjjAlJcXZ2fnff/89d+5ccnLyN998w+VyN2zY0Lt377///vvChQsPHz50cnIihJw4cULMXqemph45ckRZWTkuLi4tLe327dvPnj3btm0bIUToYJKIvYfPnTsXFxfHYDCCgoIyMjKePn166dIlLS2tuLg4wWo1NTVLly4tKiry9vbOyMi4f//+69evV69ezWazV6xYkZWVJWYXBFVVVR0+fPjw4cPq6urLli2Trpt8bm5uQ4YMSU1NPXr0KCGEy+X6+/tzOJwdO3ZoaWlJvVkp1N3zYu69mzdvhoeHMxgMet6xJ0+eXL9+/euvv75y5YoUYUj0lsXHx+vr69+9e/fatWtJSUm///47g8H4+++///nnH7pCRkbGunXrCCGhoaEvXrxITk6+e/euubn5nTt3QkND6w2g1XY4QCtor+Ndo5SVlU1NTQkh9Z5RI4QEBQUVFRVNnDgxLS3t7t27aWlpYWFhhJCffvqppqZG/Dr1wkjaKIykGEkBAACIFLcw82VmZv4juWYMHTqInJwcQoixsbEUr83Nzd27d6+VlZV0TWtqav7222/0LcaqqqqrVq2i5/3Zs2cPXWHPnj0sFmvmzJk//vijkpISIURDQyMyMrJv3765ubkNTFBFCOnUqdPBgwe7du1aUlKyc+fOESNG2NjY+Pn5nTp16v3792JGqKur+8svv6ioqNARLly4kBDCYDD27t1Ln0tnMBj0b33xjxnS09NVVVWnT58+evRouoTBYCxcuFBHRyc/P//z58+ClcXZw1wu96effiKEbNy4ce7cufSOGjBgQHx8vNBB8sGDBwsKCn744Qf+nKoKCgorVqyYNWsWk8n89ddfxYl/0KBB/f/H3NzcxMRkw4YNPXv2PHv2rOBfkUTd5KMo6ueff1ZUVAwODi4sLDxy5EhqauqECROcnZ2bslkhS5Ys6V+fI0eO8OvU3fNi7j36vdiwYcO8efPoaubm5idOnJBu1jOJ3jKKovbt29erVy/64bBhwxwdHQkhr1+/pkt27drF5XL9/PymTZsmLy9PCOnVq9fPP/9MCPnzzz/rDaBZdjhAG9Fexztx0Eswi0og/vvvv4QQLy8vdXV1usTFxWXixImDBw/m31ErTp16YSStCyMpRlKMpAAAUJdk49zQoUNbKA4AUYqLiwkhBgYGQuV79uzZvXu3UOH06dN/+eUX/sP+/ftbWlpK3fSsWbP4xyE0Ly+vI0eO3Llzh8vlysnJ0fcNCV0vQFGUu7v7ypUr79271/BE44MHD/7rr78uXbp05cqVBw8e5ObmJiQkJCQkEEIGDhy4aNGiKVOmNBzhkCFDVFVV+Q+7d+9OCDE2NhZalYUQInhvS8Nmz55d9+65oqKiiooKQojQhFPi7OG8vLy3b9+qq6u7ubkJln/99dejR48WnAPoxo0bhJC6O23atGnHjx+/f1+sFeVKS0vrFmZlZYWEhOzevbtz5850iUTdFArbz88vJCRkxYoV//77r7a29o4dO/jPSr1ZQXTlugQvoqm758XZex8+fEhLS1NXV+evVEDT19d3cnK6cOGCOOFJ2iifhYWFhYWFYEnPnj3J/9Zt4HK5169fl5OTE4pt4MCB27Zt43K5PB6v7mzxzbLDAdqIdjzeNUpXV5cQUlhYWO+z9OoWp06d6tu3Lz9HI5RYEadOvTCS1oWRVOhVGEkBAACIpAnEpk9zAyApFRWVioqKuhflKSkpCa6Xx2azq6qqhOrQP6qkJjTRDyHEwMBAW1u7tLS0sLCQPjHLYDDqXi1ibm5OCHn37l2jTaiqqrq4uLi4uPB4PPq+lTt37ty5cyc1NdXb2zs1NTUwMLCBl2tqago+pC9DEJpBSboV+uh4Xr9+nZ2dnZmZeefOHSaTWbeaOHuYvjvb1NS07lJLAwcOFDzsoS/uiI+P//333wWr0e8sfW1Oo7KyshQVFfkPa2tr09PTt2/ffvXqVRcXl6tXrwpeICBmN4V4eXmdP3/+zp07hJB9+/bVnbJKus3yxcfH29vbN1yn7p4XZ+818F707dtXisMeid4yIyMjoZcLXjiTl5fHYrG6desmdOc+RVH0BUENaOIOB2gj2vd417CPHz8SQvT09Op9dsmSJYsXL46Jiblw4YK9vb2Njc3w4cOFuixOnXphJK0LIylGUoykAABQlzRX2gO0pq+++qqoqCgjI0Oo3Nvb29vbm//w/PnzS5cuFaojxUTygoRmmKJ17969tLT0/fv3HA6Hy+V26dKFvkNEEH0IlJeXJ35bFEWZm5ubm5svXLiwoqJix44dx44di4qKmjRp0qBBgyQKW7rjHEFRUVEREREfPnygH2pqag4dOrSysrLu+Xxx9jC9Rme3bt3qPkVf00FjsVj0AeTJkyfr3Q6LxWKz2ZLeH6SkpGRlZXX48GE7O7uMjIwLFy58//339FPid1MIg8GYMWNGYGCgsrJy3ZVSpd6sRIT2vJh7Lzc3l4h4L+otbJikb5mamloDW6NjE5U+aEDr7HCAVtBBxrt60d8Aghf9CZowYcLp06d/+eWX5ORk/qX6/fv3X79+vZ2dnfh1xIeRVBBGUn4FjKQAANCRIYEIbd3w4cNTU1Pv3btX720XfPUu3djwPPSC6p1hnf9Dqm6hrq5u165d5eTkSkpKOByO0DEV/VuQviFLlPXr179//37Dhg30zPGC1NXVg4ODnz59Sndc0gRiE0VGRu7YsUNdXd3Hx2fkyJF9+vShb1YaOnRo3d+R4uxh+tim3hvTBDeooKCgra1dVlaWlZWloKDQpD7Uoa6uPmzYsHPnzqWnp9OHPRJ1U0hJScnevXsJITU1Ndu2baOnFqI1ZbMSEdrzYu49Oph634t6/9rrEvykNO9bRh/I1XvfXANabYcDtIL2Ot41qra2lp7BTVQCkRAydOjQkydPfvr06a+//nr48OG1a9eePn06a9askydP2trail+ndWAkxUjaAIykAADwhZJ+ERWA1jFnzhwlJaXU1FT6aoJ6VVVVXbp0Sfxt1p3Ppd6Z0V+8eCFUUlhY+OHDBwaDoa+vr6io2K1bNzab/d9//wlVo68fqXubiaCcnJxr1641sLKQjo4O+d+kNq0pNjaWEHLw4MG1a9eOGDGCP9WR1JHQB4SvXr3ir+HO9/LlS8GHvXr14vF4mZmZQtXKy8sfPHhQ9+2QCP27nH/o25Rubty4sbi42M/Pr0uXLidOnBCc26HZ9574xNl79LTr9b4X9e7eRj8pzfiWGRoaysvL5+XlVVZWCj3l5+c3b968srKyuq+S4Q4HaHbtdbxr1G+//VZWVqanpzdgwIC6z7JYrOzsbPrSKk1NTWdn5y1btty9e3fSpEmEEHr9FnHqtCaMpI1uCiOpRI2KCSMpAAC0KCQQoa0zNDT08fEhhGzbtu3p06d1K7DZ7DVr1tBT0jSKPtssdLPVs2fP6v19dvz4caFfYJGRkYSQIUOG0PeSDB8+nBASHR0t9EK6ZNiwYQ1EQt9RFRYWVu+Puffv3ycnJxNZrFxEz+IvNK14dnZ2QUGBdBvs1q2biYlJeXn5sWPHBMuLiorOnj0rWEJfIXLgwAGhLfz8888uLi4SHTMLqa2tpfenmZkZXSJ1N69cuXLu3Ln+/fv7+flt3ryZEOLv78+fJ6jZ9574xNl7+vr63bp1q/te5OfnJyYmCpaI+UlpxrdMQUHB2tqazWbHx8cLlr98+TIhIeHJkydaWlp1XyXDHQ7Q7NrreNewrKws+kq0FStW0IsLCykvLx8+fPjIkSMF8zVycnJjx44lhNBfv+LUaU0YSRveFEZSSRsVE0ZSAABoUUggwhfA29vb3Ny8tLTU2dl548aNjx49om+pyM/Pv3jx4rhx486cOdPoVNk0egL406dP83+9vX371sfHp9415kpLS11dXelfftXV1WFhYTExMYQQf39/usLKlSsVFBROnDgRHh7OYrEIIRUVFcuWLXv69KmBgYHQUolC5s6da2RklJuba29vf+rUKXqSKXoLiYmJ06dPr6ysnDhxYlOOyqRjYmJCCBH86Xn37t2ZM2fSu6jedGfDKIpauXIlIWT79u3x8fH0jvrvv/9mzZoldFDn5eWlpaWVkJCwadOmT58+EUI4HM6hQ4diY2NVVFRcXFyk61FOTo6Xl1dubm7Xrl0dHBya0s3y8vK1a9fKy8vv2rVLXl5+6tSptra2b968CQsLa8pmm4U4e4/BYPj5+ZH/+168fv169uzZ9P/5xPykNO9btm7dOkJISEjIuXPn6Ibev3/v6+tLCJk6dWq9L5HhDgdoCe1yvKsXj8d7+/ZtXFyck5NTfn6+kZFR3XVgaTo6OoaGhkwmc+3atfwbKt++fbt//35CiI2NjZh1WhNG0ga6iZEUIylAO+Dm5kZRlKOjIz1pAI/HO3LkyIkTJ2QdF0DLQgIRvgCKiopnzpwZM2YM/Ytq0qRJ5ubmX3/9tbW1taen5/v374OCgqKjo8WZO2b06NHm5uafP392dHScOHHid999N2rUqFevXg0cOLBuZWdn55SUlMGDB1tbW5ubm+/atYsQ8uOPPw4ePJiu0LNnz6CgIEVFxZCQEFNTU1tb2379+v3xxx+6urphYWGCKxjWpaSkdPLkSXNz8w8fPvj6+g4ZMqR3795ff/21ubn54sWL3759O2LEiF9++UWqHdYk9CHKjh07Ro4cOX369CFDhsycObNHjx70Lpo1a9bp06cl3eaECRPmzJnDYrH8/f3NzMysrKzo3U7/zOXT0NAIDw/X0NCIjY21sLAYOXJk//79N27cKCcnFxYWJuYao4MGDeovwNTUdOjQoZcvX1ZWVt61axd/9nHpurl58+aioqKFCxfy77Oj/wAiIiJevXrVQntPTGLuvZkzZzo7Owu+F/b29pmZmT/88IPg1sT8pDTLW8Y3ePBg+iIULy+vPn36jBw5cvjw4c+ePbOwsOBnMYTIcIcDtIR2Od7xeXh48L+cTUxMRowYsWbNmoqKChMTk99++62BlT2Cg4MpikpISLCwsLC1tR02bJitre3Lly+HDRu2YMEC8eu0GoykDXQTIylGUoAv3e7du+Pi4tauXfvnn3/Si55zudz58+d7eXnJOjSAloUEInwZNDU1jx07duLECRcXl549eyopKSkoKPTt23f58uV3796dO3euioqKv7//qFGjGt4OnbabO3euvr5+Wlras2fPGAxGUFAQPU2SkEWLFh09etTR0ZHL5Xbu3Pm77747evQo/TOLb9asWYmJiVOnTjUyMioqKrKwsJg3b15SUpI4tx7r6+tfvXr1l19+cXBw6N69u7y8vIqKyoABAyZPnnzq1KmEhAQVFRWJ9lKz+O67706cODFs2LDS0tLXr1+bmZn9/PPPJ06c2LBhg6WlZV5enhS3tFAUFRISsm/fvrFjx2poaFRXV48YMSIhIaHubh87dmxSUtLs2bP79u2bn5/fuXPn77///vr1687OzmK2VVpaWiKgpqbGyMjI2dn56tWr/IsmpOvmzZs3ExISunfvvnr1an5h7969fXx86KMIHo/XEntPfOLsPQaDcfDgwZCQEDs7u06dOqmoqEyZMuX06dPjxo0T3JT4n5Smv2WCfH19f/vtN2dnZ21t7Q8fPlhYWKxbty4xMbHeGxtJy/y5AshWuxzvaBUVFYJfztra2jY2Ntu3b09KSjIwMGjghXZ2dpcuXXJ2djYwMMjLy6utrR0yZMju3bsF047i1Gk1GEkxkhKMpADt1OvXr//4449Tp04FBQWJv4IZQPtA1XsnC0BHwGKxcnNzv/rqq7q/qGbOnHn37t2zZ8/yL74AaN/Onz+/dOnS2bNn//TTT0JPNfBJAYAvAsY7gFaAkRTaiNDk+zJsfcXQ4U15OZvNawwfuAAAIABJREFU5vF4zbuOfFlZWb0TgDYjDofDYDC0tLQkXQZdSHV1tbKyMkVRzRUYQPNCyhw6LgUFBSMjI/ySA2gYPikAXzp8igFkC59BgAY4ODhQFFVYWLhy5UodHR1FRcUePXq4uLhcuXKlbuUrV65MnjzZ3NxcRUXF0NDQycnpwoULghViYmIoioqIiPj06ZObm5u6unpISAj/2SdPnri5uVlYWKirq9vY2Hh7e/Ovsc3NzdXU1FRQUEhLSxPc4KpVqyiKmjt3Lr9k8ODBFEXxF0+fNm0afal7WVkZRVHq6uriNEeLj4+nKCosLCw5OdnS0rJTp06KiopmZmarVq2qOwNpo30HaGlIIAIAAAAAAACAzHh4eOzZs6e8vFxPTy8/P//06dPjx48PDg4WrOPt7e3o6Hj+/PnS0tJevXqVlZVdvnx50qRJERERQltjMpnjx4+Pi4tTUFDo2rUrXXj48GEbG5u4uLhXr17p6uqmpKRERkZaWlrevn2bEGJgYBAcHMxmsz09PblcLv2S1NTU0NBQPT290NBQUZGPHTt24cKFhBBFRUUPD4958+aJ05yg58+fjxs37tmzZwMGDOjXr9/r16937949adIkeo1NSfsO0HKQQAQAAAAAAAAAmUlMTBwyZEhmZmZBQUFZWVlAQACXy123bt0///xDV6ATcCoqKpcuXSosLHzx4kVxcXF4eDghRCjPSAgJCwsrLi5OTk4uKSmhV05/+/bt4sWLa2trAwMDy8vL37x5U1JSMmPGjKKionnz5tEr2i9ZssTW1vbhw4f79+8nhHC5XE9PTw6HExER0blzZ1GRL1my5ODBg4SQTp06RUVF7du3T8zm+KKionr27JmRkZGWlpaamnrz5k0FBYW7d+/ev39fir4DtBwkEAHq8d133y1YsIB/tgqg3evdu/eKFSsmTpwo60AAoFVhvANoLhhJAZpCW1s7KSmpd+/ehBA1NbUtW7bQixpv2bKFrpCWlqampjZ//nxHR0e6hMFg+Pj46Orq5ubmVlRUCG4tOzs7Li7OxsaGX7JlyxYmk7lw4cLNmzcrKysTQrS0tE6cOGFpaZmdnR0dHU0IoSgqOjpaSUlp/fr1eXl5kZGRKSkp06ZNE1pjXRziNMdHUVR8fLyxsTH9cNSoUVOmTCGEpKenS9F3gJbT2svSAXwRFixYIOsQAFqVhYWFhYWFrKMAgNaG8Q6guWAkBWgKd3d3DQ0NwRJ/f//IyMikpCQulysnJ+fh4eHh4SH0qoKCgvLyckII/6Zj2qBBg6ytrQVLbty4QQihr0bkoyhq+fLl7u7uN2/epPOVZmZmmzZt2rhx4/z58//++28dHR36ikJJidkczcrKysrKSrCmkZERIYTNZtMPJeo7QMtBAhEAAAAAAAAAZGbgwIFCJYaGhjo6OsXFxXl5eQYGBnQhj8d7/vx5enr6mzdvMjIykpKSamtr626NvpKRr7a2Njc3l8FgmJubC9Xs378/IeTNmzf8En9//4SEhKSkJEJIfHy8FBfpS9QcIcTExESompxcPbeKitl3gJaDBCIAAAAAAAAAyEy3bt3qFhoYGBQXF797945OIIaGhgYHBxcWFtLPamtr29nZff78+dOnT0IvFMr6FRQUcLncrl27ysvLC9Xs3r07ISQnJ4dfoqCgsGDBAj8/PxUVFScnJyn6IlFzhBDBhZtFEb/vAC0HcyACAAAAAAAAgMzwU2OCCgoKCCF6enqEkF27dvn5+VVXV69bt+769esfPnwoKSk5e/astrZ23RcKXcHXrVs3OTm5jx8/Cq5rTCsqKiL/N3358ePHnTt3EkKqq6tXr14tRV8kak4cEvUdoOUggQgAAAAAAAAAMvPkyROhkry8vMLCQgaDYWhoSAjZu3cvIeTUqVM7d+4cM2ZMly5d6Gr8iQIboKSkpK+vz2azX758KfTUs2fPCCH8BUwIIT4+Ph8+fAgICOjatWtMTMytW7ck7YtEzYmjKX0HaEZIIAIAAAAAAACAzERHR3/+/FmwZNeuXYSQkSNHMhgMQsiHDx8IIUJLo2RmZr5//16c7Y8ePZoQEhoaKlQeFhZGCLG3t6cfnjt37rfffhs0aFBAQMCePXsIIYsXL5ZiqkExmxNTE/sO0FyQQAQAAAAAAAAAmSkuLnZ0dKQnB6yqqtq+fXt4eDghZNu2bXSFPn36EEKioqL4L7l27ZqDgwOPxyOElJaWNrz9wMBARUXFmJiYnTt3MplMQkh5ebmrq+vjx48NDQ0XL15MCCkrK1u6dKm8vPzBgwfl5eVdXV3Hjh376tWrHTt2iNOFz58/V1VVid+c+JrYd4DmggQiAAAAAAAAAMiMi4vLvXv3evbs2aNHD01NzU2bNhFCNm/ePGLECLpCYGAgIWTNmjVmZmZjx441NDR0cHAwMjIaPHgwIeTbb7+Ni4trYPtGRkaRkZFKSkobNmzQ0NAwNTXt3Lnz8ePH9fT0jh49qqSkRAjx8/PLz8/38fH55ptv6FfRLwkJCUlPT29g4/Ly8tra2mw2e9CgQePHjxezOfE1se8AzQUJxNbG5XI5HE7d6VTbMR6Px+VyZR1F6+HxePRbTJ8R6iA6VH/5b3GH+sPmcrkdrb8d8LtaVv3F3m73OubIyOVyO1R/O+DI2NF+4vK/qzvOHzb93dVx+itbK1asSExMnDJlCpfL1dXVnTx5cmJiIp04o02ePPnq1av29vbFxcXp6ekWFhbR0dFXr14NCQmxtrbOyclp9H5ed3f35ORkV1dXY2Pj/Px8KysrLy+vtLQ0Ozs7Qsjly5cPHz5sYGDAv+aREGJqarpu3Tomk+np6dnwX8L+/fsNDQ2zsrIyMzPFaU4iTe87QLOg8IXYykpKSrhcLkVROjo6so6llVRVVdXU1HTu3FnWgbSSysrK6upqQoiGhoaioqKsw2kNHA6ntLRUU1NTQUFB1rG0BjabXVZWRghRUlJSV1eXdTitpKysjMFgqKmpyTqQVlJaWkrnd/jTVLd71dXVVVVVMhmbKioq6NmFtLS06HmO2j0mk1leXq6trS0vLy/rWFoD3V9CiIqKiqqqqqzDaSUlJSXKysqdOnWSdSCtpLi4mMfjycnJdaiffEwms+Osgvr58+eamhpCSEf7yffFjU2hyfdl2PqKocMlfYmDg8O1a9f++usv/sWGANA24QpEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQ6UuazQEAAAAAAAAA2o3Jkyebm5t3795d1oEAQCOQQAQAAAAAAAAAGVi2bJmsQwAAseAWZgAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABCJIesAAAAAAAAAAKAZrBg6XNYhAED7hCsQAQAAAAAAAAAAQCQkEAEAAAAAAAAAAEAkJBABAAAAAAAAAABAJMyBCAAAAAAAANAe8D6Hy7B1Sm25DFsHgBaFKxABAAAAAAAAAABAJCQQAQAAAAAAAAAAQCTcwtx2Xbp0KScnR9ZRNAMmk8lisVRVVWUdSDNQVFScMmWKlpaWrAMBaKPevHlz/fp1Ho8n60CaqqqqisvlEkLU1NRkHUszGDx4sJWVlayjAAAAAACALxUSiG3U2bNnv//+e1lHAfU4c+bM+fPnZR0FQFvEZrOHDRtWVFQk60BAmJKSUmZmpr6+vqwDAQAAAACALxISiG3Uq1evZB0C1O+fB4+Pbfm9gQpMJpPNZhNClJSU5OXlWysuWeJyuTU1NR2tv4QQeXl5JSUlWYfTSmpqauTk5BQVFRuoU1FVgexh21RbW5udnd0OEogbN25MSkricDiyDqSpeDweh8ORl5enKErWsTSVgoKCq6vrsmXLZB0IQBt18+bNrVu3VlRUyDqQpuJyufS1+e3ju8vc3Hzfvn24rwgAQHxIILZ1Li4u1tbWso4CCCFk7dq1sg4B4MvQq1evJUuWyDoKIISQU6dO/fPPP7KOonk8ffp0x44dso4C6vHw4cN58+apq6vLOhCAtmjNmjUpKSmyjgKEPXr0yMbGxsfHR9aBAAB8MZBAbOucnJwWLlwo6yiAECQQAcRmYGCwZs0aWUcBhBDy6tWrdpNArKyslHUIUD8ul3t020kNVU1RFTgcTm1tLSGEwWA0fCFze1JdXc1gMBQUFGQdSCupqqoihFAUpaKiIutYWgmTyeRwOI32N+9tfuvEA5LCsAIAIBEkEAEAAOBLMmvWrIiICFlHAYQQMmHChPv378s6CoAvw8ePH+Xk5GQdBZATJ054e3vLOgoAgC8PEogAAADwJVFSUtLW1pZ1FEAIIQwGfkkCiEtbWxsJxLagU6dOsg4BAOCLhDEMAAAAAAAAAAAAREICEQAAAAAAAAAAAERCAhEAAAAAAAAAoA1xc3OjKMrR0bG0tJQQwuPxjhw5cuLECVnHBR0XEogAAAAAAAAAAG3F7t274+Li1q5d++eff9JTP3O53Pnz53t5eck6NOi4MPU1AAAAAAAAAECb8Pr16z/++OPUqVM//PCDrGMB+P8hgQgAAAAAAAAAMsZms3k8noKCgjiVy8rKtLS0WroVMUkdTL1MTEz++uuv5tqakOrqamVlZYqiWmj70I7hFmYAAAAAAAAAkAEHBweKogoLC1euXKmjo6OoqNijRw8XF5crV64IVouJiaEoKiIi4tOnT25uburq6iEhIfxnnzx54ubmZmFhoa6ubmNj4+3tXVBQIEUrtCtXrkyePNnc3FxFRcXQ0NDJyenChQvNEkxubq6mpqaCgkJaWprgBletWkVR1Ny5c/klgwcPpigqMzOTfjht2jQGg0EIKSsroyhKXV1d/L7Hx8dTFBUWFpacnGxpadmpUydFRUUzM7NVq1aVlZVJ2nfoyJBABAAAAAAAAACZ8fDw2LNnT3l5uZ6eXn5+/unTp8ePHx8cHCxUjclkjh8/Pi4uTkFBoWvXrnTh4cOHbWxs4uLiXr16paurm5KSEhkZaWlpefv2bSla8fb2dnR0PH/+fGlpaa9evcrKyi5fvjxp0qSIiIimB2NgYBAcHMxmsz09PblcLv2S1NTU0NBQPT290NBQUftn7NixCxcuJIQoKip6eHjMmzdP0r4/f/583Lhxz549GzBgQL9+/V6/fr179+5JkyZxOBwp+g4dExKIAAAAAAAAACAziYmJQ4YMyczMLCgoKCsrCwgI4HK569at++effwSrhYWFFRcXJycnl5SU+Pn5EULevn27ePHi2trawMDA8vLyN2/elJSUzJgxo6ioaN68eUwmU6JW6ASciorKpUuXCgsLX7x4UVxcHB4eTgipm82ULpglS5bY2to+fPhw//79hBAul+vp6cnhcCIiIjp37ixq/yxZsuTgwYOEkE6dOkVFRe3bt0/SvkdFRfXs2TMjIyMtLS01NfXmzZsKCgp37969f/++FH2HjglzIDan4uJiHo8nTk0ej/fx48cGKlRWVjZTUNDMeDxuVVWVODVra2tbOpg2paP1lxDC4XDE/GNoH7hcLpvNbqBCdXUH2htfnE+fPjU87tDEqaOoqKihoSFmu+Xl5UK/XxtQ9z4a8Z8F2aqurmZQjU8mxWazG/4aaWdYLBaLxZJ1FK2Kx+N1qJGRENJof/kXGUFbU1lZKc6oJ87oQ1GUjo5OcwTVcWlrayclJdE/MNTU1LZs2fLx48fIyMgtW7YI3kKbnZ2dkpJibW3NL9myZQuTyXR3d9+8eTNdoqWldeLEiZcvX6alpUVHRwsuW9xoK2lpaWpqam5ubo6OjvRLGAyGj4/Ptm3bcnNzKyoqBO8dli4YiqKio6MtLS3Xr1///fffnzlzJiUlZdq0aVKslyJR3ymKio+PNzY2ph+OGjVqypQpv//+e3p6+siRIyXtO3RMSCA2JzU1tUYTiJWVlXQdNTW1BqopKSk1Z2TQfChCKSoqNlCBzWbTvxQZDIacXIe4yJfH47FYrI7WX0KInJwcPRdJR8BisSiKari/iuyGPhogWyoqKg2POywWi8lkqqqqNropiT7pysrKDX9nEkJqamropJKKioq8vLyoap06dRK/XWhlCgqKDbzR/NMPHeprk8lkysvLN/An3c7wTxU0+pFvNzgcDpfLbXQdBqxU0GYpKSk1PDJyudyqqqpOnTp1kJ+4suXu7i50etLf3z8yMjIpKYnL5fLfgkGDBgkm7AghN27cIITQFwDyURS1fPlyd3f3mzdvCibRGm3Fw8PDw8NDKLaCgoLy8nJS53yA1MGYmZlt2rRp48aN8+fP//vvv3V0dOgrCiUlUd+trKysrKwEaxoZGRFC+Cf2JOo7dEwd5Tdc6xAn61dVVcXj8SiKUlZWbqBax/l5/eVpLIfC5XLpr9eOc9jA5XJZLFZH6y8hpNGEWnvCZrMbPfKX7zB740ukqKjY8LjD4/GYTGbDdaRrt9E6LBaL/vGqpKTUwN9Yx8lKfIkYDPkG3jsOh9MBE4gsFqtD9ZdOIHaokZF/wrjhakggtlkMBqPhUY/NZldVVSkqKnacv2oZGjhwoFCJoaGhjo5OcXFxXl6egYEBXdi7d2/BOrW1tbm5uQwGw9zcXOjl/fv3J4S8efNGilZ4PN7z58/T09PfvHmTkZGRlJRU771WTQnG398/ISEhKSmJEBIfH8+fQlF8kvbdxMREqFq9mXEx+w4dE74KAQAAAAAAAEBmunXrVrfQwMCguLj43bt3/NSeUKKtoKCAy+V27dq17nUM3bt3J4Tk5ORI2kpoaGhwcHBhYSH9rLa2tp2d3efPnz99+iT0wqYEo6CgsGDBAj8/PxUVFScnp7pRNUrSvotzA7L4fYeOCRdjAwAAAAAAAIDM8JNWggoKCgghenp6/BKhi+a6desmJyf38eNHwaWEaUVFRaROxrDRVnbt2uXn51ddXb1u3brr169/+PChpKTk7Nmz2tradV/YlGA+fvy4c+dOQkh1dfXq1avrbrxRkva9URL1HTomJBABAAAAAAAAQGaePHkiVJKXl1dYWMhgMAwNDUW9SklJSV9fn81mv3z5UuipZ8+eEUL4a4aI2crevXsJIadOndq5c+eYMWO6dOlCVxNnBTCJgvHx8fnw4UNAQEDXrl1jYmJu3brV6Pab0pw4mtJ36CCQQAQAAAAAAAAAmYmOjv78+bNgya5duwghI0eObHgOytGjRxNCQkNDhcrDwsIIIfb29hK18uHDB0KI0NIomZmZ79+/F6cXYgZz7ty53377bdCgQQEBAXv27CGELF68WIqpBiXqe6Oa2HfoCJBABAAAAAAAAACZKS4udnR0pKftq6qq2r59e3h4OCFk27ZtDb8wMDBQUVExJiZm586d9GpO5eXlrq6ujx8/NjQ0XLx4sUSt9OnThxASFRXFf8m1a9ccHBx4PB4hpLS0tOnBlJWVLV26VF5e/uDBg/Ly8q6urmPHjn316tWOHTvE2VGfP3+uqqqSou+NamLfoSNAAhEAAAAAAAAAZMbFxeXevXs9e/bs0aOHpqbmpk2bCCGbN28eMWJEwy80MjKKjIxUUlLasGGDhoaGqalp586djx8/rqend/ToUSUlJYlaCQwMJISsWbPGzMxs7NixhoaGDg4ORkZGgwcPJoR8++23cXFxTQzGz88vPz/fx8fnm2++oV9FvyQkJCQ9Pb2BjcvLy2tra7PZ7EGDBo0fP17SvjeqiX2HjgAJRAAAAAAAAACQmRUrViQmJk6ZMoXL5erq6k6ePDkxMZFOaTXK3d09OTnZ1dXV2Ng4Pz/fysrKy8srLS3Nzs5O0lYmT5589epVe3v74uLi9PR0CwuL6Ojoq1evhoSEWFtb5+TkNHo/b8PBXL58+fDhwwYGBoJXVpqamq5bt47JZHp6etKX+4myf/9+Q0PDrKyszMxMSfveqKb3Hdq9hmYTAAAAAAAAAABoac7Ozs7OzqKedXd3d3d3F/WspaWlmNfHNdwKIcTBwcHBwUGocPTo0SkpKU0PxtHRsd4U4ebNmzdv3ixYItgc34wZM2bMmCF+czRXV1dXV9e65UFBQUFBQYIl4vQdOjJcgQgAAAAAAAAAAAAiIYEIAAAAAAAAAAAAIiGBCAAAAAAAAAAAACJhDkQAAAAAAAAAkIHJkyebm5t37969HbQC0L4hgQgAAAAAAAAAMrBs2bJ20wpA+4ZbmAEAAAAAAAAAAEAkJBABAAAAAAAAAABAJCQQAQAAAAAAAAAAQCQkEAEAAAAAAAAAAEAkJBABAAAAAAAAAABAJCQQAQAAAAAAAAAAQCQkEAEAAAAAAAAAAEAkhqwDAAAAAAAAAIBmQKktl3UIANA+4QpEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRAAAAAAAAAAAABAJCUQAAAAAAAAAAAAQCQlEAAAAAAAAAAAAEAkJRGgqDw8PiqIoilq3bp2sYwEAAAAAAAAAgGaGBCI0ycWLF2NiYgghQUFBQUFBdGFOTs69e/eSk5NlGhoAAIBs4NQaAAAAALQzDFkHAF+w4uJiDw8POTm5ffv2LV26lF8eGxsbGBiopaVVWloqw/AAAABan+CptbVr19KFOTk57969k5eXHzp0qEyjAwAAAACQBq5ABOktXbr048ePR48eFcweAgAAdFj8U2uRkZH87CEhJDY21tbW1snJSYaxAQAAAABIDVcggpR4PN5PP/20d+9ePT09WccCAADQJvBPrbm6uso6FgAAAACAZoMEIkiJoihDQ8PWbJHFYjGZzE6dOlEU1ZrtAgAAiAOn1gAAAACgvcItzB1CXl6er69v37591dTU1NTUzMzMvLy8nj9/LlinurraxMSEoihjY+Pq6mqhLZw5c4aeD37v3r38wnv37tGFjx49okuWLl1KUVRgYCAhpKysjH42JCRE0mBo6urqFEWdO3eusrJyyZIlXbp0UVNTU1ZW7tu377x58/777796O3v79u2lS5eOHj26e/fu6urqffr0cXZ2Pn36NIfDkXjHAUA7hTUuoCXQp9ZaM3vIYrEqKyt5PF6rtQgAAAAAHRMSiO1fYmKipaVleHj4ixcvKisrKysrX716tX//fktLS/66yYQQFRWVmJgYiqIyMzPpDCDfp0+ffHx8CCF2dnbLli1rhWAEVVdXjxo16sCBA+Xl5YQQJpP54sWLo0eP9u3b98aNG4I12Wy2m5ubvb39r7/+euvWrYKCgs+fP798+fLPP/90cXEZN24ci8VqSvAA0D5g+XggOLWGU2sAAAAAIAkkENu5xMTEiRMnfvz4kcFgLFiw4ODBg7GxsZ6enkpKShwOZ/369XFxcfzKdnZ2Xl5ehJDdu3f/+++//HJ/f/+8vDxVVdVDhw41fPtwREQEm80OCAgghGhqarLZbDab7e/vL0UwfBs2bHj06JGpqWlERERycvKff/45bdo0QgiLxZozZw6bzebXDA0NpbdgZGS0Y8eOhISE33//PSgoyMzMjBBy69atnTt3NmFfAkB7gDUugODUGk6tAQAAAICEkEBszzgczpo1awgh2tra165di42NXbRo0YIFCw4cOHD79u2uXbsSQgICAphMJv8lwcHBhoaGHA7H3d2dzs3duXMnKiqKfqp3794NtygnJycvLy8nJ0cIoShKXl5eXl6ezjlKEQztzZs3tra2KSkpXl5eNjY2Tk5OCQkJbm5uhJD8/Pz09HR+zcjISEKIsbHx48eP169fP23aNBcXl7Vr1/7zzz8mJiaEEKHDKgDogLB8PODUGk6tAQAAAICkkEBsz+Lj4+n82oYNG0aNGiX4lI2NzZYtWwghWVlZsbGx/HI1NTU6Xfjvv//u2bOntrbW09OTx+ONGjXK29u7lYOhycnJRUREaGhoCBZ6enrS/+HfrsVkMtlstoGBgZeXl5aWlmBlNTW1sWPHEkLevHnTlC4AwJeOXuMiNzcXK+R2WDi1hlNrAAAAACAFJBDbs3v37hFC1NXVlyxZUvfZBQsW6Ojo8KvxOTg4uLu7E0ICAwM9PT0zMjJUVVVjY2ObuPaxdMEQQoYMGTJgwAChQv4C0PyZ4xUVFd+9e5eTk+Pn51d3+x8+fGhK8ADQPmCNC8CpNX6ncGoNAAAAAMSHBGJ7Rh9CmJqaqqqq1n1WSUmpb9++hJDMzEyhp3bv3v3VV19VV1cfPXqUELJr165Gr7BouWDo26yE0JdyNIDH4+Xl5d27dy8mJmbmzJmnT5+WMm4AkBGscYE1LloCTq3x4dQaAAjy8PCgR8B169bJOhYAAGiLkEBsz+gjVSMjI1EVevXqRerL2WlqakZERND/Hzx4cLPMFCZ1MN26dRO/lRcvXixfvtzKykpVVVVfX9/W1tbDw+PkyZPSRAwAsoM1LrDGRQvBqTWcWgOAui5evBgTE0MICQoK4g9tOTnP08aBAAAgAElEQVQ59+7dS05OlmloAADQViCB2J41etMcg8EghNTU1NR96smTJ/R/0tPTs7OzZRiM+Nd3/Pzzz/3799+7d29qaiqbzbayspo+ffqmTZsuXbqE1RIAviBY4wJrXLQcnFrDqTUAEFJcXOzh4SEnJxcZGbl27Vp+eWxsrK2trZOTkwxjAwCAtoMh6wCgBZmYmOTk5Lx9+1ZUhaysLLqaUPmTJ0+2b99OCJGTk6usrPT09Lx69aqsghHTzZs3V69eTQjp16/fzp07v/32W2VlZf6zV65ckW6zANDKBJeV+OOPP/gTwy1YsGDhwoWTJk0qKioKCAiYPn26oqIi/VRwcHBiYmJ2dra7u/vDhw8ZDIaka1zw/6XXuGhKMDR6jYuLFy/yZ6lzcnKaO3fusWPH6DUu+Pef8te4SElJEZylbtmyZYMGDXr9+vWNGzc2b94sza6E+jTjqTU6uyeTYCQ6tbZ27Vr6XngFBQUrKysTExMzM7Phw4efP39+//79kkcNAO3N0qVLP378ePToUawwBgAADcAViO2ZsbExISQjI6OqqqrusywWi5673dTUVKh8/vz5LBZr8ODB9MRhSUlJR44ckUkw4qPvKVNSUrp27dqkSZMEs4eEEMHrfQCgLcMaF/xOYY2LlkCfpmqWU2syDEZM9Kk1DofTr1+/c+fOlZeXP378+OTJk1u3bnV0dFRSUpJuswDQnvB4vJ9++ik3NxfZQwAAaBgSiO3ZsGHDCCEVFRUHDhyo++zhw4eLiooIIUOHDhUs37lz57///stgMKKjo5cuXTpixAhCyI8//lhYWNj6wYjv/fv3hJBevXrVvbGLx+M9fPhQus0CQCvDGhd8WOOiJeDUGh9OrQEAIYSiKENDQz09vVZrkcViVVZWNnoJNgAAtDVIILZnc+bMMTc3J4Rs375d6Pg2JSVl06ZNhBBDQ0PByyjS0tJ27NhBCFmzZs2AAQMoijpw4ICCgkJJScny5cslal3oyESKYCRCX6CRlZWVn58vWF5bW7tixQo6gYj1TAHaPqxxgTUuWhROrdFwag3gS5SXl+fr69u3b181NTU1NTUzMzMvL6/nz58L1qmurjYxMaEoytjYuLq6WmgLZ86coZdaps+F0O7du0cXPnr0iC5ZunQpRVH06mRlZWX0syEhIZIGQ1NXV6co6ty5c5WVlUuWLOnSpYuampqysnLfvn3nzZvHvypfyO3bt5cuXTp69Oju3burq6v36dPH2dn59OnT+D0PACArSCAKy83Nzc3NlXUUzYPBYNAjfUlJyZgxYxYvXnzkyJFjx455e3vb2dnRhz1BQUH8SxL4V1iYmppu3LiRLuzXrx89BVhCQsL58+fFbJcQ8vnz54SEhPT0dPoARtJgJOXs7EwIYTKZY8eOPX78+JMnT27durV3714LC4vw8HA1NTVCSH5+/unTp+lFUQGgbcIaF1jjokXh1BrBqTWAL1NiYqKlpWV4ePiLFy8qKysrKytfvXq1f/9+S0tL/rrJhBAVFZWYmBiKojIzM+kMIN+nT598fHwIIXZ2dsuWLWuFYARVV1ePGjXqwIED9E9xJpP54sWLo0eP9u3b98aNG4I12Wy2m5ubvb39r7/+euvWrYKCgs+fP798+fLPP/90cXEZN24ci8VqSvAAACCdL2ARlbdv3549e/bp06dlZWU6Ojo9e/b84Ycf+vTpI1StpqYmLi4uOTm5vLz866+/HjhwoIuLi+Bc+ISQ6urq27dvv337tkuXLjY2Nj169BDaSFFR0fLly+fOnWtgYNCyvWotkyZNCgsLW7VqFZPJPHjw4MGDB/lPaWpqHjhwYMaMGfySHTt2pKamUhQVFRUlmMjbsGHDyZMnX79+7eXlNWrUKE1NzYYbHTRoEP0feuPBwcF0ClKiYCQ1fvx4Ly+vyMjIFy9eCM7hQlGUr6/vuHHjJk6cSAihf3YkJSVJ3RAAtCiscYE1LloUfTZr8uTJ9Nms+fPnDx8+XE5OLjk5OTY2ln4rxTy1tn379oSEBFdX10mTJonTLvnfqTULCwtNTU19fX1Jg5GUs7NzZGQkfWpt48aNFhYWJSUlT58+DQ8P/++//9TU1D5//kyfWnNwcBCashMA2pTExET6pyyDwXBzcxs2bBiDwUhOTj5y5Ehtbe369et79OgxZ84curKdnZ2Xl1dERMTu3btnzpxpZWVFl/v7++fl5amqqh46dKjhcSoiImLfvn1bt27dunWrpqZmcXExEbiOXqJg+DZs2PDmzRtTU1NfX99vvvmmpKTk0KFDv//+O4vFmjNnzrt37+jvSUJIaGhoXFwcIcTIyMjDw4O+oPK///47fPhwRkbGrVu3du7cieXFAABaX1tPIP7111+7d++mj6y6du1aUlJSUFCQkpIyY8aM2bNn86t9/Phx27Zt9Fzjmpqaz58/f/78eVpa2rp169TV1ek62dnZ27Zto+8GIoTEx8cvWrRo/Pjxgs3Fx8dra2vT17K1G8uXL3dycgoPD7927VpOTg6Px9PX1x83btyaNWv4E3IRQtLS0nbu3EkIWbRokZ2dneAWlJWVDxw4MGbMmPfv369Zs+bXX39tuEUnJ6egoKBff/01Pz+/S5cuurq6kgYjnYiIiPHjx4eHh798+bKwsFBPT2/MmDH0dT2EEF9f36NHj1ZXVze9IQBoOVg+nv8slo9vITi11nKn1tw2T6u3nMlk0tccqaio1DshQLtUUlKirKzcqVMnWQfSSoqLi3k8npycXOfOnWUdSyuprKxkMpna2tqiKoQl3yeEcI4wSNOmtOVwOPQ3hra29h9//MFf1GvBggULFy6cNGlSUVFRQEDA9OnTFRUV6aeCg4MTExOzs7Pd3d0fPnzIYDDu3LlDLzgWHBzc6BQfdK6Q/peiKMFrMqQIhvbmzRtbW9uLFy/yT1c4OTnNnTv32LFj+fn56enp/LmDIyMjCSHGxsYpKSmCK4wtW7Zs0KBBr1+/vnHjBhKIAACtr00nED99+hQaGsrhcEaOHOnu7t65c2cOh3PhwoVDhw6dPHnSwsKCP8z88ssvWVlZ/fr1W7lyZZcuXfLy8nbs2PHs2bOYmJgVK1YQQrhc7s8//1xRUeHv7//NN9/k5+dHRkZGRUWZm5vzR9C3b9/eunXL19dXQUFBZn1uGSYmJoITndTL0tKSyWSKenb06NF1r8QZMWKEqMtz1q5du3btWqmDoVVUVIh6Sl9fv96mnZ2dReV/Q0NDQ0NDxWkXAGTI2Nj4xo0b9LISdQ+8xVnjYv78+d7e3vQaF/PmzWv9YMQnuMZF3buescZFy8GptRY6tXZsy+/1lnM4nNraWkIIg8FQVFQUlWcEaOPohCAfk8nkcDgqKiot3W58fDw93GzYsIGfsKPZ2Nhs2bJl6dKlWVlZsbGx/CW/1NTUoqKivv3223///XfPnj2+vr6enp48Hm/UqFHe3t6tHAxNTk4uIiJC6GJnT0/PY8eOEUL+++8/+siOyWSy2WwDAwMvLy/B7CHdqbFjx75+/frNmzdN6QIAAEinTScQk5KSmExmnz59fvzxR/rEl7y8/JQpU0pKSs6ePZuYmEgPMy9fvnz69Kmamtr69evp6w2/+uqrgICAJUuW3Lx509XVVVdX9927d9nZ2XPnzrW1tSWE9O7d29/f38PD48GDB/wE4pEjR3r27Dl69GjZ9RgAoKMbNmzYwYMH6WUl6q5NLM4aF/379z9+/Pi9e/d+/PFHR0fHpqwsKV0w4sMaFzKEU2tEdqfWROUZaUgvgkwIJQfbFHqOVHV1daGUHG3BggUbN24sLi6+d++eYAUHBwd3d/eYmJjAwMDnz59nZGSoqqrGxsaKP8lGMwZDCBkyZAj/4g8+/tkL/teXoqLiu3fvRLX+4UPTLuYEAIAmaNMJRHr2ent7e6GpDIcPH3727Fn+il33798nhFhbW/PvViaE6Onp9enT59mzZ8nJyRMnTqR/cAveUqGlpSUvL19WVkY/fPr06aNHjwICApo4pgIAQFPMmfP/2Lvz+Kaq/P/jJ2m6QUsBEUTGAkqpLMIXFERgKAI6AiPKKI5+gQEE+6PAgDojoKigsqo4CMNSEJRtvoCi4oAzAwzrtwoqS0H2pSy2KEup0DVNmt8fZ+Z+M0mT3CQ3yU3yej58zLQ3t/eepCWfnPc9555Bs2bNOn78+NSpUzt27CiXu5VUrnEhhMjOzm7Xrp1c48Kr1Uic17jwtjFeSUtL27Jli1zjomHDhsr2ioqK8ePHs8YFopOreJFgEf7Tc0rohuz1NG/evNo7AMTHx7ds2XL37t3OK3rNnj37b3/7W0FBgRzw/vbbb3ucvBy4xqSnpzvvr9xX0RWbzXbp0qW8vLzjx49v2bJl/fr1vjYcAOAvXQeIFoulXr16zuuZyCnGSp9K1ifl7kKK9u3bf//99/LRu+66Kz4+/q9//WunTp3kNLRPPvnEarW2atVK7rx8+fJWrVrdd999gXxCAAAPWOOCNS6AajkHi0SKcCNMs8JqycyuadOmrnZo0qRJtZldSkrK/Pnz+/fvL4To0KFDVlZWCBvjPNbejWPHji1cuHD37t0nTpwoKyvzrakAAG3pOkBUuoIO9u7dK4S466675LcFBQVCiHr16jnsJrfICWI1atQYPnz4ggULMjMzW7Ro8eOPP54/f75Nmzbyzh05OTknT5585513/GywV+NE3O9cVVXlZ2MQMDaVvx2bTe2e4U7OOom25ytFyVMWQthsNo+/Yq1eDda4CMQaF1VVVWrqjppCZjAYPI4ZsT+sx8WslR3cNzJ6/rmFo6oqd+8PAXrbXD7ZcXzxoNef1Org/pPvmVE4iDgkT3nu3q+Df1L5h+3xT9rTW6DaE7khr4HJy1oODh06JL84evTo+fPnmzRpEqrGqJ/m9e67706cOFH+IcXGxrZr1y4tLS09Pb1z585ffPHFwoULvW919VRWRpX/kB3mzAFA5NF1gFit3NxcOXZdXkwTQpSUlAgh7OcvS0lJSUKI0tJS+e0jjzxSr169Tz755PDhw7fccsvTTz89YMAAg8FgtVpXrVrVuXPnasfVe6WoqMhjTZVsNtv169fd7MClNt2y2WzVfj5z5ubOWREp2p6vEMJqtUZVz9Dj862oUPVPQw3WuNB8jYubN2+6rzuSmn3i4uLUD4csLi5W/+YgF+r17VGEVkVFeXlMnMfdLBZLQFcH+uCVVcrXT7xU/Z0fg6m8vFzlZ4aIUVVVpeZtRBNLDh0Mzonc8/grVtk7cCMtLe3ixYvnzp1ztUNeXp7czWH7oUOHpk6dKoQwGo0lJSWZmZmbN28OVWNU2r59+0svvSSEaNWq1fTp0x9++GH7q4P/+Mc/fDtstcrKytT8uaqpPgaD4ZZbbtGiUQCgX+EUIFZUVKxdu/bTTz+tqqoaOHDgPffcI7dXVlYKIZxXQJNTleWqf9J9993nPEl58+bNly5dcjXaEQAQEqxxIVg+HvDD+nc22X+rhzwR/tNJaBhkzZo127Zt24kTJ0pLS2UHx15lZaVcFrl58+YO2+UtPjp06DB06NDRo0dv2bJl+fLlQ4YMCX5j1JO3a4yPj9+6davzrOeAXoEAALgXNgFiTk7O0qVLr169mpCQMHz48F/96lfKQ8nJyUVFRc5D9uTYQ+eRifYqKirWrFnz0EMPNWrUSP7IihUr9u/fX1JSkp6ePmTIEK8GfcTHx3u8xmg2m+U+8fHxbnaTg/+hSwb3MxSU+XpGozF61uSxWq3R9nyFlxM5w52cxeP++TJ5R89iY2Pd1x05wjQuzvMgMq8qVGxsrMd3BovFokxVc/M3pqZtCJWYmBg37wDKDRBC+Lb5+Xt/l1/89uXHgnNGs9ns/mWJMPKavcFg0Pyf6sL93ylf6+r1lB/5PDbJ/w9HDzzwwOLFi2/evJmdnf3CCy84PPrRRx9dvnxZCNGpUyf77dOnTz9w4IDJZPrggw/uueeev/zlLzk5OS+++OIjjzzSoEGDIDdGPXn7qSZNmjinhzabTS4vphWTyeS+MtpsNrPZHBcX57GQRc9nYADRLAxSqhs3bixcuDAnJ0cI0bVr16FDh9avX99+h7p16xYVFRUXFzv8oNxSp04dNwffsGFDaWnpM888I4SoqKj4wx/+kJ+f36xZswYNGuTm5r7wwgszZ85UfwFNTpp2r7Cw0GazGQwG98mm+2KGEDIYDO5/O2azWV4djY2N1dXH3MCRt4aJtucrhDAajdHzT7W8vNxoNLrvFpqtUTeNPYzUqFHDfd0pKysrLS11v48PnOcHOLt586b8N1WzZk036aTzUBfoR1xcnJv3Q6vVKtOlmJiYkAfBSpIY6DVYCgsL4+LioufvVl4j9/gRVyX7JVB0W2rNZrPVavXYPP+jpUGDBs2aNev48eNTp07t2LFjly5dlIe+/fbb1157TQjRuHHjzMxMZXtubu60adOEEBMmTGjTpo0QIjs7u127doWFhWPHjl271vH+oW44DPrzoTFeSUtL27JlS15e3qVLlxo2bKhsr6ioGD9+vAwQtbqBTHx8vPs/V4vFYjaba9SowdgOABD6DxAvX748YcKEa9eupaamjhkz5u6773bep3bt2kKIwsJCh+3ylhZu7kZx48aNTz/9tF+/fnXr1hVCfPrpp/n5+aNHj5bDGy9cuPDSSy8tWrTovffe0/AZIfI49EBKSkrkeNhatWqFvJsUHFar9fr16ykpKXKF9IhnsViKioqEis+dkaSoqMhkMtlfJnFe4LKk6GfxdnCbBQC+UpZ1ZjVn/YikpZM1ZDKZZs2a9dhjjxUWFvbo0WPo0KGdO3c2Go179uxZtmyZvAnjjBkzlHsFKpOXmzdvrtymqVWrVhMmTJg6deq6desGDhzYr18/NecVQhQXF69bt65169YpKSmNGjXytjHe6tu374IFC8xmc8+ePV999dXWrVsXFhYePnx47ty5p0+fTkpKKi4uvnTp0vr16x966CH1N+QFAPhP1wFiaWnp5MmTr1271qtXr6ysLFfZRGpq6v79+w8ePPjLX/7Sfntubq4QomnTpq6Ov27dupiYmCeeeEJ++/333zdo0ECZHJ2amtqjR48vv/yyrKxMzQAKRC2lByIpIxDj4+OdR+TRS4Fuue+2qRmBCADhiCQx5MgNPerXr9/777//xz/+0Ww2L168ePHixcpDKSkp2dnZv/3tb5Ut06ZNO3jwoMFgWLJkiX2QN2nSpLVr1546dWrUqFEZGRkpKSnuT9q+fXv5hTz4zJkzJ0yY4G1jvNWnT59Ro0YtWLDg2LFjAwcOVLYbDIZx48b16tXr0UcfFUI8+eSTvXr12rJli88nAgB4S9cB4tatW/Pz8++7776xY8e62a1jx46ff/75d999V1FRoUwiuHHjxuHDh+Pi4jIyMqr9qcuXL3/55ZdDhgyxn1riMMVA3qZH3rUH0IRD2uiM3gsCgb4ZAHhEkhhk1CavjB07tnfv3nPnzt26devFixdtNlujRo169eo1YcIE+5u25+bmTp8+XQjx3HPPdevWzf4ICQkJ2dnZPXr0yM/PnzBhwqJFi9yfsXfv3jNmzFi0aNGlS5fq1at36623etsY38yfP79Pnz5z5849fvz4Tz/91KBBgx49eowdO7Zdu3ZCiHHjxq1YsaKsrMz/EwEAvKLrAHHz5s1CiMcff9xVhCcDvtatW6enp584cWLu3LkvvvhiTExMRUXFzJkzKysre/XqVbNmzWp/dtWqVXXr1u3Tp4+ypXXr1v/zP/+zZcuWhx56SAiRn5+/bdu2pk2bujoCEAiuEkY6M/CInhgAaELWYipv4FCwfJOWljZv3jz3+7Rt29ZsdnlL4gcffNB5yccuXbq4Wgdy4sSJEydO9Lkx0s2bN1091KhRo2pP3bdv3759q185fc6cOXPmzFFzXgCAtvQbIFqt1h9++EEIody5w0HDhg2zs7Pl1y+++OL48eN37969b9++1NTUs2fPms3m22+/fdiwYdX+bF5e3s6dO59//nn7adG/+c1vdu3aNW/evM2bNyclJR0+fLiqqiorK0vrZwb4otpgkb5N1KLrBQCBRoyoOYoXAADhS78B4pUrV9TPHW7YsOH777//l7/8Zd++fadPn65bt27nzp2ffvppVyvfLV++PDU1tXv37vYb4+PjZ8+evWLFin379hUUFNxzzz1Dhgxp0qSJf88DCCCHVJFOTqSixwUAoUKMqAkKGQAA4U6/AeJtt932xRdfqN+/bt26Y8aMUbnzlClTqt1eo0aNkSNHqj8poCvkiZGEvhYA6Ae3R/QNtQwAgIih3wARgJ/s80Q6PPpHLwsA9I8BiSpR1AAAiDAEiEBUIEzULbpYABB2iBFdWZx7IDExMdStAAAA2iNABKIO87BCjtAQACIAMaK9xbkHhBAGgyHUDQEAAAFBgAhEL5LEICM3BIDIQ4xIdQMAIBoQIAIgSQwselYAEPGiMEakugEAEFUIEAH8H5JErdCtAoAotPKNj6OhgFLjAACIQgSIAKpBkugzulUAEM0ieygiNQ4AgKhFgAjAncjuCGmIPhUAQLHyjY/LysoGvf5kqBuiGcocAABRjgARgGcMSHSFDhUAwJU10z+PjY0N69JJmQMAABIBIgAvMCBRWnLooBAiJiYmPj4+1G0BAOhamJZOokMAAGCPABGA18K0L+Q/2ZuqqqoKdUMAAGEmjNZXIToEAADOCBAB+EiZ1/zfr/4mtC0JAnpTAAA/6f/yG8UOAAC4QoAIwF+r3vykvLz82an/HeqGaI+uFABAW/qMEal3AADAPQJEANpY/db6mJgYvfWIfEM/CgAQUPqJESl5AABADQJEAFoK9/Wa6UcBAIImhDdGpN4BAACvECACCAj9jK1Qg34UACAkgl8uKXkAAMAHBIgAAkj/MSL9KABAyAWnXFLyAACAzwgQAQScDmNEOlEAAL0JXLmk6gEAAD8RIAIIEp3EiHSiAAB6pu2NEal6AABAEwSIAIIqVKus0IMCAIQLTS65UfgAAICGCBABhEbQBiTSgwIAhCPfCiVVDwAABAIBIoBQ4n5PAAC4oX5GM4UPAAAEDgEigNDTNkakBwUAiCQeqySFDwAABBoBIgC98DNGpPsEAIhg1VZJah8AAAgOAkQA+uJDjEj3CQAQJZQZzdQ+AAAQTASIAPRITYxI3wkAEIWenblECNG2e6tQNwQAAEQRAkQA+uUqRiQ6BABEoe3xRcrXuTuOCGJEAAAQLASIAPROiRHJDQEAUcg+N3SQu+MIGSIAAAgCAkQAYWB7fNF2ZmwBAKKMm+hQwVBEAAAQBASIAPTLueMku0mCnhIAIKKpiQ7tESMCAICAIkAEoEceO070lAAAEcnb6NAeM5oBAECAECAC0BEGXAAAopY/0aGCyggAAAKBABGALvg54ELQWQIAhC1NokN7VEYAAKAtAkQAoaRhl4nOEgAgvGieGzpgRjMAANAKASKAEAhcl4kYEQCgf4GODhWURQAAoAkCRABBFZwuE/0lAIA+BS06tEdZBAAAfiJABBAM9JcAAFEuJKXQHjOaAQCAzwgQAQSWHvpLghgRABAiIa+D9qiJAADANwSIAAJCV/0lQZcJABB0u2rcNBqNoW5FNaiJAADAWwSIALSkt9zQAV0mAECgyVJoibEYhR7TQwUzmgEAgHoEiAA08L9JJSZThcFgCHVDVJExoiBJBABoSudX0ZxxXQ0AAKhEgAjAL9vji2w2m7CEuh0+oeMEANBE2EWH9qiGAADAIwJEAL4I656SAzpOAADfRFg1pBQCAABXCBABeCGSekoOiBEBACpFajWkFAIAAFcIEAF4Fqk9JWf0nQAAbkRDQaQUAgAAZwSIAFyKhm5Steg7AQDsRWFBZEYzAACwR4AIwFEUdpOqxWLNABDlorwgcjkNAAAoCBABCBH1fST36EEBQFShJtqjCAIAAEGACEQ5+kjq0YMCgMhGTXSDGc0AAEQ5AkQg6tBB8kfujiM2m635/XeGuiEAAA1QE9XjQhoAANGMABGIfPSONHc056QQwmg0tu/ZJtRtAQB4h7LoD2JEAACiEwEiEIHoGgUN/SgACAtURm1R/gAAiDYEiEDYo1MUcvSjAEBXqIzBwY0RAQCIHgSIQNigO6RzMkYUJIkAos+AP/arX7++EGLlGx8H/+zUxxDiEhoAAFGCABHQEbpAkSF6elPjOnVWvrYVz7t6rWRSCFsDIHQ+fveLWjVT7LcMnjxA+dpsNt+4cUMIkZiYWLNmTeFrzkiV1K3cHUcqKytbdmke6oYAAIBAIUDUqStXrsgvhg8fPnz48NA2BvZKyoqVTpH6/g99nigUdgMS7dNAZ0VFRSaTKSkpyVY8T9loK94X+HYBjs6dO/fxxyEY5gZnyscVZ/Yl0mq1/npsL/tH7eNFe+/v+UrYvX8ivBzNOWkwGO7t1TbUDQEAANojQNSpM2fOhLoJqF5JRemzM5f865v4f/2/fUJkNpstFosQIj4+PiYm5l87iEZ0h6KWHgYkug8HXbHPCuMt5cYqo604TrtGAd65fv26/GLHjh07duwIaVvgyFpV5ebRnYk3/rlwnRDCaDTGxMR4fD90tQOVNCzooeoBAADNESDqVJs2bT777DMhRFxcnMnEr0kXSktLhRDJdes4fCbO3XHEvktjtVrvfqCZ84+r+SRN1yiCBWFAom8poT37xBDQG7PZHOomwKXr3eofPOpyNKKw/cd39sXOq7dE552pm7oVzTGiw/09FseX/xjC1gAAoBGSKZ2qUaOG/GLhwoXPPvtsaBsDyWAwCCHiExMdtjt8ON7/z0NHc04KIUwmk8Fg8LNrJNFBiiSaJIn+Z4USiSHCSIMGDeQXjRo1atOmTWgbA2nv3r2FhYVCCFNsrG/pnp9vic6X9Hw4CAInYmLEastuSUmJ2WyuU6eOQzHl/h4AgIhEgAhorLS1V/IAACAASURBVPUv77afwuzzOAt71f4g3aRw51W3mcQQUDz00EMffvhhqFsBIYTIyMjYtWuXq0eVNzer1Xpg22H3h9Lk4gp5oj7l7jii8wzRqyKrVFKT2WywWm3FjpeWAQCISASIQGDZf2LWJEx0cwR6SmGq2m6zVomhIDQEoANyfV6TyRQXFyfcFiwNb/jgqgQj+HQyFNGH2koNBQBAIkAEgkf53Gx/20QNP0zTUwp3df+R/3/fdPL3aPR5AOiWfUF0tY+2hVLNGRFoQbgdsMLn63BUTwAAqkWACIRAtUmfth+mmcYVLh6sqF3t9pVvfKx8PXjyAJVHo9sDILyoufQVoCTRzRkRaJoPSPRn2D6lEwAANQgQgRBzHhMRiMvyjLzQFVehoStqwkT6PwDCncdSpXnqJA9FZQwVf36hft7og6IJAIC3CBABvQhykijoMgWdt7lhtezDRCHEPff+M+S3lAIAbblPEgMUI7o6HQJN/S/U/7sDkxsCAOAzAkRAd5QBEYG+4zhdpuDQJDd0cM+9/1S+dv71ESkCiAxu6lQgSiRlMYTc/EIZbAgAgB4QIAI65dCNCWgkRJcpEAKRG4r/jA5dcfV7JFgEEKZczTUOUIlkanOoKK/5sonP+XkockMAALRFgAjonX03JtABEEmi/wKUGwp10aF7Hn+tWv2B/fDDD7NmzdLkUPDToUOHQt0EQDPEiBFPqaHyfh3q1xCzR3QIAEAgECAC4SGYMaKg1+S9wOWGQovoUCU3v3GLxWIwGGJiYuS31f4RVlZa5Rfnzp2bOHFiIFoIn12+fDnUTQC04epaV0BjROfTQUOuaqhy2181SSK5IQAAAUWACISTkMSIgl6TawHNDUUQo0Nv2f9JHN7XU37xc3FiiJoDz4xGY6ibAGis2mtdgSuRXFrTnPoa6j5JJDoEACAICBCB8BPkGFHQa3LStbimECImJkbEB+oU+owOlaywWkpEVb9+/YcffjgoLYIHX3/99ZkzZ4QQ9erVC3VbgIBwFSMGqD5SEDXh8+U3hySR6BAAgKAhQATCVahiRBHFHSfZ4amqqioX5QE9kR7SQ4essLy83Gg0xsWp+tnmzZuvXLkyIM2Cl4YPHy4DRCCyte3eKmhDEQUxoq80HLZ/cONI5WuWCAMAIAgIEIHwpvRhgvnpOQo7ToGeqqwIYXTofnQhAOhckIciujojnGlbQ50Lpf2vgDARAIAAIUAEIoEy8iL4MaIQ4uD274N20iALWm4oQhEdkhgCiDzOoV6g6yMxohuBjg6dESYCABAgBIhAhAjJUESpTUbL8vLyk3vPBvm8gRPM3FAKTnpIYgggSlQbIwa0PhIj2gtEGfWhUDr/OogUAQDwGQGiloqKimw2m/t9qqqqhBA2m+369etudisrK9OyZdBOla3K/W9H+Rswm81BadF/aH7/nfu25gohWnZpHuRTp3e6SwhxNOdkkM+rLbk6SplQ9Q/QarVq8k+1faddFov/h6ne/j3d7L7zvbU2m62qqspqtbrZp7ycNy79unnzpvu6Y7PZPNYmKTY2NikpSeV5i4uLKysr3e8jK6MQ4saNGwaDwdVuN2/eVHlSBF9ZeXmMivdDi8Xi/m1EW83vv9O+Ku3bmhvo4tj8/jvFv0uhfNtU/ryjRJebNQwGg8oyqlL7TruEEJoUSvkZyZ6ffxI2m83jJ4EqT70DhEpZWZmaqqem+hgMhtq1g335GQCCjABRS7GxsWoCRLlPbGysm91iYmK0bBm0YxAG978dpbdgMBiURWmD6Z5uLYQQ3+8+3vqXdwfnjDabzWq1Go1Gg8GgnD04p9ZKt9Lkf32l4l+efL5CCIPBwx+DR//VcYcQQgiXiYnPDn7TXX6h1XuJfMrun2+MkTcu/TKZTO7rjtVqtdls7vdRDuXVeT3uU1lZKf/ATCaTm7dNr86LIIsxxrh5f9DwbdNb93RrYV+Sjn11KgjFUZ5Uft5zk4lHmC43a8gvNPwVB65KKo59dara7Wr+TuSneo/PN1r+AsJQTEyM+6on37tiYmI8fqSPnn/pAKIZn8W1VLNmTY/7mM1mm81mMBjcD9+IU7nWKYLOYDC4/+2YzWYZIMbGxoYwCG7fs03QpjPLgWkmk0l5vu17tpFf6H8y17+mWXnzD04ZiGc0Gv35p3rPvf9UFVh6Q5mkrPlbyL9XYXZ33FgLb1z6lZiY6L7ulJWVWSwW9UMLVUpISPC4z82bN+W/qRo1arhJCRMTE7VsGTQVFxfr5v3BarUqFyGC/wlHliSlHh376lQQimP7nm3KysqOf306JJcSg0mZrVwqSoWKj0nqBaJKqucqWJTkn5D8VO/x+ZaV/2vw5MMPP0zMpAcFBQXyC5vN5r7qWSyWiooK97UJAKIHb4VAxArJyirObRC6jBGDf5dDB9re9JCbGwKAe0pNFIFfVkXR+pd3x8bG6rAIaiJwlTT4q4p5S/5O5cBtN9GS/Bv76fIN+e0//6n35xVtDh48GOomAEA4IUAEIpnsL4VkZRWHZgjdxIiRFB2SGwKAevYZogjismO6KoKaCGgl1X966J59aT68TwghTIZEITzcChYhcccdd4S6CQAQTggQgQgXwtWZXbUkJGcPeW4oadUvIjoEAB84VKJgFsfIiBEDXUzDKz08+E13q9Xq8e4KtWrWull6Qwixbdu2iJ/SHhb+/ve/z5w5Uwhx++23h7otABBOCBCBqCCHXYQ8QxSh6EHpJDoUGvWLiA4BwE8O05mDWRwdRkGGiyBUUp1Hhy6Kr9mrg2RkZBAg6kFeXl6omwAAYYkAEYgW+skQRVBiRP3khoLoEAB0JrQZogifoYjBKaY6TA+puQAAOCBABKKIrjJEYXcDe237UbqKDoUW/SK6MQCguRBmiCIcYsSgFVOdpIeUWgAA3CNABKKL3jJESZN+lN5yQ8nPfhH9GQAInNBmiEKvMWL0RIcUWQAA1CNABKKOPjNE4Uc/Sp/RofCva0SvBgCCIOQZotDTjRGDWU9DlR5SXgEA8A0BIhCNdJshCm9iRN3mhpLPXSP6NgAQTDrJEEXohiIGv54GPz2ktgIA4CcCRCBK6TlDFJ66UjqPDgXpIQCEFT1kiCIUMWJI6mkw00OqKgAAWiFABKKXzjNE4dSV0n9uKPnWNaKTAwAhpJ95xMFpSahKanDSQ0oqAACaM4a6AQBCST/9JTfadm+1bOJzpIcAgIBSrqiFvDK27d4qcJf3HqyoHaqBh4FODw/v6yn/C+hZAACIToxABKKdnschjuvUWfl68OQBQoiVb3wcuuZ4QHQIAOFOua6mh8qo+YzmEF6KC0J0GNDjAwAARiAC0OM4xHGdOtunh4rBkwfIJFFvSA8BIDLoZxyipEmOGapRh1JA00OGHAIAEByMQAQghEb9E/9VGxo609toRNJDAIgkuhqHKPwbihjyG4AELj2kjAIAEEwEiAD+JbTdJJXRoT2dxIg+dI3o8wAAvOVVjBjy3FAKUHpIGQUAIPgIEAH8S0huhuhDbuhAmdEckiSR9BAAIpLeBiEqPN51RCfRoQhMekgNBQAgVAgQAfyfoGWI/ueGzoI/ILHd/TuFiPHqR+j5AEC40HOGKKobiqif6FAEID2kgAIAEFoEiAD+Q6AzxEBEh/aCFiO277TLq3Wo6PkAQNjRbYYo/jNG1FV0KEgPAQCIRKzCDMBRIBZllqsqBzo9VAR6seb2nXZ5tT89HwAIU3pblNnBsonPRXZ6yCLLAADoBCMQAVRDw3EWQQsNnQVoNGKb+7ZZLF7sT88HAKA5pbzqZEkxqX2nXRr2LyigAADoBwEigOr5OV0rhLmhA217Vvfc+0+bzYv96fwAQLjT20TmaiusHmLE9p12CWHQ5FBUTwAA9IYAEUD1fLsZon5yQwea9Ky8nZZF/wcAIoMeMkQ1FXbw5AGhyhC9vbmHG1RPAAB0iAARgEteZYi/79gpNjY20E3ykz8xIukhAESzEGaIXl2cC/5QRFkfKys1OBSlEwAA3SJABOCOxwxxXKfOVqv1+vXrwWyVn3zoXJEeAgACsciYez6P6w9ajKjhkimUTgAA9IwAEYAvdDtVWT31nSuvekf0fwAg4gVhEKImdTbQM5pJDwEAiB4EiAA8sB+EGAG5oQMZIwrXSSLpIQBAEYSJzNqW2sANRdQqPaR0AgAQFggQAXi2bOJzK9/4WMnaIlK1XSzSQwCAgwBNZA7oJTrNY0TSQwAAog0BIgCX7DszkZ0eKuy7WKSHAAA3tBqEGLTR/VrNaCY9BAAgChEgAnDkqicT8YMQFYMnD7AVz8vdoXZ/ukAAEFW0msgc/BuD+D8UkfQQAIDoRIAIQAh1fRg5ciEaMkRb8TwhhOwTepynRhcIAKKQnxliaO8p7HOMqEl6SN0EACAcGUPdAAChNK5TZ/mfyv0DvZ6jHsj0UNG2eys3PUN6QQAQtXwbe+hV2Q0ob68Ikh4CABDNGIEIRB0/+y2RPQLRIT1UKL1E+wGJB/ZmxMcHo1UAAD1TMwhRJ6GhA/VDEUkPAQCIcgSIQOTTvNMSqROZXaWH9tp2b1VVVbX/n4f27+kWExOERgEA9EvNRGZ9Rof2PMaIpIcAAIAAEYhAge6rROTNENWkh4qmv5zV9Jfi8/f+Hrj2AADCgpIhOht1b4caNWoEuT0+c3WXEtJDAAAgCBCBCBCSoQ0RliF6lR7aaowW5iIhxG9ffiw5OVn4t5wlACAyKIMQZV0uLCwMdYu85jwUkfQQAABIBIhA2ND/HKgw5VV6aEj6vbBYHDb6vJwlACACKIMQ6/4jPwIurSlFjfQQAAAoCBABfQmjlDAyBiF6nR66RowIANFpXKfOolPnCHv/H/SHH3N3+HUEokMAACIJASIQDGEUC3pFZoj//epvQt0QH2mYHiqURDXCepIAAGfO9T0CLq2Jf9dHOSPb1R0e3SM9BAAgwhAgAtpQuhAlJSVlZWVCiFq1asXFxYW0UcEwePIAq9Ua6lb4IhDpoT0GJAJApKr2uqCyCEm4Z4gO9dGHGJH0EACAyEOACGjj/T1fyS/MZrPFYhFCxMfHx8TEhKo9wRzzuOrNT/r+Psy6CoFODxUMSASASOK+vLpayDiMuKqP6mNE0kMAACISASIQmZRA01s+JI+DXn/yg1dWPTv1v307Y/AFLT20R5IIAOHL2+K48o2Pw+7SmlBRH5XlYlzZv6dbYqKmbQIAAPpAgAjgP6hPHu17U0+81DcwzdFeSNJDeySJABAufLiopgxC/OTtjYNefzIAjQoxN0MR9+/pZjAEvUEAACAoCBAB+EiJGquqqsrLy0/uPftfD7Z22Edvq8eEPD20R5IIAPrkZ/EK04nMXpVI5xhx/55u2rcJAADoBgEiAG3c061F7o4jskehUDOeUW8hoxTo9NAeSSIAhFwgitGa6Z+Hy/09vEoPFUqMeHhfTyFKtW4UAADQEQJEAJpxSA9VClrIqL53FMz00B5JIgAEWYAuYg2ePGDxxBWBOHIg+JYeKv7r14sO76NsAQAQ4QgQAWjJeRCiJvwPGfWfHtpTkkSJPBEANBScke9Pjv/15+/9feUbHzu8peuNn+mhLJqDJw+4du3aJ29v1KhRAABAdwgQAWhJrs8YiAzRIzchY8fanwshOv3iDo8H0UN66My+80mYCADeCu29MvScIWqSHiqeeKmv0WjcNO+f/jUKAADoEQEiAI2FJD10Q6aHQog9P1x0v+c3RY+P6xT4BvmHwYkA4JFO7q779CuPr39nU6hb4ZK26aFC1inKEwAAEYYAEYD2QjUI0ZmSHnr0TdHjQt1c6dH3dfSrTZqqdlQL3TYA0UMnWaErckVmHQ5CDFB6qCBGBAAgwhAgIsRGjBixdOlSIcTEiRNnzJgR6uZAGyGcyGzP2/RQpXnf7CkvLxdCxMTExMfHu9othH1aUkUAkUfnQaFHusoQA50eKogRAQCIGASICKVNmzbJ9HDGjBkTJ06UGy9evHjhwoWYmJhOnXQ/mxSuRWp6qJ6awYz2At03dt9xpXcH6EfUXloL94jQFTkIMdSt+D9BSw8VxIgAAEQAAkSEzLVr10aMGGE0Gv/85z9nZWUp25ctWzZlypTatWtfv349hM2D/0I4CDHk6aEPvA0cPfKqK+5xXExRUZHJZEpKSqIHCARUhF1ak29EZrP5xo0bQojExMSaNWuGulEho4dBiMFPDxXEiAAAhDUCRIRMVlbW1atXV6xYMXDgwFC3BQERqonM4ZgeBoK2iWR5ebnRaIyLixO/auRqn5Kin8XbGp4TiDqRd2lNvhFZrdaKigohhMlkiouL8/YgETAyUSeDEEOYHiqIEQEACFMEiAgNm832zjvvzJs3r0GDBqFuCwKI9BAA1OPSWrW0vRwSqjgy5Kup6CE9VBAjAgAQdggQw0xxcXFiYmJMTEzgTlFVVXXlypVA53oGg6Fx48YBPYWDyspKs9lco0YNg8EQzPMimIMQSQ8BhC8urQWHV3FkINLGkGSIukoPFcSIAACEEWOoGwAPhg8f3qJFCyHE6tWrW7RokZycbDKZbr311u7duy9ZssRqtVb7Uzt37szKynrwwQcbNmyYnJzcokWLvn37rl+/3nn/2NhYg8GwadMmIcSGDRvat2+fkJCwZs0a+30KCgrGjRvXsmXLpKSkpKSk9PT0UaNGHTlyxH6fsrKytLQ0g8HQrFmzsrIyh7N8+umnBoPBYDDMm/d/n19zcnLkxn379sktWVlZBoNhypQpQoiioiL56KxZs7xtjJScnGwwGDZs2FBSUjJy5Mh69eolJSUlJCS0bNlyyJAhp0+f9vOlg0pyInMQTkR6CESn4uLiQL9FV1VV/fTTTwE9hfj3pbVgpoeVlZUlJSU2my1oZww77+/5yuN/6o/G2MNqDZ48IOS3hgQAAB4RIIaHadOmDRo06Pjx4/Lbq1ev7ty5MzMzs0uXLteuXbPf02KxDB48uHv37osWLdqxY8ePP/5YXFx8/PjxL7/88sknn+zVq1dlZWW1p1i8eHH//v0PHDjgsMPGjRvbtm07d+7cY8eOlZSUlJSUnDx5cuHChW3btrVfGjIxMXHp0qUGg+HMmTMyAVT8/PPPv//974UQ3bp1GzNmjD+vg8rG2CsrK8vIyMjOzpa3bzebzceOHVuxYkXLli23bdtmv6fHl86flke5IIxAJD0EosdHH33EpTVvGyNxaS0QXAWLi3MPLNj3rcPOwR9zp/P0UEGMCACAzjGFOQycP3/+tddeE0Lce++9jz32WNOmTffv379u3br8/Py9e/cOGDDAPgibM2fOqlWrhBBNmzYdMWKE7LqcPn36o48+OnHixI4dO6ZPnz558mSHU3z33XdTp06tX7/+2LFjmzVr1qVLF7l948aNjz76qBDCZDINHjz4gQceMJlMe/bsWb58eUVFxSuvvHLHHXcMGjRI7tytW7dRo0bNnz9/9uzZTz/9dLt27eT28ePHFxQU1KxZ88MPP3Q/fXj+/Pl//vOf33zzzTfffDMlJUVmo0aj0YfGKCZNmnT27NnmzZuPGzfu3nvvLSws/PDDDz/++OPKyspBgwZduHDBZDKpfOm8+q3BQUAnMpMeAlFo2rRpr776qvKtvLS2c+fOpUuXbtq06ZZbblEeslgsw4YNk+/wiuPHj8tLRN27d9+8eXNsbKzzKRYvXjxy5EjnAXobN24cNmzY1atXlS0nT548efLk4sWL33rrrZdffllulJfWunfvLi+t2ad+2l5aU9MYe/LSmpJRyktrx44d+5//+Z+///3vPXr0UPb0+NIxetEj5yGKufFFQojtM5csm/hcoM8eLumhQskQmdcMAIDeECCGATlsYdiwYdnZ2bKHM2jQoIkTJ/bv3/+rr77avn371q1blfFxCxYsEEI0a9bs22+/rV27tnKQMWPGtG/f/tSpU9u2bXMOEKdNm9a5c+fPP/+8Tp06ykar1TphwgQhRJ06dT777LOMjAy5fdiwYc8++2y/fv0uX778+uuvP/XUU8qKijNnzty4ceP58+eHDx/+zTffmEymXbt2LVmyRD505513un+mMiuU/2swGOxv9ehDY6SzZ8927dp106ZNtWrVklt69+79u9/9buXKlZcuXTp69GibNm1UvnTuGw/3ArciM+khEIW4tOZDYxQaXloL8u2MI4NyZw/305/9v/1i2KWH9rg9IgAAekOAGB5SU1OV9FCqX7/+mjVrmjVrZjabJ0+eLANEs9lssVh+8YtfjBo1yj4CE0IkJSX17Nnz1KlTZ8+edT6+xWKZO3eufXoohFi9evXRo0eFEJMmTVICO+n+++9/4403srKy8vLyli1bNnLkSOUsS5Ysefjhhw8cOPDee++NGzcuMzPTZrNlZGSMHj3an1fAh8ZIRqNx/vz5SnooZWZmrly5Ughx+vRpGSCqeen8aT9EYCYykx4C0YlLa741RtLw0lpRUZH79sMN99fV3MSLarLFsE4PFQxIBABAP7gHYnh4/vnnnWdX3XHHHYMHDxZCfP311+Xl5UKIuLi4CxcuXLx48YUXXnA+yJUrV1wd//7772/btq3DxpycHCFEcnKyQyQnDRs2TE4Qk7spHnrooeHDhwshpkyZkpmZeeLEiZo1ay5btszPtY99a4wQomPHjkpHSKGMmFDmXvn80sEr2q6mQnoIRDNXl9ZkWKYEgh6vDwkhNLy0JoSQV7PszyLjQnlpraKiImiX1pwbI7m6tCa/UO6EqOalkx8/4C0/r6h5XNElMtJDe/IOidwkEQCAECJADA8dOnSodnvnzp2FEDabLS8vz/lRm81WUFCQk5OzdOnSp59+ev369a6OX+0ICNmFaN68ec2aNZ0fjY+Pb9mypRDizJkzDg/Nnj379ttvLysrW7FihRDi7bff9jjCwiOfG5Oenu68vzL5yxX1Lx28ErQVme2RHgIRiUtrXFoLazJD1Lwmvr/nq6+Pj9/zw0WH/9QfQYfpoT2SRAAAQoUpzOGhadOm1W5XgrkzZ87IJSmFEMeOHVu4cOHu3btPnDjhvOxjtVJTU503yszO1amFEE2aNNm9e7dzZpeSkjJ//vz+/fsLITp06JCVlaWmDe753JjbbrtN/Vl8eOkQKuqHHwKISG4urS1dulReWlMqo8Jms126dCkvL+/48eNbtmwJxKW1aovR7Nmz//a3vxUUFAT50lq1jfH50prKlw5e0fYGwa6Ko5sMsdMv7lC+1nl6aM8+Q2SCMwAAQUCAGN6UwRdK2vXuu+9OnDjRarXKR9u1a5eWlpaent65c+cvvvhi4cKF1R4nISHBeaPHpRXlTdarnb506NAh+cXRo0fPnz/fpEkTNU/HDZ8bo358h28vHbylyWoqTF4GwKU1Lq2FO81H5ft2aU3JFr8pelwIxxsv+r+WSxAQJgIAEAQEiOEhLy+vUaNGztuVGxWlpaUJIbZv3/7SSy8JIVq1ajV9+vSHH37YPhn8xz/+4dVJ09LSLl68eO7cOTetUk5t79ChQ1OnThVCGI3GkpKSzMzMzZs3e3VqDRujkrYvHdwjPQQQOFxa89gYLq3ph8wQNRmE6OfAfFcV08+1XIKPMBEAgAAhQAwP+/bt69q1q/P2b775Rn7RrFkzIYScGBUfH79161bn8QUWi8WrkzZr1mzbtm0nTpwoLS2tUaOGw6OVlZXy3u3Nmzd32D506NDKysoOHToMHTp09OjRW7ZsWb58+ZAhQ7w6uyaNUU/blw4e+dxZIj0EIHFpjUtrUAQoPXTPIVssLS0VQhgMhsTERKGPeNH5VolEigAA+IwAMTz86U9/Gj16tBxKoCgoKJBLK7Zp0yYpKUkIkZ+fL4Ro0qSJcwRms9mUtFGlBx54YPHixTdv3szOzna+gfpHH310+fJlIUSnTp3st0+fPv3AgQMmk+mDDz645557/vKXv+Tk5Lz44ouPPPJIgwYNvGqA/41RT9uXDh75NpGZ9BCAgktrXFqLDP4PQgxJeuiRm6GLInTxYrWrr5AqAgCgBqswh4fz58+PGjXK/sP61atXn3nmGTkv6a233pIb5SiDvLy8S5cu2f94RUXF888/L/tUciKSGoMGDbr77ruFEFOnTnVYw/Hbb7997bXXhBCNGzfOzMxUtufm5k6bNk0IMWHChDZt2hgMhuzs7NjY2MLCwrFjx3r1lB16Jj40xitqXjpoi/QQgD/+9Kc/OWdYQbi0JoSQV7OcH1VzaS0rK6tLly5CiBdffPGnn37y6uyaNEY9Lq0FmW/3Q9RneujR+3u+UvNfcBqjrOzs8F9wzg4AQLhgBGJ4SExMXLJkyaFDhx5//PGmTZvu379/zZo1Fy5cEEJ07dq1X79+cre+ffsuWLDAbDb37Nnz1Vdfbd26dWFh4eHDh+fOnXv69OmkpKTi4uJLly6tX7/+oYceqlWrlvuTmkymWbNmPfbYY4WFhT169Bg6dGjnzp2NRuOePXuWLVsms8sZM2YoE5qUERbNmzd/9dVX5cZWrVpNmDBh6tSp69atGzhwoNJU9+cVQhQXF69bt65169YpKSmNGjXytjHeUvPSyT1tVVW+nQLO1A+4ID0E4EBeWluwYIEyPN/VpbUtW7bI60MNGzZUfryiomL8+PE+XFqbNWvW8ePHp06d2rFjRxkFSiovrQkhsrOz27VrJy+trV27Vv1Tdr605m1jvKLmpfN4H0aooflqKirpv2L6kCFqOLbRfYbIuEUAQLQhQAwPn3322TPPPLN37969e/fab3/iiSfkUAupT58+sjd17NixgQMHKtsNBsO4ceN69er16KOPCiGefPLJXr16bdmyxeN5+/Xr9/777//xj380m82LFy9evHix8lBKSkp2dvZvf/tbZcu0adMOHjxoMBiWLFliH+RNmjRp7dq1p06dGjVqVEZGRkpKivuTtm/fXn4hDz5z5swJEyZ42xhvqXzphBBFV674fBY4UDmRG9AoVgAAIABJREFUmfQQgDMurenh0prZbPbt4HDg20Rmf4YfRmrFDNq4RfGrRmaz2Wq1yns+ChfZJTkjACBiECCGh65dux49enTmzJkbN27Mz89PTExs1arV0KFDhw8f7rDn/Pnz+/TpM3fu3OPHj//0008NGjTo0aPH2LFj27VrJ4QYN27cihUrysrKGjdurPLUY8eO7d2799y5c7du3Xrx4kWbzdaoUaNevXpNmDDB/iC5ubnTp08XQjz33HPdunWzP0JCQkJ2dnaPHj3y8/MnTJiwaNEi92fs3bv3jBkzFi1adOnSpXr16t16663eNsY3Hl+6999/XwgRY+JfjZZIDwH4hktr3jbGW+ovrSEkSA/1pvrs8leNrMtNgqvPAIDwRxQSNm677bY5c+bMmTPH4559+/bt27dvtQ85H6GystLjAdPS0ubNm+d+n7Zt27oZhvDggw86z3Lq0qWLq6lPEydOnDhxos+NkW7evOnqoUaNGlV7avcvnQwQa91yi5qzQz03Ay5IDwG4wqU1rxrjG48v3fz581lNRSteDUIkPQQAAEFGgAggxFxNZCY9BOAel9bUN0bS/NLagQMHdu3apebUUM9jhkh6CAAAgo9VmB398MMPP/zwQ6hbAUQ70kMAQLRh7CEAANCtcAoQt23b9tRTT/3444/VPlpeXv7BBx+MGDHiqaeeevnll9euXeu8qGJZWdnf//73RYsWffLJJxcvXnQ+yOXLl8eOHfvdd99p33oArjksQEl6CACITjJDdLUoM+khAAAIlXCawrxlyxa5pKCzq1evvvXW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/jzk6aFEf0mH/vd//7dFixZCiNWrV7do0SI5OdlkMt16663du3dfsmSJqzBx586dWVlZDz74YMOGDZOTk1u0aNG3b9/169c77x8bG2swGDZt2iSE2LBhQ/v27RMSEtasWWO/T0FBwbhx41q2bJmUlJSUlJSenj5q1KgjR/7jr6WsrCwtLc1gMDRr1qysrMzhLJ9++qlcannevHnKxpycHLlx3759cktWVpbBYJgyZYoQoqioSD46a9YsbxsjJScnGwyGDRs2lJSUjBw5sl69eklJSQkJCS1bthwyZMjp06f9fOkABFpI0kMupwEAgEAjQATgNW97RwG9kROrqejWtGnTBg0adPz4cfnt1atXd+7cmZmZ2aVLl2vXrtnvabFYBg8e3L1790WLFu3YsePHH38sLi4+fvz4l19++eSTT/bq1auysrLaUyxevLh///4HDhxw2GHjxo1t27adO3fusWPHSkpKSkpKTp48uXDhwrZt2yrrJgshEhMTly5dajAYzpw5IxNAxc8///z73/9eCNGtW7cxY8b48zqobIy9srKyjIyM7OzsGzduCCHMZvOxY8dWrFjRsmXLbdu22e/p8aWrqqryp/EA1PP20pq2mMgMAAACikVUAHhHV+mhxMgLHTp//vxrr70mhLj33nsfe+yxpk2b7t+/f926dfn5+Xv37h0wYIB9EDZnzpxVq1YJIZo2bTpixAg5KvD06dMfffTRiRMnduzYMX369MmTJzuc4rvvvps6dWr9+vXHjh3brFmzLl26yO0bN2589NFHhRAmk2nw4MEPPPCAyWTas2fP8uXLKyoqXnnllTvuuGPQoEFy527duo0aNWr+/PmzZ89++umn27VrJ7ePHz++oKCgZs2aH374ocFgcPNM58+f/+c///nNN9988803U1JSZDZqNBp9aIxi0qRJZ8+ebd68+bhx4+69997CwsIPP/zw448/rqysHDRo0IULF0wmk8qXTnlGAAJKk+iQhVMAAIBuESAC8IIO00Mpd8cRYkRdkTOChw0blp2dHRsbK4QYNGjQxIkT+/fv/9VXX23fvn3r1q29evWSOy9YsEAI0axZs2+//bZ27drKQcaMGdO+fftTp05t27bNOUCcNm1a586dP//88zp16igbrVbrhAkThBB16tT57LPPMjIy5PZhw4Y9++yz/fr1u3z58uuvv/7UU0/F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" alt="Tonicidade de palavra-alvo e pseudopalavra" width="864" />
<p class="caption">
Figura 6.1: Tonicidade de palavra-alvo e pseudopalavra
</p>
</div>
<p>No geral, podemos ver que há um “confundimento” entre oxítonas e paroxítonas em todos os grupos de classificação, ou seja, muitas pseudopalavras cuja palavra de referência é paroxítona foram classificadas pelos falantes como oxítonas, e vice-versa.</p>
<p>Consegue-se perceber que nos grupos de baixa frequência, a quantidade de pseudopalavras que foram classificadas como oxítona e cuja tonicidade da palavra-alvo era proparoxítona é consideravelmente maior do que nos grupos de alta frequência. Supomos que o fato de a palavra ser de baixa frequência faz com que seja mais dificil ter uma referência na mesma estrutura. Além disso, para os grupos dissimilares a quantidade de pseudopalavras acentuadas como proparoxítonas é ainda menor do que nos grupos similares, o que pode concorda com a hipótese de que quando o falante perde a referência de uma palavra real, ele acaba acentuando-a de acordo com um padrão, que seria o paroxítono. Cada um dos gráficos de fluxo pode ser visto detalhadamente no Apêndice B-Gráficos.</p>
<p>Na Tabela <a href="#tab:estrut-tonicidade-producao">6.3</a>, vemos que 85% das pseudopalavras
cuja estrutura era CV-CV-CV foram classificadas como paroxítonas, e 79% das pseudopalavras cuja estrutura era CV-CV-CVC foram classificadas como oxítonas, o que corrobora com a afirmação da literatura de que uma palavra típica da língua portuguesa é formada por sílabas CV e com a tonicidade recaindo na penúltima sílaba (paroxítona), uma vez que o padrão silábico canônico do português é CV e o padrão tônico é o paroxítono. Logo, parece existir forte influência da estrutura na atribuição da tonicidade em palavras do português brasileiro.</p>
<table style="width:100%;">
<caption>
<span id="tab:estrut-tonicidade-producao">Tabela 6.3: </span>Frequência da Tonicidade de produção por Estrutura das palavras.
</caption>
<thead>
<tr>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="2">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Estrutura da palavra
</div>
</th>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
</tr>
<tr>
<th style="text-align:left;">
Tonicidade produção
</th>
<th style="text-align:left;">
CV-CV-CV
</th>
<th style="text-align:left;">
CV-CV-CVC
</th>
<th style="text-align:left;">
Total
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
oxítona
</td>
<td style="text-align:left;">
748 (10.3%)
</td>
<td style="text-align:left;">
4156 (79%)
</td>
<td style="text-align:left;">
4904 (39%)
</td>
</tr>
<tr>
<td style="text-align:left;">
paroxítona
</td>
<td style="text-align:left;">
6200 (85.3%)
</td>
<td style="text-align:left;">
963 (18%)
</td>
<td style="text-align:left;">
7163 (57%)
</td>
</tr>
<tr>
<td style="text-align:left;">
proparoxítona
</td>
<td style="text-align:left;">
323 (4.4%)
</td>
<td style="text-align:left;">
121 (2%)
</td>
<td style="text-align:left;">
444 (4%)
</td>
</tr>
<tr>
<td style="text-align:left;">
Total
</td>
<td style="text-align:left;">
7271 (100.0%)
</td>
<td style="text-align:left;">
5240 (100%)
</td>
<td style="text-align:left;">
12511 (100%)
</td>
</tr>
</tbody>
</table>
<p>Por fim, explorando os dados no âmbito de validação, vemos, na Tabela <a href="#tab:validacao-producao">6.4</a>, que aproximadamente 73% das pseudopalavras foram validadas de acordo com o processo descrito anteriormente no capítulo <a href="#descricao-estudo">4</a> (Descrição).</p>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<caption>
<span id="tab:validacao-producao">Tabela 6.4: </span>Frequência da Tonicidade de produção, por nível da variável Validação.
</caption>
<thead>
<tr>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="2">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Validação
</div>
</th>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
</tr>
<tr>
<th style="text-align:left;">
Tonicidade produção
</th>
<th style="text-align:left;">
Não Validada
</th>
<th style="text-align:left;">
Quase Validada
</th>
<th style="text-align:left;">
Validada
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
oxítona
</td>
<td style="text-align:left;">
335 (15.8%)
</td>
<td style="text-align:left;">
529 (39.2%)
</td>
<td style="text-align:left;">
4040 (44.7%)
</td>
</tr>
<tr>
<td style="text-align:left;">
paroxítona
</td>
<td style="text-align:left;">
1727 (81.5%)
</td>
<td style="text-align:left;">
771 (57.2%)
</td>
<td style="text-align:left;">
4665 (51.6%)
</td>
</tr>
<tr>
<td style="text-align:left;">
proparoxítona
</td>
<td style="text-align:left;">
56 (2.6%)
</td>
<td style="text-align:left;">
48 (3.6%)
</td>
<td style="text-align:left;">
340 (3.8%)
</td>
</tr>
<tr>
<td style="text-align:left;">
Total
</td>
<td style="text-align:left;">
2118 (100.0%)
</td>
<td style="text-align:left;">
1348 (100.0%)
</td>
<td style="text-align:left;">
9045 (100.0%)
</td>
</tr>
</tbody>
</table>
<p>Cerca de 81% das pseudolavras cuja similaridade/dissimilaridade não foi validada
foram classificadas como paroxítonas. Dentre as não validadas, aproximadamente 85%
das pseudopalavras pertencem ao grupo das similares (<a href="#fig:validacao-grupo"><strong>??</strong></a>.
Ou seja, percebe-se que nos grupos 1 (pseudopalavras similares de alta frequência)
e 3 (pseudopalavras similares de baixa frequência) a porcentagem de palavras não
validadas é superior aos demais grupos, o que parece indicar que a validação de
palavras similares é mais complexa e difícil, uma vez que pseudopalavras classificadas
como similares a palavra-alvo podem ser associadas a mais de uma palavra real pelos falantes.</p>
<p><img src="data:image/png;base64,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5JAef0yvvKiysrqPAQAAAMAlgASi1bx58ywHJS9fvrz8vmCz2fzee+8lJiZKmjZtmm1zcW1GXejw4cO7du0KCQmZNWtW+es9e/b08fEpKSlZtmxZ+euff/55bm6up6dnnz593LtfAGhk336t48cUf1ppjsvI1lh+vtaskqQZsxszDPfmN5t17Kgi1+rLz7R2tQ79oorfGzm2fau2b9PeGHXsVFW3/gPVtbuSk7R9W82CBwAAAABJHKJiExgYeNddd7388stFRUV/+tOfpk+f3rt374KCgm3bth05ckRSx44db7755joZdaH3339f0q233urp6Vn+up+f38033/zee+99+eWXSUlJ4eHhllOYo6KiJC1cuNB2EjQANCX7f9RP++p4ztXfqbBA/forrEdjhuHG/Bnp+mKFTp+yX4mSOnTU/IUK7ep0VH6+tm2VpIlTVO05XTNm6b23tClSg4eoXZALoQMAAACAHQlEu2nTpuXm5n744YfFxcWrVq0q/1BoaOjjjz/eqlWruhpVXnR09NGjR/v37z9u3LgLH503b96pU6c2bdq0c+fOnTt32q6Hh4dff/31Nbg9ALhIZGXp26/reM5jsfppnwyGGiw/rI8w3Jg/IV7vvCGjsfL11LN681XdsFiDhzgeuHmDiovUqrXGTaj+WXr1Vq8+ijumb77SHXdV3x8A4J69MfryM4X10N33NXYoDcJo1IZ1Mps1cLB69HTa7cghfbhEIZ11/2/lwR44AGiSSCBWcM011wwbNmzNmjX79+8/d+6cr69vSEhIRETEzJkzfX1963aUhclkWrp0qaQ77rjDYQeDwfDb3/527NixkZGRx48fLysr692799SpUy3lFwGgiTGb9fmnKiqs42nXrZakvv0V0rkxw6jp/EajPvvUmj0cNlzjw9W+vTIytOcH7dqhsjJ9+6XCeqhly8oDz2Xoh12SNH2mvL1dCmnSFMUd0/FYHY9V7741vSEAaMKee0a5OS71fPrv8vFx/4mqLqbRMGGkp+nAz4o9ouxs5eXK00stW6prNw0arIGDZTA4HWg263isTp5Qbq4CWqh7d/XtL6/qPi1aimn4+WnytKq6WYppxJ/W9m2KmOTGbQEAGt0lkUB8+umnXe/co0eP+++/v6ZP4d4oSZ6enm+//Xa13UaNGjVq1Cg35geAi8vWLdWc+OGGkyeUnCRJ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dOrUaenSpdOnTz/55JOrX3zOnDkhhOoHJ06cWFlZee211zZq1Ki27xAAAAAAakSAGEII/fv379+//146xOPxDz/8MIQQi8Xy8vJSx5MBYnZ29ty5c5999tnNmzenTsVisX79+g0fPjw3N7f6pYYOHbp06dKZM2fGYrGhQ4cef/zxH3/88fjx4z/77LP69esPHDgw2a2goGDOnDnNmzcfMmTIQXynAAAAAHBABIj75b/+6782bNgQQujdu3f1QHDdunUhhMrKyscee2yXIYlEYvbs2R988ME///M/d+/ePXX8nHPOueyyy1566aUZM2bMmDEjdTwzM/P2229v0aJF8uVf/vKXRCJx3XXXJZdGHlzxeHzTpk0H/bLAHpWUlKS7BDiymURQSyYR1FIaJ1HDhg1zcnLSdXeAFAHivr388ssTJ04MIWRlZV177bWp44lEoqioKNnOzc39zne+c+655zZq1OiLL75YsWLFpEmTSkpKNm3a9Jvf/OY///M/69Wrlxo4fPjwbt26jR8/Pjk8IyOjS5cuI0aMOOmkk5Id3n333cWLF5900kl7XxdZY4lEIpFIHIorA7sz3aCWTCKoJZMIaskkAhAg7k1RUdGf/vSnRYsWhRBisdidd97Zvn371NnS0tKKiooQQqtWrX7xi180b948ebxdu3bt2rXr3bv3/fffv2LFipKSkieeeOKWW26pfuU+ffr06dOnrKxs/fr1bdu2rf5vSolEYvz48SGEH/zgB8mdVQAAAAAgXQSIe7Z9+/bnn39+ypQpyW2Rc3Nzb7/99t69e1fv06RJk0mTJoUQcnJydn/QuEGDBrfeeuuPfvSjRCIxffr0G264oW7durv0yc3N3eUbEkMIM2bMWLNmTc+ePU8//fTUwQULFrz++uurVq2KxWKdOnXq37//eeedV+N3F4vFRJNw2JhuUEsmEdSSSQS1ZBIBCBD3YP78+Y899ljySw9DCL169br11lv3uKXy7vFfdR06dDjllFOWLl26c+fOlStXnnrqqfu8dUVFxaRJk2Kx2Pe///3kkUQiMXbs2JkzZ6b6vPPOO++8807fvn3vvPPOzMzMA3prSZmZmc2aNavBQKAGTDeoJZMIaskkgloyiQAEiP9g69atjz766Lx585IvO3bseOONN/bo0aPGF2zbtu3SpUtDCKWlpfvT/4UXXigtLR0wYEDq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LiNGjDjppJOSHd59993FixefdNJJ/fv3PxSVx+Px6htDA4dUSUlJukuAI5tJBLVkEkEtpXESNWzYMPVLJUAaCRBrrqKiItnIysqK6pM6VT1ADCH06dOnT58+ZWVl69evb9u2bfUfCYlEYvz48SGEH/zgB8mdVQ66RCKRSCQOxZWB3ZluUEsmEdSSSQS1ZBIBCBBrLvVw8c6dO6P6pHZV3mPImJubm5ubu8vBGTNmrFmzpmfPnqeffnrq4IIFC15//fVVq1bFYrFOnTr179//vPPOq+0bSJ/vP3ljukuAI5tJBLVkEkFtmEEAcKwRINZc6snl1FLE3aVO1atXb3+uWVFRMWnSpFgs9v3vfz95JJFIjB07dubMmak+77zzzjvvvNO3b98777wzMzOzBpXHYrFDtLaRr6Zd/snUnz4cqOqTyAyCmknNI5MIasBPIgDSS4BYc8cdd1yysXHjxqg+qa8abNiw4f5c84UXXigtLR0wYED79u2TR1588cVkenjuueeef/75sVjs7bfffvvtt+fOndu+ffurr766BpVnZmY2a9asBgM5Qm3evDm1GLZJkyY1y53hWLZp06bUYvOmTZv6zQ0O1MaNG+PxeLLtLyFQAyUlJckMMRaLmUQAHH4CxJrLy8tLNtavX7/HDolEori4OITQtGnT+vXr7/OCmzdvnjJlSnZ29ne/+93kkW3btj355JMhhG9961upNYkXXHDBpEmTJk+e/MwzzwwePHj3h6ABAAAA4GDJSHcBR7DUIsFVq1btscPatWuTe6ekeu7d008/vW3btssvv7x58+bJIwUFBZWVldnZ2dddd131ntdee239+vV37NiRn59f0/IBAAAAYN8EiDXXokWLtm3bhhCWL19eXl6+e4d333032TjzzDP3ebXCwsLp06c3atToyiuvTB1ct25dCKFVq1Z16vzDWtHMzMzkrdeuXVuLdwAAAAAA+yBArJXkVsiVlZXTp0/f5VQ8Hk8ezMzM7N279z4vNWHChHg8/u1vf7v6w87Jp6SLiop22ei5qqrq888/DyG0bt261m8CAAAAACIJEGtlyJAhye2Vn3nmmepPEycSiccff7ywsDCEcNFFF6UeSY6ybNmyv/3tb61btx48eHD14x06dMjOzq6srJw0aVL1488991xZWVlmZmbnzp0P2psBAAAAgN3YRKVWcnNzhw8fPnbs2O3bt99zzz0DBw7s1KnT1q1b33zzzeXLl4cQWrZs+b3vfW+f1xk3blwI4YYbbthle9y6det+73vfe/zxx59//vl169b17ds3uQvz3LlzQwjDhg1L7QQNAAAAAIeCALG2LrroorKysieeeKKiomLq1KnVT7Vt23bMmDGNGjXa+xXeeuutFStWnHzyyX369Nn97JAhQz755JOZM2fOnz9//vz5qeN9+/a9+uqrD8pbAAAAAIAoAsSDYOjQoaeffvq0adMWL15cWlqak5PTunXrCy64YNCgQTk5OXsfG4/HJ0yYEEK48cYb99ghFovdcccdvXv3fu211/Lz86uqqjp16jRgwIDk1y8CAAAAwCEVSyQS6a4BOLQ2b968Y8eOZLtJkya7PCkP7NOmTZtSm1k1a9YsFoultx444mzcuDEejyfb+/xuaGB3JSUlyV/cYrFYs2bN0l0OAMccm6gAAAAAAJEEiAAAAABAJAEiAAAAABBJgAgAAAAARBIgAgAAAACRBIgAAAAAQCQBIgAAAAAQSYAIAAAAAEQSIAIAAAAAkQSIAAAAAEAkASIAAAAAEEmACAAAAABEEiACAAAAAJEEiAAAAABAJAEiAAAAABBJgAgAAAAARBIgAgAAAACRBIgAAAAAQCQBIgAAAAAQSYAIAAAAAEQSIAIAAAAAkQSIAAAAAEAkASIAAAAAEEmACAAAAABEEiACAAAAAJEEiAAAAABAJAEiAAAAABBJgAgAAAAARBIgAgAAAACRBIgAAAAAQCQBIgAAAAAQSYAIAAAAAEQSIAIAAAAAkQSIAAAAAECkWCKRSHcNwKEVj8dTM71OnTrpLQaORCYR1NLOnTtTbZMIasAkAiC9BIgAAAAAQCSPMAMAAAAAkQSIAAAAAEAkASIAAAAAEEmACAAAAABEEiACAAAAAJEEiAAAAABAJAEiAAAAABBJgAgAAAAARBIgAgAAAACRBIgAAAAAQCQBIgAAAAAQSYAIAAAAAEQSIAIAAAAAkQSIAAAAAEAkASIAAAAAEEmACMeKjRs3rl+/PpFIpLsQAAAA4EgSkybAsSAej1933XXl5eVPPPFE48aN010OHDEWL148Z86cZcuWbdy4MSMjIy8vLy8v7+KLLz7llFPSXRocAeLx+LRp0/7+97+vXbu2qKioSZMmbdu27dix4xVXXNGgQYN0VwdHpIKCgtGjR+/cufOBBx447bTT0l0OAMeKOukuADgc3nvvvfLy8nRXAUeS8vLysWPHzp8/v/rBFStWrFixYtasWf3797/55ptzc3PTVR589a1cufJ3v/vdmjVrUkeKioqKiooWLVo0bdq0H/zgBxdddFEay4MjUWVl5W9+85udO3emuxAAjjkCRDj6bd++ffz48emuAo4k8Xj8oYceWrx4cQghFov16NGjc+fOlZWVBQUFS5cuDSG88cYbmzdvvu+++2KxWLqLha+iL7/88v7779+yZUsIoXHjxmeffXbz5s1LSko++uijdevWlZWV/e53v2vZsmWPHj3SXSkcScaNG/fZZ5+luwoAjkUCRDjKffjhh0899ZS/a8IBmTFjRjI9rFOnzpgxY84666zUqcWLFz/yyCMbN2587733pk2bdskll6SvTPjqmjBhQjI9HDBgwK233pqdnZ08Ho/Hn3zyyeeffz6RSPzbv/3bH/7wh6ysrLRWCkeM5OrddFcBwDFKgAhHp6lTp77//vurV68uLS1Ndy1w5Jk6dWqyMXr06OrpYQjhtNNOGzVq1P33359IJJ566qlvfOMbGRl2JIN/sHXr1hkzZoQQ2rVrd/vtt2dmZqZOZWZmXn/99UuWLFm1alVxcfGnn37asWPH9FUKR4zNmzePHTs2hJCRkVFVVZXucgA45vidB45O8+fPX7hwofQQaqCwsDD5rW3t27fv06fP7h3OOOOMTp06hRDKyspWr159uOuDr7y1a9cmt+k7//zzq6eHSbFYrGfPnsn2xx9/fLiLgyPT2LFjN23a1KxZs69//evprgWAY5EViHB0uuCCC7p06ZJ6OXfu3C+++CKN9cARpLCwMNno1q1bVJ8OHTqsWrUqhCCmh919+umnyUbLli332CG1AdGmTZsOU01wJHvllVcWLlwYi8XuuOOO999/P93lAHAsEiDC0WnQoEHVXxYUFAgQYT+Vl5cnv68tKvsIIVRWViYbxx133GEqC44cp59++q9+9asQQtu2bffYYcWKFclG69atD19ZcGQqLCwcN25cCOHSSy89/fTTBYgApIUAEQD+Qf/+/fv377+XDvF4/MMPPwwhxGKxvLy8w1UXHDGaN2/evHnzqLOLFy9etGhRCKFRo0a7fMcosIt4PP7www9XVFS0bdv2hhtuSHc5ABy7BIgAcGD+67/+a8OGDSGE3r17p57EBPZi2bJlW7duLSkpWbZs2ezZs+PxeFZW1l133ZWTk5Pu0uAr7cknn1y9enVmZuadd96Z2s0cAA4/ASIAHICXX3554sSJIYSsrKxrr7023eXAkeFnP/tZeXl56mXnzp1HjRrVrl27NJYEX30fffTRlClTQgjf/va3k5t3AUC62IUZAPZLUVHRz372sz/+8Y+JRCIWi915553t27dPd1FwRMrPz3/yySd9OS/sRXl5+W9/+9tEItGlS5errroq3eUAcKyzAhEA9mH79u3PP//8lClTduzYEULIzc29/fbbe/fune664IjxxBNPVFVVlZSUrF279sUXX/zwww/nz5+/fPnyX/7yl23atEl3dfBV9Pvf/764uLhu3bp33nlnRoZlHwCkmQARAPZm/vz5jz32WPJLD0MIvXr1uvXWW5s0aZLequDIkpWVFUJo06ZNmzZtzjnnnN///vevvPLKxo0bJ02a9L//9/9Od3XwlTN79uw333wzhHDTTTfZrByArwIBIgDs2datWx999NF58+YlX3bs2PHGG2/s0aNHequCo8BNN900c+bMysrKt956684778zMzEx3RfAVsnXr1j/84Q8hhLPOOmvQoEHpLgcAQhAgAsAelZeX33333WvWrAkh5Obm3nTTTf3794/FYumuC44AK1euDCFkZWWddNJJe+yQnZ3drl271atXJ59rbtGixeEtEL7Stm3btnXr1hDCokWLhgwZEtXtJz/5SbIxYMCAO+644zAVB8CxSoAIALuqrKx88MEHk+lhz54977jjDs8sw/7713/91/Xr19etW3fy5MlRsXudOv/9t9B4PH4YSwMAoCYEiACwq6eeemrp0qUhhH79+o0aNcrzlXBA8vLy1q9fv3379nXr1uXl5e3eIZFIfPrppyGEjIyMpk2bHvYC4SutXr16e9l2ecmSJclFvn379m3ZsmUIoWPHjoevOACOVQJEAPgHFRUVr732WgihVatWI0eOlB7CgTrttNPef//9EMILL7xw22237d7htdde27ZtWwjhlFNOycnJOdz1wVdb/fr1r7/++qizf/nLX5IB4sUXX3zaaacdxroAOKZlpLsAAPhqmTt37pYtW0II3/jGN7Kzs9NdDhx5BgwYkIwFX3vttZdeeqmqqqr62bfeemvcuHEhhIyMjBtuuCE9JQIAcCCsQASAf7Bq1apkY9asWYsWLdp755EjR7Zq1erQFwVHkuOOO+6WW24ZO3ZsIpF47LHHpk2b1rlz5+OPP37jxo0FBQUFBQXJbsOGDevSpUt6SwUAYH8IEAHgH3zxxRfJRnITlb1LPoYJ7OKiiy7atm3b+PHjd+zYUVhYWFhYWP1sgwYNvvOd71xyySXpKg8AgAMiQASAf1BUVJTuEuBocNlll5199tlvvPHGwoULS0pKysvLW7Ro0bZt2/bt21966aWNGjVKd4EAAOyvWCKRSHcNAAAAAMBXlE1UAAAAAIBIAkQAAAAAIJIAEQAAAACIJEAEAAAAACIJEAEAAACASAJEAAAAACCSABEAAAAAiCRABAAAAAAiCRABAAAAgEgCRAAAAAAgkgARAAAAAIgkQAQAAAAAIgkQAQAAAIBIAkQAAAAAIJIAEQAAAACIVCfdBQBwrCsoKJg6depbb721ZMmS0tLSjRs31q1bt0mTJieeeOK5557bv3//QYMGZWZmprtMDoeqqqoFCxZMnz599uzZ69atKy4uLi8vb9y4cYsWLc4666y+ffsOGzasYcOG6S4TAACOLVYgApA277333pAhQzp37nzHHXc8++yzy5cvX79+/Y4dO8rKyj799NO5c+c+/PDDl1xySfv27f/93/89Ho+nu96j0D333BOLxWKxWO/evdNdS3jppZdOP/30Pn36/PSnP50zZ86qVas2bdq0Y8eO4uLipUuXTpgw4eabb87Ly/s//+f/7NixI+oi06dPj/2PkpKSw1n/oTNhwoTkO8rKyorq89e//nXgwIHt2rVr0KBB586dN23alDrVrl275PD/+I//OCz1Hlbjx4/v0qVLgwYNzjjjjDFjxrz77rvJ488991zyXa9evTq9FQIAHAWsQAQgDaqqqn7605/+4he/2Llz5z47r127dtSoURMnTnz++edPPPHEw1Aeh1lFRcX111//7LPP7rPnl19++cADD0ydOnX69OnHH3/8YajtiHDHHXeMHTs29TI/P/8YCdz/+te//uAHP0i2P/jggw8++OCXv/xlmzZt2rZtm0wS8/LyOnbsmNYaAQCOBgJEANLgtttu+8Mf/lD9yMknn3zZZZd16NChVatWxcXF+fn5K1asePXVVysqKpId3n333b59+86aNatTp07pKJlDZcuWLd/4xjfmzZuXOtKsWbMrr7zy1FNPbdOmzcaNG1euXLly5cp58+YVFxcnO7z//vuDBg168803Pc4cQnjzzTerp4d169bNyclJYz2H07333htCyM7O7tOnz9KlS5P/haxbt27dunXJDvfcc0866wMAOFoIEAE43O6///7q6WGvXr3Gjh179tln796zsLDwoYceeuyxx5Ix4mefffatb31r4cKFx04+ciwYOXJkKj2sX7/+z3/+89tuu233Z3UrKir+/Oc///M///PWrVtDCO+///6//Mu//IGHprMAAB1wSURBVNu//dvhLverZ9q0aclGvXr1/vrXvw4YMCAWi6W3pMPjs88+++ijj0IIEydOvOaaa+Lx+Jw5c1588cUZM2YUFBQ0btx4+PDhI0aMSHeZAABHg1gikUh3DQAcQ6ZMmXLllVemXt5333333Xff3vOO2bNnDx48OLUU8d57733wwQcPbZXHjHvuueehhx4KIfTq1Wv+/PmHv4DJkydfe+21yXbz5s1nz57drVu3vfR/++23+/Xrl3zyPTMz88MPP+zatWv1DtOnTx88eHCyvWHDhmbNmh2awg+rkpKSTz75JNk+88wzdzk7ZMiQl156KYRwzTXXTJ48effhS5YsSX5r5AknnHA0Pfe9ffv2L774IoRwwgknHCOZKQBAuthEBYDDZ8eOHT/+8Y9TL3/+85/ff//9+/zN/8ILL3z66adTGzE/+uijZWVlh7BKDpft27f/0z/9U7KdnZ39yiuv7D09DCH06dPnZz/7WbIdj8d3eRD+aNWsWbMz/8fuZ7dt25ZsNG3adI/DTz311OTYoyk9DCHUrVv3xBNPPPHEE6WHAACHmgARgMPnsccey8/PT7YHDhw4ZsyY/Rw4dOjQyy+/PNnevHnzU089dUjq4/CaOHHi+vXrk+277rrrrLPO2p9Ro0ePTgVhTz75ZFVV1aGqDwAACCEIEAE4bBKJxM9//vNkOysr689//vMBDb/55ptT7ddff32f/bdv3/6v//qv3bt3b9CgwQ9/+MMDutcBicfjkydPvuaaa1q3bt2kSZPu3bvffvvt+/k48KZNm/74xz9ecsklHTt2rF+/fuPGjbt06TJs2LBJkyalHtmupTfffPPWW2/t1q1b48aNGzVq1LVr1xtvvPGNN944oIu88cYbt956a/fu3Zs1a5abm3v66adfeeWVTzzxRPLB2JpJJBK//e1vk+3GjRsnd8PYH1lZWUOGDEm2S0tLlyxZUoO7f/TRR/fdd1+/fv1OOOGE5CffvXv3wYMH33XXXamMey/Kysp+/etfDxs27Mwzz2zcuHGLFi169er13e9+d+LEifsMNGsz9tApKip65JFH+vXr165du5ycnDZt2vTq1eu+++5btmzZPsfW8sNM3v23v/1tuu5+GKYhAMARLwEAh8U777yT+unz7W9/+0CHx+Pxf/qnfxoxYsSIESPGjBmzy9nZs2cnr9y9e/dEIlFaWlr9Yc/kwUQikXritVWrVnu515YtW1JjZ8yYUf3UySefnDw+b968RCIxZ86cDh067PEn7He/+92SkpK93GXcuHHNmzeP+gHdoUOHadOmHeinVF1RUdHQoUOjrn/VVVeVlJTcfffdyZe9evXa40Xy8/MHDhwYdZG2bds+8cQTNSuvevA3fPjwAxo7c+bM6/7HG2+8Uf3Uq6++mrrshg0bdh9bUlJy1VVX7eWh14yMjKFDh3755Zd7vHU8Hv/1r3+9l69W7N69+6xZsw7u2P/7f/9vskOdOnVSB1N/dntU/b23bds2efDRRx/dY2Fjx47Nzc2N+jRuv/32srKyPQ6s5Yf5Vbj7oZ6GAABHBwEiAIfJ/fffn/q1fPbs2Qf34tUDxIqKil32dD5EAeKf//znOnXqREUPIYQzzjijtLR0j7f4yU9+speBqfhj3LhxNftA1q1b16VLl71f/9xzz019BeEeA8QlS5bsz7fmPfTQQzWo8He/+13qCrt8yLWx9wCxtLS0Y8eO+3xHIYRLL700Ho/vfv39WSmZm5u7evXqgzj2kAaII0eO3GdV559//pYtWw76h5n2ux/qaQgAcNTwCDMAh8krr7ySbNStW7dPnz6H7kb/8i//snDhwupH9h7z1cwbb7wxYsSInTt3Nm3a9L777nvrrbeWLVv26quvDh8+PHW7999//7rrrtt97BNPPPHAAw+kXl5zzTVTp07Nz8//+9///vTTT/fr1y95vKqq6uabb67B5shVVVVXXnnlihUrki9zcnJuu+22119/fdmyZXPnzr333nsbN24cQliwYMEf//jHqIts2LBh4MCBxcXFyZennnrqb37zm3nz5q1evXratGlXX311qufdd9/9+9///kCLnDNnTrIRi8V2CXwPnZ/+9KerV69Otlu0aPHggw/Onj07+cm/9tprI0eOTC2Fmzp16u4fzksvvfSLX/wi2T7uuOPuvvvuWbNm5efnL168+Omnnz7nnHOSp8rKyr7zne8cxLF71KlTp4suuuiiiy5K7Z2Sl5d30f/Iysran4s88sgjqSS3YcOGY8aMmT9/fkFBwaxZs+6777769esnT82bN++uu+7aZWwtP8y03/1QT0MAgKNKuhNMAI4VDRo0SP7o6du370G/eGoFYsOGDTMyMkII2dnZ99577/z589etW1dVVZXsdhBXICbv0r1797Vr1+4y/J133qn+mOrzzz9f/WxxcXEq8cnKypoyZcruBTz44IOp4V27dt25c+cBfRqPPvpoanjr1q2XLFmyS4c1a9Z07dq1+t8Hdl+BWD3G+uEPf7ht27ZdOvzpT3/KyclJdmjatOnGjRsPqMjOnTsnx3bq1OmABu7dXlYglpaWpmK1E044Yf369bsPf/fddxs2bJjsc/HFF+9yNhXzNW3adPny5bucjcfjAwYMSN39k08+OVhj97gCMeWiiy5Knh0xYsQeP5OoFYgff/xxKqTLy8tbuXLlLgM//vjjli1bJjvk5OQUFhamTtX+w0zv3Q/DNAQAOJpYgQjA4VBeXl5eXp5sf+1rXzt0N9qyZUtVVVXXrl2XLFny4IMP9urVq3Xr1nv5lrQaq6qqysnJmTp1al5e3i6nzj777FTiE0L49a9/Xf3s448/Xlpammw/+OCDe/yawnvvvTeV3yUXNh5QYQ8//HCyHYvFpk6d2qNHj136nHDCCS+//HJ2dnbURVasWJHa6nrIkCF//OMf69atu0uf4cOH//KXv0y2S0tLU+39tGHDhmSjXbt2BzSwxhYtWpTa9eXhhx/e49PZPXv2TP2JfPrpp9VPVVRUpFa23nzzzbs/IZ6RkVH9Of0PPvjgoIw9dB555JGtW7cm288++2wq0k1p3759arOjioqK6v9V1/LD3OXuzzzzzGG++6GehgAAR5mD/0gXAOzuiy++SLWbNGmy984LFiyovgZwj7p3755anbS73/3ud/v8BsDau+6660488cQ9nrrwwgv79euXfEr3b3/72/Lly1NLF8eNG5dsHHfccf/rf/2vqIv/+Mc/TkV448aNu+SSS/azqlmzZn3yySfJ9hVXXNGzZ889djvppJOuvfbaJ554Yo9n//SnPyUb2dnZv/nNb6Luddttt40dOzZ5u7/+9a+/+tWv9rPIeDy+adOmZPu4447bz1G1VFpamtwuIxaLVV/ut4vu3bsnG9u3b69+PLnEMtmO+va9nj17jho1KtmuvjFIbcYeItu3b584cWKy3bt376hvFbj00kvbtm27du3aEMJHH32UOl7LD3P79u1PPvlksn3uueeef/75h/Pu4dBPQwCAo4wAEYDDYf369an2PgOjESNG7HMF1jPPPDNs2LA9nho0aNBeMoWDKBX37NHo0aNTX/M3a9asZID4+eefr1y5MnnwlltuST1iubtTTz3161//+qxZs0IIb7755v5XlXqaO4Tw4x//eC89f/SjH0UFiC+99FKyMWTIkE6d/l97dx8UVdUHcPwgL5KmNr4gEilCEhFik+9pSCWmqKmpNNNoSUGTNcVkjeaMWaa9PFP5SmVDZaWVJaloFCDgmIGAbeqkiSggooASEKQSoHufP+7Tmdsu9+7CLksP8/38ddh7zj3nnt1rM7/OOb9b9e7g5eUVFxe3YsUKIcSpU6fq6upsRodV9fX1MqBmMAnO9fDDD+v9ZrT0gtc+Pj7e3t5qKGrPnj3x8fHWK1t79Oixbt0657btIPn5+TKG+8wzzxjUXLRokfXiOwcnMz8/v66urrN6d8FrCAAA0MWwhRkA4AralA42Vxc6aN68eR16f1VAQIBc39Sq6dOn33DDDWrZZDKphYKCAllh6tSpxl1ER0erhd9//72srMzOgeXl5akFPz+/sWPHGtS88847rfdfCyFqa2tPnz6tluXJfXrkWYqKoljkrjEgD8QUQsh9rP8G1dXV27dvb/VSt27d5DLS1NTUmJiY0tJSO2/rSNsOkp+fL8vGC+tWr159+PDhw4cPy3WpdjKYTG3vM2bMcHHvLngNAQAAuhhWIAIAXEHdb6iSh991EOsj/zqC3uZlyc3NbciQIYWFhUIImRBZbi4WQgwePNj4DtrDAYuLi232qJLHvQ0dOtRm5SFDhly4cMHiQ+1e0VGjRhnfQbtV3PpWerp3796rV68///xTCCFXonWKq1evFhcXl5SUnDx50mQyff/99wYBzTVr1shoV3Jy8rfffjt69Ojo6Oh777137NixMqWM09t2hJMnT6qFnj17qlm5HWf/ZMree/ToYeeqVSf27oLXEAAAoIshgAgAcAVtVmKbq3iOHDmid+mmm26qr6+3v6+OY08cISAgQA0gyjHLTaNubm4yN64ebeTC5lNLMh5nTwBx8ODBubm5Fh/W1NTI8n333WdnvxYNberXr58aQLQ/7OgsJSUlO3bsOHjw4PHjx8+dOyc3U9s0ffr0ZcuWyaMeFUUpKCgoKCh49dVXvb29J06cGBMTM3fuXJne11ltO4L8ndj8HRpr32TK3ltdA9vRvbvgNQQAAOhi2MIMAHCFG2+80c/PTy3n5eVdu3atHTe5fv26GnIyZp0vuCP4+PjYrCODIzLuIMffp08fm4vOBg0aJMsNDQ12Dkzmi/D19bVZudVENDK80lZNTU32V5ZHK54+fbodcZnFixfPnDlz5syZs2bNMpvNdrZqaGhISEgIDg5+6aWXUlNTy8rKLEJOAQEB48ePN7jDW2+9lZGRYZ1y5K+//srMzHzyySd9fX0TEhIaGxud29bp5Jxrf2Zt4shkyt7lPwuu7N0FryEAAEAXwwpEAICLREZGqvlML1++bDKZjI/na1VlZaU9oSLr9BRtZc86Jm1aGD3V1dVqQcY0ZbqG+vr65uZmLy8vg+baBX09evSw2Z2qd+/e6imTVVVVNiu3+hTu7u6yHBERYTxIrTatZYuMjMzMzBRCKIqSn58/ZcoU+9s2NjZ+9NFHahg6ODi4Wze7/odoY2PjtGnTtCsuu3XrFhYWNmrUqGHDht12220jRowIDAx89913Dx06ZHCfqKioqKiowsLClJSU9PT0Q4cOaZP8trS0bNy4MT09PScnx3oxrCNtnUv+Jtu3qs7ByZQvQvtORHVW7x33GgIAAHQxBBABAC4iA4hCiC1btrQjgKjNL9yhZODPgDxq0EBJSYlakKe8ycPmFEU5f/58YGCgQXPtXm/7z4nr06dPRUWFEMKeNB2tbifX9rVt2zbtFk4nioyMlOUvvviiTQFEk8kkF7Eap7LRWrlypQw5DR48+OWXX54/f77NnOB6QkJCQkJCli1b1tTUlJeXl52dvXPnTnl85KlTp1544YVPP/3U6W2dRX7L9vySrTk4mQMGDOjE3l3wGgIAAHQxbGEGALjInDlzZFbizz//vE3n5am+/vprZw+qdcXFxTbr2JOPVYbwZKIG7cmJNkMn2lQP9kfxgoODLXo30OpTaHeVVlZW2tlvW40ZM0ZGkZKTk9uUSmXXrl2yPHHiRHuaqIsW1XJQUNCxY8fi4uLaHT3U6t69+6RJk1atWvXrr79mZGTIve2fffaZzYdypK2D5G+ypqbGOBH2pUuXsv6mLgF2fDLlk1ZXV2vXYFqrrq4+8Ddn9e6C1xAAAKCLIYAIAHCR/v37L1q0SC03Nja++OKLbWqel5f33XffOWswxpuUz5w5Y/MOpaWlJ06cMKiQnZ195coVtTxmzBi1MHr0aFkhIyPDuIusrCy1cNNNN8mwoE0yb3JFRUVBQYFBzaNHj7aawCQ8PFzub83JyTHurqqqSkaX7M9GIoTw9PR87rnn1PLVq1dfeuklOxu2tLRs3bpV/vnQQw/Z06qoqEie7bhy5UqDvMPyW7Nw/Pjx9PT09PR0g5WwUVFR7777rvxTZt92pG0H0S4B/umnnwxqJiYmTp48efLkyXPmzFF3izs+mdre8/PzDXp/7733IiMjIyMjo6OjndW7C15DAACALoYAIgDAdV544QWZsuDTTz+VO5ptqq2tXbhwoRNHUltb29zcrHdVG58ysH79eoOrb775pixPmjRJLfj7+8v9kps3b9YLcAghTpw48cMPP6jliIgI+w92vPfee2VZ5vxt1dq1a1v93NPTU2afSExMND53MiEhQY0uLV++vK2nTz799NM9e/ZUy0lJSfJ5ja1Zs0buMZ8wYYI96bDFP3M9h4aGGtQ8evRoq59/++23U6dOnTp16pQpUwx+PCNGjJBlecSkI207yIQJEzw8/neUzbp16wxqpqWlqYXbb79dLTg+mZMnT/b09FTLGzZsMLhDenq6Whg2bJizenfBawgAANDFEEAEALhOUFCQNqT12GOPJSUl2WxVUVExbdo0e1YF2tSrVy+10NLScuzYsVbrpKWlaZMzGNi2bZve/seDBw+qGUKEEGFhYXIFohDi8ccfVwt1dXWbN2/Wu/mbb74pF/TFxcXZMx7VhAkTZKhl9+7dR44cabVacXHx9u3b9W7yxBNPqIWSkpKNGzfqVTty5EhycrJafuSRR+wfpKpv374rVqxQy4qizJ07V6720pOWlvb666/LP1977TU7+5IZsYUQ5eXletUyMzNTUlJavSSjey0tLfv27dO7w88//2zdqSNtO4iPj8+DDz6oltPS0vReh+zsbDmq6Oho67G1bzJ79ep1//33q+WUlJSioqJWq+Xm5spVtNOmTXNW76LjX0MAAICuRgEAwIXMZvP06dO1/yWaMWPG0aNHW63c3NyclJQ0cOBAtWZYWJg8NW/79u3amtqdoefPn9fr/bfffpPVIiIizGazRYWjR49arGjLzMzUVggJCdFeDQ8Pr6ystLiJyWSS4xRCbNmyRXu1qqpKntfm5eW1d+9e63FqVy+GhoZeu3ZN74la9eGHH8rmN9988/Hjxy0qlJeXy9VkqnHjxmkrNDU1BQQEqJc8PDwsHkFVVFTk6+ur1vH09KyoqGjTIFVms/mBBx6Qw3B3d1+yZElDQ4N1zStXrqxevVqbIXrWrFnW1eRyOSHE77//rn0iueQtKirK+qtXFOWzzz7T7ocdMGCAtpr2TMmQkJDi4mLrO5SUlAwaNEit4+PjI784R9oqiiKjtB4eHtYNJ0+erF596qmnrK8qiiKzYycmJmo/z8nJkUvqgoKCysrKLBpeuHBh6NChaoWePXuWlpaqnzs+mYqiHD58WPY+fPjw6upqizvU1tbKX6m3t3dRUZETe3fBawgAANCVEEAEALja1atXZ8yYIf5p+PDhS5cuTUpK2rNnz65duz744IPY2FgZnxJCjBs3rra2dt68eeqf7QsgXr9+vX///rLmxIkTc3JyGhsbFUWpqalJTEzs0aOHEGLYsGF33XWXWkcvgChjHwMGDHj99dcLCgrOnDmTlZW1ePFiGd0QQkRGRloHOGQKCPU+CxYsyMjIOHv27JkzZ3bs2KHdg+zu7p6fn9/WGTabzXIPshp8SUhI2L9//5kzZ/Lz81etWiWTycrHtAggKoqyf/9+7YbNqKio7du3nzx58uzZs9nZ2c8//7w8J1EIkZSU1NZBStXV1bfeeqv2x3DDDTfExMRs2LAhOTl59+7dmzZtio+Pt8iSERISUl9fb303vQCioihyAZ0QYubMmSaTqbm52Ww2l5aW7t69OyoqyuKbFULs2rVLe4eYmBjtrC5btiwlJaWwsFD96pcsWSKXuAoh3nnnHWe17aAAoqIozz77rOy0d+/er7zyyuHDh8vLy3Nyct5++23tnFu0dXwyFUWRh6IKIXx9fTdt2lRaWtrY2Hjq1KktW7ZoX/+1a9c6vfeOfg0BAAC6EgKIAIBO0NLS8swzz6gpEeyxYMGCy5cvK4oijx1sXwBRURTrXY3dunXTBkr69etXVFQkgzJ6AcTFixeHh4cbD/uOO+64ePFiq8NYunSpzaf28PD44osv2jfDlZWVNhM+jBw5UuavsA4gKoqSlJRkz3e0ZMmS9g1Sqqmp0cZrbBo/frzet2wQQCwvL7dIuOHu7i4PYVSFh4fLaJ1qyJAh33zzjRynNkW1gdmzZ1ssWHOkbccFEJuamuRGZgP333+/RRzc8clUFKWxsVFuTDYQERFx/fp1p/eudPxrCAAA0GVwBiIAoBN4eHgkJiYWFBRMnDjRuOYdd9yRnZ29detWNTpwzz33ONj1gw8+uHbtWm2swWw219fXq+XRo0f//PPP8gxBA/369cvKyjIIvsybN2///v0+Pj6tXv3Pf/7z4Ycf9uvXT695cHBwWlpaOw4WVPn6+h44cGDWrFl6FebMmZOZmWkRc7EQFxeXmpoaFBSkV8Hf3//jjz9+++232zdIqW/fvhkZGZs3b77llluMa/bv33/16tUHDhxoxxGB/v7+O3fu1K52vH79ukyg4enpmZCQkJubO2fOHO3+7rKysoaGBjnO7777zmIbuwU/P7/169fv2LFDu9vawbYdx8vLKzk5efny5V5eXq1WcHNzW7Ro0Z49eyzyhzg+mUIIb2/v3bt3x8fHG8SpFyxY8P3331tUcErvouNfQwAAgC7DTfn7ZGgAADpFUVHRzp07s7Kyzp8/X1lZ2dzcPGjQID8/vwkTJsyfP3/kyJHaymaz+eDBg0KI0NBQ7TmDbVVVVfXOO+/88ssvp0+frqmp8ff3DwsLW7hw4cyZM2Vq2lbdfvvthYWFQogVK1asXr1aCJGRkbF169bc3NyqqioPDw8/P7+IiIgFCxbYE+usq6v76quv9u7dW1hYePHiRQ8Pj4EDB44cOXL27Nlz587VboVutx9//PHLL788ePBgRUVFU1OTn5/fyJEjY2Njp06daucdmpubk5OT9+zZYzKZLl686ObmFhwcfNttt40dOzY+Pl67kdlxzc3NGRkZmZmZOTk5Fy9erKmpMZvNffv2HTBgwNixYydNmjR79mx1m7kjXbz//vv79+8vKio6e/Zsr169AgICoqOjH330UZmZt6ioaMmSJYcOHbpy5UpgYODGjRvlKj8hREtLy969e3ft2mUymSorKy9fvuzj4xMYGDh06NC77747NjZWphq35kjbDlVaWrpt27bU1NSysrKamprevXsPHjw4MjLy8ccfDwsL02vl+GSqjhw5smXLln379qkvV/fu3YcMGXLffffFx8fLXfYd17sLXkMAAID/dwQQAQBoA+sAIgCnOHDgQGRk5CeffBIbG9vZYwEAAMA/sIUZAAAAnW/Dhg1CiOTk5Pnz569Zs6aurq6zRwQAAID/MdqlBQAAALjApUuX0tPTQ0ND09LSzGZzcnLy119/bTKZ9A5nBAAAgCuxAhEAAACdzMfHp76+/sSJE+fOnVNz+xw/ftxkMnX2uAAAACAEAUQAAAB0orKyMrWg5i+6+eab77zzTvUTBxPmAAAAwFkIIAIAAKBzHDt2LDAwcMaMGXv37q2srCwvL3/jjTdyc3OFEEOHDjVIAA0AAABX4gxEAAAAdI4//vhj3Lhxqampqamp2s+DgoJSUlLc3d07a2AAAADQIoAIAEAbhISEeHt7CyF8fX07eyzA/71Jkybl5OQUFxfv27evtLS0pqbG398/PDx81qxZRA8BAAD+PdwURensMQAAAAAAAAD4l+IMRAAAAAAAAAC6CCACAAAAAAAA0EUAEQAAAAAAAIAuAogAAAAAAAAAdBFABAAAAAAAAKCLACIAAAAAAAAAXQQQAQAAAAAAAOgigAgAAAAAAABAFwFEAAAAAAAAALoIIAIAAAAAAADQRQARAAAAAAAAgC4CiAAAAAAAAAB0EUAEAAAAAAAAoIsAIgAAAAAAAABdBBABAAAAAAAA6CKACAAAAAAAAEAXAUQAAAAAAAAAugggAgAAAAAAANBFABEAAAAAAACArv8CArFs+8doqRMAAAAASUVORK5CYII=" width="864" /></p>
</div>
<div id="análise-de-concordância" class="section level2" number="6.3">
<h2><span class="header-section-number">6.3</span> Análise de Concordância</h2>
<p>Como nossa base de dados está no formato de medidas repetidas (falantes acentuando diversas pseudopalavras) e uma mesma palavra-alvo gerou diversas pseupalavras, o pressuposto de independência entre as observações não é verdadeiro. Logo, optamos por medir a concordância entre a acentuação dos falantes através de uma Estatística do tipo Kappa, separando as análises em cada nível das seguintes variáveis: Grupo de Classificação, Estrutura da palavra e Segmento Modificado.</p>
<p>Busca-se investigar o grau de concordância entre os falantes quanto a classificação das 372
pseudopalavras em oxítona, paroxítona e proparoxítona. Como os níveis da variável resposta (tonicidade
da produção) têm uma distribuição desbalanceada, houve a necessidade de utilizar um fator corretor
no cálculo da estatística Kappa. Assim, para esse conjunto de dados, foi adotado a estatística de Gwet,
medida que, de acordo com a literatura, pode ser utilizada em amostras desbalanceadas.</p>
<p><strong>AC1 de Gwet:</strong> Coeficiente para n experimentos com r avaliadores que utilizam um sistema de classificação em Q categorias</p>
<p><span class="math display">\[  AC1 = \frac{p_a - p_{e\gamma}}{1-p_{e\gamma}}  \]</span> com
<span class="math display">\[ p_a = \frac{1}{n}\sum^n_{i=1}(\sum^Q_{q=1}\frac{r_{iq}(r_{iq}-1)}{r-1}) \]</span>
<span class="math display">\[p_{e\gamma} = \frac{1}{Q-1}\sum^Q_{q=1}\pi_q(1-\pi_q)  \]</span>
<span class="math display">\[ \pi_q = \frac{1}{n}\sum^n_{i=1}\frac{r_{iq}}{r}  \]</span>
Temos que<br />
<span class="math inline">\(p_{e\gamma}\)</span> = probabilidade de concordância ao acaso
<span class="math inline">\(p_a\)</span> = probabilidade de concordância geral
<span class="math inline">\(\pi_q\)</span> = probabilidade de classificação na categoria q</p>
<p>Quanto mais próximo de 1 menor a probabilidade de a concordância acontecer devido ao acaso, ou seja, melhor a concordância entre os falantes na classificação das pseudopalavras. Altman, DG (1991) define os seguintes pontos de corte para a interpretação da estatística Kappa (e, consequentemente, do AC1)</p>
<table style="width:100%;">
<caption>
<span id="tab:ponto-corte">Tabela 6.5: </span>Pontos de corte para medidas do tipo Kappa
</caption>
<tbody>
<tr>
<td style="text-align:left;">
AC1 &lt; 0,20
</td>
<td style="text-align:left;">
pobre
</td>
</tr>
<tr>
<td style="text-align:left;">
0,2 &lt;= AC1 &lt; 0,4
</td>
<td style="text-align:left;">
razoável
</td>
</tr>
<tr>
<td style="text-align:left;">
0,4 &lt;= AC1 &lt; 0,6
</td>
<td style="text-align:left;">
moderada
</td>
</tr>
<tr>
<td style="text-align:left;">
0,6 &lt;= AC1 &lt; 0,8
</td>
<td style="text-align:left;">
boa
</td>
</tr>
<tr>
<td style="text-align:left;">
AC1 &gt;= 0,8
</td>
<td style="text-align:left;">
muito boa
</td>
</tr>
</tbody>
</table>
<p>Além da estimação da medida geral (sem segmentar a base de acordo com alguma característica), separou-se as pseudopalavras em cada uma das categorias da variável escolhida e calculou-se a medida AC1 de concordância em cada um dos níveis.</p>
<p>Observando o resultado da medida sem abertura dos níveis (vide Tabela <a href="#tab:gwet-geral">6.6</a>), os falantes apresentaram uma concordância boa na atribuição do acento tônico pois a estatística de Gwet produziu um coeficiente de, aproximadamente, 0.68.</p>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<caption>
<span id="tab:gwet-geral">Tabela 6.6: </span>Estatística de Gwet para a base total (sem abertura por nível de uma variável).
</caption>
<thead>
<tr>
<th style="text-align:left;">
Estatística
</th>
<th style="text-align:right;">
Valor da Estatística
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Gwet’s AC1
</td>
<td style="text-align:right;">
0.6775543
</td>
</tr>
</tbody>
</table>
<p>Já na Tabela <a href="#tab:gwet-grupo">6.7</a>,vemos que há semelhança de concordância entre os grupos similares e dissimilares, sendo nas dissimilares os maiores níveis de concordância (0.75 e 0.71). Porém em todos os casos pode se considerar que a concordância foi boa.</p>
<p>Uma hipótese para o fato de os falantes concordarem mais nos grupos dissimilares seria de que quanto menos referência entre a pseudopalavra e uma palavra real, maior a chance de o falante utilizar outra característica para definir a tonicidade (como por exemplo a estrutura da palavra).</p>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<caption>
<span id="tab:gwet-grupo">Tabela 6.7: </span>Estatística de Gwet para cada nível da variável Grupo de classificação).
</caption>
<thead>
<tr>
<th style="text-align:left;">
Grupo de classificação
</th>
<th style="text-align:right;">
Valor da Estatística
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Grupo 1
</td>
<td style="text-align:right;">
0.6641838
</td>
</tr>
<tr>
<td style="text-align:left;">
Grupo 2
</td>
<td style="text-align:right;">
0.7549719
</td>
</tr>
<tr>
<td style="text-align:left;">
Grupo 3
</td>
<td style="text-align:right;">
0.5874817
</td>
</tr>
<tr>
<td style="text-align:left;">
Grupo 4
</td>
<td style="text-align:right;">
0.7063545
</td>
</tr>
</tbody>
</table>
<p>Em relação a estrutura da palavra, há uma maior concordância nas respostas dos falantes cujas pseudopalavras estão no nível CV-CV-CV, como visto na <a href="#tab:gwet-estrutura"><strong>??</strong></a>. Dado que dentro da estrutura CV-CV-CV 85% das pseudopalavras nesse nível foram classificadas como paroxítonas, parece existir uma concordância alta entre os falantes de seguirem essa tonicidade.</p>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<thead>
<tr>
<th style="text-align:left;">
Estrutura da palavra
</th>
<th style="text-align:right;">
Valor da Estatística
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
CV-CV-CVC
</td>
<td style="text-align:right;">
0.6582021
</td>
</tr>
<tr>
<td style="text-align:left;">
CV-CV-CV
</td>
<td style="text-align:right;">
0.7626996
</td>
</tr>
</tbody>
</table>
<p>Por fim, em relação ao segmento modificado, vemos que há semelhança na medida de concordância entre os dois níveis de mudança (0.67 e 0.68). Ou seja, os falantes concordam na tonicidade da produção de forma muito parecida entre os dois níveis como visto na <a href="#tab:gwet-segmento"><strong>??</strong></a>.</p>
</div>
<div id="resumo-da-análise-descritiva" class="section level2" number="6.4">
<h2><span class="header-section-number">6.4</span> Resumo da Análise Descritiva</h2>
<p>No geral, podemos ver que há um grande “confundimento” entre oxítonas e paroxítonas, além dos participantes acentuarem as pseudopalavras de forma paroxítona com bastante frequência. Logo, isso reforça a teoria de que o acento na penúltima sílaba é o padrão seguido pelos falantes do português brasileiro.</p>
<p>Além disso, dificilmente um falante acentua uma palavra desconhecida de forma proparoxítona e as volumetrias parecem ir ao encontro das teorias fonológicas de que se a palavra terminar em consoante o acento será oxítono e se terminar em vogal, o acento é paroxítono.</p>
<p>A análise de concordância parece indicar que as variáveis Grupo de classificação e Estrutura da palavra são importantes para a atribuição do acento tônico, visto que seus níveis apresentaram estatísticas de Gwet levemente diferentes entre si.</p>
<p>A partir desses resultados, serão desenvolvidos <strong>Modelos de Regressão Mistos Multinomiais</strong> com o falante como efeito aleatório, pois há interesse em analisar variáveis relacionadas aos indivíduos.</p>
<!--chapter:end:05-descritiva.Rmd-->
</div>
</div>
<div id="univariada" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Análise univariada</h1>
<div class="page-break-after"></div>
<!--chapter:end:06-univariada.Rmd-->
</div>

<div id="appendix-apêndices" class="section level1 unnumbered">
<h1>Apêndices</h1>
</div>
<div id="tabelas" class="section level1" number="8">
<h1><span class="header-section-number">A</span> Tabelas</h1>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<caption>
<span id="tab:perfil-informantes">Tabela A.1: </span>Perfil dos participantes de acordo com a Naturalidade.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Naturalidade
</th>
<th style="text-align:right;">
Total
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
São Paulo, SP
</td>
<td style="text-align:right;">
16
</td>
</tr>
<tr>
<td style="text-align:left;">
Outros municípios de SP
</td>
<td style="text-align:right;">
12
</td>
</tr>
<tr>
<td style="text-align:left;">
Outras UF
</td>
<td style="text-align:right;">
6
</td>
</tr>
</tbody>
</table>
<br>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<caption>
<span id="tab:area-formacao">Tabela A.2: </span>Frequência da variável dicotômica Área de formação.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Área de formação
</th>
<th style="text-align:left;">
Total
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Outro
</td>
<td style="text-align:left;">
19 (56%)
</td>
</tr>
<tr>
<td style="text-align:left;">
Letras
</td>
<td style="text-align:left;">
15 (44%)
</td>
</tr>
</tbody>
</table>
<br>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<caption>
<span id="tab:area-escolaridade">Tabela A.3: </span>Escolaridade dos participantes pela Área de formação.
</caption>
<thead>
<tr>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="2">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Área de formação
</div>
</th>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
</tr>
<tr>
<th style="text-align:left;">
Escolaridade
</th>
<th style="text-align:left;">
Outro
</th>
<th style="text-align:left;">
Letras
</th>
<th style="text-align:left;">
Total
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<ol style="list-style-type: decimal">
<li>Fundamental Completo
</td>
<td style="text-align:left;">
1 (2.9%)
</td>
<td style="text-align:left;">
0 (0.0%)
</td>
<td style="text-align:left;">
1 (2.9%)
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="2" style="list-style-type: decimal">
<li>Superior Incompleto
</td>
<td style="text-align:left;">
6 (17.6%)
</td>
<td style="text-align:left;">
11 (32.4%)
</td>
<td style="text-align:left;">
17 (50.0%)
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="3" style="list-style-type: decimal">
<li>Superior Completo
</td>
<td style="text-align:left;">
5 (14.7%)
</td>
<td style="text-align:left;">
1 (2.9%)
</td>
<td style="text-align:left;">
6 (17.6%)
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="4" style="list-style-type: decimal">
<li>Pós-Graduação (Completo ou Incompleto)
</td>
<td style="text-align:left;">
7 (20.6%)
</td>
<td style="text-align:left;">
3 (8.8%)
</td>
<td style="text-align:left;">
10 (29.4%)
</td>
</tr>
<tr>
<td style="text-align:left;">
Total
</td>
<td style="text-align:left;">
19 (55.9%)
</td>
<td style="text-align:left;">
15 (44.1%)
</td>
<td style="text-align:left;">
34 (100.0%)
</td>
</tr>
</tbody>
</table>
<br>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<caption>
<span id="tab:linguas">Tabela A.4: </span>Frequência da variável dicotômica Línguas.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Conhecimento em línguas
</th>
<th style="text-align:right;">
Total
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Sim
</td>
<td style="text-align:right;">
26
</td>
</tr>
<tr>
<td style="text-align:left;">
Não
</td>
<td style="text-align:right;">
8
</td>
</tr>
</tbody>
</table>
<br>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<caption>
<span id="tab:musica">Tabela A.5: </span>Frequência da variável dicotômica Música.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Conhecimento em música
</th>
<th style="text-align:right;">
Total
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Sim
</td>
<td style="text-align:right;">
21
</td>
</tr>
<tr>
<td style="text-align:left;">
Não
</td>
<td style="text-align:right;">
13
</td>
</tr>
</tbody>
</table></li>
</ol></li>
</ol></li>
</ol></li>
</ol>
<br>
<table style="width:100%;">
<caption>
<span id="tab:tonicidade-pseudoxalvo2">Tabela A.6: </span>Frequência da tonicidade das palavras-alvo por nível de tonicidade de produção
</caption>
<thead>
<tr>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="3">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Tonicidade da palavra-alvo
</div>
</th>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
</tr>
<tr>
<th style="text-align:left;">
Tonicidade produção
</th>
<th style="text-align:left;">
oxítona
</th>
<th style="text-align:left;">
paroxítona
</th>
<th style="text-align:left;">
proparoxítona
</th>
<th style="text-align:left;">
Total
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
oxítona
</td>
<td style="text-align:left;">
2642 (54.5%)
</td>
<td style="text-align:left;">
1939 (40.1%)
</td>
<td style="text-align:left;">
323 (11.4%)
</td>
<td style="text-align:left;">
4904 (39.2%)
</td>
</tr>
<tr>
<td style="text-align:left;">
paroxítona
</td>
<td style="text-align:left;">
2154 (44.5%)
</td>
<td style="text-align:left;">
2824 (58.4%)
</td>
<td style="text-align:left;">
2185 (77.2%)
</td>
<td style="text-align:left;">
7163 (57.3%)
</td>
</tr>
<tr>
<td style="text-align:left;">
proparoxítona
</td>
<td style="text-align:left;">
49 (1.0%)
</td>
<td style="text-align:left;">
72 (1.5%)
</td>
<td style="text-align:left;">
323 (11.4%)
</td>
<td style="text-align:left;">
444 (3.5%)
</td>
</tr>
<tr>
<td style="text-align:left;">
Total
</td>
<td style="text-align:left;">
4845 (100.0%)
</td>
<td style="text-align:left;">
4835 (100.0%)
</td>
<td style="text-align:left;">
2831 (100.0%)
</td>
<td style="text-align:left;">
12511 (100.0%)
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table style="width:100%;">
<caption>
<span id="tab:grupo-producao">Tabela A.7: </span>Frequência do Grupo de classificação por Tonicidade de produção (da pseudopalavra).
</caption>
<thead>
<tr>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="4">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Grupo de classificação
</div>
</th>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
</tr>
<tr>
<th style="text-align:left;">
Tonicidade produção
</th>
<th style="text-align:left;">
1 (Similar de alta freq.)
</th>
<th style="text-align:left;">
2 (Dissimilar de alta freq.)
</th>
<th style="text-align:left;">
3 (Similar de baixa freq.)
</th>
<th style="text-align:left;">
4 (Dissimilar de baixa freq.)
</th>
<th style="text-align:left;">
Total
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
oxítona
</td>
<td style="text-align:left;">
1077 (22.0%)
</td>
<td style="text-align:left;">
1152 (23.5%)
</td>
<td style="text-align:left;">
1308 (26.7%)
</td>
<td style="text-align:left;">
1367 (27.9%)
</td>
<td style="text-align:left;">
4904 (100%)
</td>
</tr>
<tr>
<td style="text-align:left;">
paroxítona
</td>
<td style="text-align:left;">
1805 (25.2%)
</td>
<td style="text-align:left;">
1818 (25.4%)
</td>
<td style="text-align:left;">
1760 (24.6%)
</td>
<td style="text-align:left;">
1780 (24.8%)
</td>
<td style="text-align:left;">
7163 (100%)
</td>
</tr>
<tr>
<td style="text-align:left;">
proparoxítona
</td>
<td style="text-align:left;">
153 (34.5%)
</td>
<td style="text-align:left;">
48 (10.8%)
</td>
<td style="text-align:left;">
167 (37.6%)
</td>
<td style="text-align:left;">
76 (17.1%)
</td>
<td style="text-align:left;">
444 (100%)
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table style="width:100%;">
<caption>
<span id="tab:validacao-grupo-tonicidade">Tabela A.8: </span>Tonicidade de produção por Grupo de classificação e Validação.
</caption>
<thead>
<tr>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="2">
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="3">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Status Validação
</div>
</th>
</tr>
<tr>
<th style="text-align:left;">
Grupo de classificação
</th>
<th style="text-align:left;">
Tonicidade produção
</th>
<th style="text-align:left;">
Não Validada
</th>
<th style="text-align:left;">
Quase Validada
</th>
<th style="text-align:left;">
Validada
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:left;">
oxítona
</td>
<td style="text-align:left;">
82 (3.9%)
</td>
<td style="text-align:left;">
44 (3.3%)
</td>
<td style="text-align:left;">
951 (10.5%)
</td>
</tr>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:left;">
paroxítona
</td>
<td style="text-align:left;">
673 (31.8%)
</td>
<td style="text-align:left;">
141 (10.5%)
</td>
<td style="text-align:left;">
991 (11.0%)
</td>
</tr>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:left;">
proparoxítona
</td>
<td style="text-align:left;">
17 (0.8%)
</td>
<td style="text-align:left;">
17 (1.3%)
</td>
<td style="text-align:left;">
119 (1.3%)
</td>
</tr>
<tr>
<td style="text-align:left;">
2
</td>
<td style="text-align:left;">
oxítona
</td>
<td style="text-align:left;">
38 (1.8%)
</td>
<td style="text-align:left;">
154 (11.4%)
</td>
<td style="text-align:left;">
960 (10.6%)
</td>
</tr>
<tr>
<td style="text-align:left;">
2
</td>
<td style="text-align:left;">
paroxítona
</td>
<td style="text-align:left;">
96 (4.5%)
</td>
<td style="text-align:left;">
210 (15.6%)
</td>
<td style="text-align:left;">
1512 (16.7%)
</td>
</tr>
<tr>
<td style="text-align:left;">
2
</td>
<td style="text-align:left;">
proparoxítona
</td>
<td style="text-align:left;">
1 (0.0%)
</td>
<td style="text-align:left;">
8 (0.6%)
</td>
<td style="text-align:left;">
39 (0.4%)
</td>
</tr>
<tr>
<td style="text-align:left;">
3
</td>
<td style="text-align:left;">
oxítona
</td>
<td style="text-align:left;">
183 (8.6%)
</td>
<td style="text-align:left;">
109 (8.1%)
</td>
<td style="text-align:left;">
1016 (11.2%)
</td>
</tr>
<tr>
<td style="text-align:left;">
3
</td>
<td style="text-align:left;">
paroxítona
</td>
<td style="text-align:left;">
824 (38.9%)
</td>
<td style="text-align:left;">
87 (6.5%)
</td>
<td style="text-align:left;">
849 (9.4%)
</td>
</tr>
<tr>
<td style="text-align:left;">
3
</td>
<td style="text-align:left;">
proparoxítona
</td>
<td style="text-align:left;">
37 (1.7%)
</td>
<td style="text-align:left;">
7 (0.5%)
</td>
<td style="text-align:left;">
123 (1.4%)
</td>
</tr>
<tr>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
oxítona
</td>
<td style="text-align:left;">
32 (1.5%)
</td>
<td style="text-align:left;">
222 (16.5%)
</td>
<td style="text-align:left;">
1113 (12.3%)
</td>
</tr>
<tr>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
paroxítona
</td>
<td style="text-align:left;">
134 (6.3%)
</td>
<td style="text-align:left;">
333 (24.7%)
</td>
<td style="text-align:left;">
1313 (14.5%)
</td>
</tr>
<tr>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
proparoxítona
</td>
<td style="text-align:left;">
1 (0.0%)
</td>
<td style="text-align:left;">
16 (1.2%)
</td>
<td style="text-align:left;">
59 (0.7%)
</td>
</tr>
<tr>
<td style="text-align:left;">
Total
</td>
<td style="text-align:left;">
<ul>
<li></td>
<td style="text-align:left;">
2118 (100.0%)
</td>
<td style="text-align:left;">
1348 (100.0%)
</td>
<td style="text-align:left;">
9045 (100.0%)
</td>
</tr>
</tbody>
</table>
<br></li>
</ul>
<table style="width:100%; margin-left: auto; margin-right: auto;" class="table">
<thead>
<tr>
<th style="text-align:left;">
Segmento Modificado
</th>
<th style="text-align:right;">
Valor da Estatística
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
vogal
</td>
<td style="text-align:right;">
0.6725362
</td>
</tr>
<tr>
<td style="text-align:left;">
consoante
</td>
<td style="text-align:right;">
0.6826297
</td>
</tr>
</tbody>
</table>
<div class="page-break-after"></div>
<!--chapter:end:A-tabelas.Rmd-->
</div>
<div id="graficos" class="section level1" number="9">
<h1><span class="header-section-number">B</span> Gráficos</h1>
<div class="figure">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABsAAAASACAIAAADOHB9sAAAACXBIWXMAAB2HAAAdhwGP5fFlAAAgAElEQVR4nOzde5RV1Z0v+l89KR5VPEQERCOID8CIoEgTNajxGbtNxzxP0iZ9k3MP3nE6nXQn6qEdjnA73XHoyaPTnXjuMMYkdhtNNOm0iTY+oq0REUQDgk8QkLdgAUVBUVC1a98/dmVTFDWLXVUbN8jn89fca881168sV032d6+5Vlk2mw0AAAAAgK6Ul7oAAAAAAODwJUAEAAAAAJIEiAAAAABAkgARAAAAAEgSIAIAAAAASQJEAAAAACBJgAgAAAAAJAkQAQAAAIAkASIAAAAAkCRABAAAAACSBIgAAAAAQJIAEQAAAABIEiACAAAAAEkCRAAAAAAgSYAIAAAAACQJEAEAAACApMpSF3A42rt375w5c9ra2q699tpJkyaVuhwAAAAAKBkBYheWLFmybNmyiNi5c2eBu7zzzjvz5s1buHDhli1btm3bVlZWVldXN378+HPOOWfmzJlVVVW9Lua6667bsGFDIT3nzJkzderUXh8IAAAAAA4kQOzC448/XnjnTCbzwAMP/PznP29tbe24vbm5efPmzc8+++w999zz13/911OmTOlFJW1tbW+//XYvdgQAAACAonAPxM7mzZs3f/78Ajtns9lbb731nnvu6ZgelpWVdexTX18/Z86cHoWSeZs3b85kMr3YEQAAAACKwhWI+7S1tT399NO333574bv87Gc/e+6553LtQYMGffSjHz3vvPOOO+64HTt2rFq16je/+c0LL7wQEdls9gc/+MGYMWNOP/30HpW0cePGXKO2tva6667rvvPYsWN7NDgAAAAAHNTRHiBmMpmFCxeuX79+5cqVS5cubWhoKHzfnTt3/vrXv861R44c+Q//8A8jRozIvRw6dOjQoUOnTp366KOPfv/7388d6I477vjOd77To/LyAeKYMWMuuOCCHu0LAAAAAH13tAeIjY2Nt9xyS+/2nTt37p49e3Lt66+/Pp8ednTZZZe9/vrrjz32WESsWLFi5cqV48aNK/wQ+cenjB49undFQoGy2WzHl51W4gM94oSCInJCQRE5oQDonaM9QOyL/OLlU0899ZRTTkl1u+aaa3IBYkQsXry4RwFi/grE448/vrdlwsFls9n6+vr8y5qamkGDBpWw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AAAAAECSABEAAAAASBIgAgAAAABJAkQAAAAAIEmACAAAAAAkCRABAAAAgCQBIgAAAACQJEAEAAAAAJIEiAAAAABAkgARAAAAAEgSIAIAAAAASQJEAAAAACBJgAgAAAAAJAkQAQAAAIAkASIAAAAAkCRABAAAAACSBIgAAAAAQJIAEQAAAABIEiACAAAAAEkCRAAAAAAgSYAIAAAAACQJEAEAAACAJAEiAAAAAJAkQAQAAAAAkgSIAAAAAECSABEAAAAASBIgAgAAAABJAkQAAAAAIEmACAAAAAAkCRABAAAAgCQBIgAAAACQJEAEAAAAAJIEiAAAAABAkgARAAAAAEgSIAIAAAAASQJEAAAAACBJgAgAAAAAJAkQAQAAAIAkASIAAAAAkCRABAAAAACSBIgAAAAAQJIAEQAAAABIEiACAAAAAEkCRAAAAAAgSYAIAAAAACQJEAEAAACApMpSF3A42rt375w5c9ra2q699tpJkyaVuhwAAAAAKBkBYheWLFmybNmyiNi5c2eBu7S2tj7zzDNPP/30mjVrtm3bVldXd/zxx5933nkXXnhh//79+17SoR4fAAAAALokQOzC448/3qP+y5cv/6d/+qe1a9fmt9TX19fX17/00kv333//X/3VX02dOrUv9Rzq8QEAAAAgxT0QO5s3b978+fML7//aa6/ddNNNHdO9jt55551vfOMbCxYs6HU9h3p8AAAAAOiGKxD3aWtre/rpp2+//fbCd9m1a9c//uM/Njc3R0RlZeXHP/7xCy+8cPjw4du3b3/mmWfuu+++5ubmTCbzrW996wc/+MGIESN6WtKhHh8AAAAAune0B4iZTGbhwoXr169fuXLl0qVLGxoaerT7v/3bv+V2KS8v//rXvz558uTc9hEjRlxzzTVnnXXWjTfeuGfPnj179tx5551/93d/19PyDvX4AAAAANC9o30Jc2Nj4y233HL33Xc/88wzPU0PGxsb586dm2tfffXV+XQvb9y4cZ/97Gdz7eeeey61DLlU4wMAAADAQR3tAWJfPPvss5lMJiLKy8uvvvrqLvtcccUV+ackP/3004fV+AAAAABwUEf7Euba2tpbb72145bdu3fPmTOnkH2fe+65XGPChAnDhw/vsk9NTc3UqVPnzZuX65+/YPBwGB8AAAAADupoDxArKiomTJjQcUtTU1OB+65cuTLX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ERUAAAAAAFDibd++XavVqpcvvPBCEbw0MzNz0KBBq1ev1r/p4ODg6+tbrly5u3fvXrhwQY1Kp9NNnDgxOjp6zpw5uc6s0+lGjBihLEi0sLAICAioV6+etbX1pUuXjh8/rp9SXLt27TfffPPmm28WfYQDBw68dOmS8W5Hjhzp1KlTQkKC/k03N7datWpZW1uHhYXduHFDva/Val977bWMjIxhw4blGgCKEisQAQAAAABAiXf27Fm1XaFCBR8fnyJ46Zdffqmfm6tWrdqKFSvu3bsXEhKya9euM2fOREZGzpw5087OTu3z3//+d/369bnO/O233yrZwx49ely7dm3fvn2LFi368ssvd+7ceePGjbFjx2o0GrXz5MmTMzIyijjCefPm/fnnn0rb2tq6efPmb7755sSJE/38/NQ+SUlJQUFB+tnDNm3a7N+//86dOwcOHPjzzz+vX79+/vz5oKAgtYNOpxszZsy1a9dyDQBFiQQiAAAAAAAo8e7evau269Wrp59fKyTXr1+fOnWqetmqVavTp08HBQXpJ+MqVao0bdq04ODgSpUqqTffe++9tLQ045Mr9aOHDRv2+++/e3p66j9ycnJasGCB/jmDDx48yLEISaFG+MEHH4iIRqN55513wsLCjhw5smTJkjlz5jRr1kztM3PmzKtXr6qXb7/99l9//dW6dWv9X526deuuWLHim2++Ue8kJSW99dZbxt+OIkYCEQAAAAAAlHhRUVFqu0KFCkXwxrlz5yYlJSltJyen9evXu7i45NizSZMmixYtUi+vX7/+1VdfGZ88PT3d3d3966+/NpQJnTNnjr29vXp5+/btIo4wNTVVo9GsWrVq/vz57u7u2TskJycvWbJEvezcufNXX31l6OO88cYbEydOVC937dp18eJF4wGgKJFABAAAAAAAJZ7+CkQTE4gffPBBJZOlpqbqj01ISFArJovIjBkz3NzcjLzr5Zdfbt26tXq5fPnyXMObPHmyra2toadly5atX7++eqkmCosywv/7v//r37+/oaerV6+Oi4tT2paWlkayh4oPP/xQP8Jvv/021wBQZEggAgAAAACAEk/NVYmItbW1KUMSExPvmyzL2C1btqhH+3l4eIwePTrX182aNUttnz17Vj/jmV2FChUM1UVRGT/nsbAjtLS0fO+994x02L59u9ru3Llz7dq1jb/d0dFx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" alt="Idade dos participantes distribuída pelo Genêro" width="864" />
<p class="caption">
(#fig:idade_genero)Idade dos participantes distribuída pelo Genêro
</p>
</div>
<br>
<div class="figure">
<img src="data:image/png;base64,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FyKitrZ2/Pjx/fr1Gzx4cPbpH3300U9/+tP169dHRFFR0amnnjpy5MgePXp88MEHU6dOvfPOO9evX19dXT1u3Ljx48f37Nlz8/+AAAAAANAS2/UTiB9++OFf//rXunbv3r2vu+660047rU+fPoWFhd27dz/44IN/8IMfXHjhhXUdqqurf//739cb4bbbblu9enVEtGvX7gc/+MEZZ5zRp0+f9u3b9+zZc8yYMddcc02HDh0iYsOGDTfddNNm/MkAAAAAoHVs1wHi5MmTN2zYUNceO3Zsg08IHnPMMaNHj65rz5079+23384cWrNmzeTJk+vaJ5100gEHHFDv3D322OPMM8+saz/zzDOpac4AAAAAsMXargPEzOTlvfbaa88990x1GzNmTKb90ksvZdrTp0+vrq6OiHbt2p100kkNnnvcccdlVmF+8sknW14zAAAAAGxO23WAuHDhwrrG/vvvn6Nbnz59OnXqVNdesWJFZn8mf9xnn3169OjR4LkdO3bMLMGc6Q8AAAAAW4vtN0CsqKioW/wkInr16pWjZ0FBQVHRx6vNdOzYMbM/M515n332yXH6kCFD6hqLFy/OXusZAAAAALZ82/UqzBdddFFdY+PXF2YrKysrLy+va/ft27eusWbNmlWrVtW1BwwYkOP0/v371zWqq6uXLFmy6667tqRmAAAAANictt8AsX379pnVUXK7//776xoFBQWZhw2XLVuW6bDzzjvnOD376LvvvtvyALGqqqru3YtAm6qtrc3erK6uziy7BADQbNvwbxRFRUWFhYX5rgKA1rf9BohN9PLLL2cCxKOOOirzBOK6desyfbp27ZpjhOyjmUnTLbF+/fpWGQfYJBUVFRUVFfmuAgDY6q1ZsybfJbSV0tLSzBqSAGxLBIi5PPXUU9dff33diwtLS0vPOOOMzKHsALFDhw45Bmnfvn2DZwEAAADAlk+A2LDly5f/4Q9/ePrpp+s2O3bs+IMf/GCXXXbJdMied1BcXJxjqOyjnhwEAAAAYOsiQKxv3bp199xzz/3335+Zq9ijR49LL7108ODB2d2ynyusrKzMMWD20dxRIwAAAABsaQSIn6itrX3sscduueWWDz74ILPzmGOOOf/88zt16lSvc/arPXIHiNkvTWuVF4J07NhREAmbQW1t7YcffpjZbN++fe73FQAANEWXLl3yXUJbKSryD0yAbZO/3z+2aNGiX//612+88UZmz7777nveeefVe/AwIzsKzP0W5OyjrRIgFhUV+Q8zbAY1NTXZm4WFhQJEAKDl/EYBwFZHDhUR8dBDD/3+97/PPCrYv3//c88997DDDstxSvb7EFesWJHKGSPi/fffz7R79+7d4mIBAAAAYPMRIMaECRPuvPPOunaHDh3OPPPMk046qV27drnP6tKlyw477LB69eqIWLx4cY6eS5YsqWsUFBT069evNUoGAAAAgM2kkZhsmzd58uRMejho0KDrr7/+K1/5SqPpYZ2BAwfWNebMmZOjW+Zov379spdeAQAAAIAt33YdIK5evfrGG2+sax9wwAH//d//vUlTjA899NC6xqxZs7JXWshWXV09c+bMuvbw4cNbUCwAAAAA5MF2HSBOnjy5bgHlbt26XX755R07dtyk04cPH173rGJFRcXDDz/cYJ/p06dn1nQ+8sgjW1YvAAAAAGxu22+AWF1d/fe//72uPWbMmC5dumzqCD169Pj85z9f177zzjuXLVtWr8Pq1atvuummuvawYcMyU54BAAAAYGux/S6i8vrrr69ataquXVhY+PzzzzflrAEDBvTs2TOz+bWvfW369Olr165dt27df/7nf1500UXDhg0rKCiIiFdeeeU3v/lN3SWKi4vPOeecNvghAAAAAKBtbb8B4vz58zPtzJsQG/XNb37zhBNOyGz27Nlz7NixP/nJT2pqalatWvXjH/+4S5cuO+64Y1lZ2Zo1azLdLrroot133721KgcAAACAzWb7ncK88Yzj5hk2bNgPf/jD7t27122uWbNmwYIFmfSwS5cuV1xxxciRI1vlWgAAAACwmW2/TyCuXr26tYY68MADb7jhhieeeGLq1KnLli374IMPunTp0rt37yOOOGLUqFFdu3ZtrQsBAAAAwGZWUFtbm+8aALZENTU1ZWVlmc2SkpLS0tI81gNbuIKrx+W7BICtQ+0Vl+W7BADYNNvvFGYAAAAAoFECRAAAAAAgSYAIAAAAACQJEAEAAACAJAEiAAAAAJAkQAQAAAAAkgSIAAAAAECSABEAAAAASBIgAgAAAABJAkQAAAAAIEmACAAAAAAkCRABAAAAgCQBIgAAAACQJEAEAAAAAJIEiAAAAABAkgARAAAAAEgSIAIAAAAASQJEAAAAACBJgAgAAAAAJAkQAQAAAIAk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/dEDAFque/fu+S6B1pQ9f3no0KH77bdfRHzxi1/MLKvy4IMPrl69eocddshPfQCtQYAIAAAAzbF06dLHH388s3n22WfXNb761a9mAsQNGzbce++9//qv/9q8S1RVVd1000233HLL7NmzS0tL//znP6feyFZZWfnoo4/+5S9/efHFF5cuXfrBBx8MGDBg4MCBe+6551lnnXXooYc2/aI1NTUPP/zwY489NnXq1KVLl65cuXLdunVdu3bdaaedhgwZMnz48NNOO23gwIHN+4ly+PDDD//2t7/95S9/mT179tKlS6urq/v167fnnnuedtppJ598cufOnZsxZit+LG1h7ty5//d//zdp0qSFCxcuW7aspqamV69effr0Ofroo7/0pS8dcsghzRu26bdNxosvvvjHP/7xhRdemDVrVnFxcZ8+fT73uc+df/75w4YNy+5WU1MzadKku++++7nnnnvvvfc2bNgwaNCgvfba64gjjvjWt77VoUOHppTXFjfYK6+8MnHixEceeWTJkiXLli3bYYcd+vTps99++40ZM+bYY48tKSnJV2Ft9BVvfgX1VgkAoE69JxBLSko8gQg5FFw9Lt8lAGwdaq+4LN8l0Gp+8YtfXHbZx19oQUHBggUL+vfvHxFr167deeedM2/E+8IXvvDwww83OtqJJ574wAMP1LXr/qm+bNmyY4899pVXXsn0+d///d9vfvObG597//33X3LJJe+8805q8BEjRlx55ZXHHHNMo2XcdtttP/nJT958883c3U4//fRf/OIXffv2bXTAJrr11lsvvfTSFStWNHh0xx13vOGGG04//fRp06Z99rOfrds5cuTI7AB3Y634saTMmzdv0KBBufvcfPPN5557br2d77777pVXXnnLLbfkiGVGjRr1y1/+8oADDsgx+KbeNmefffZtt91W1/7www9LS0uXLFly7rnnPvroow2OP3bs2Kuvvrru3Qvz5s0777zzpk6d2mDPQYMGjR8/vtEPs9VvsPnz51988cWZD2FjPXv2HDduXCbf32yFtdZXvIXwPi8AAABojuz5y0cddVRdehgRnTp1OuGEEzKHHnvssWXLlm3q4O+9996oUaOyY6AGVVdXn3/++V/+8pdzxGQR8cQTTxx33HHjxuX6H36VlZXf+MY3zj777EYzlIi46667jjjiiHnz5jXas1HV1dVnnXXWOeeck0oPI6KsrOxrX/va2LFjmz5ma30sbeHZZ58dOnTozTffnPuhrscff3zYsGF//vOfmz5yE2+bjGnTph100EGp9DAifv7zn1988cUR8dxzzx188MGp9DAi5s6de9JJJ73xxhupDm1xg02ZMmXo0KE50sOIWL58+TnnnHPKKadUVVVttsLa7ivOF1OYAQAAYJPNnj37xRdfzGyeddZZ2UdPO+20zCzmmpqau+6665JLLmn64LW1tf/yL/8yZ86c3N1qamrOPPPMu+66K3tnaWnpPvvs061bt/fee+/111/PLAxYW1s7duzY5cuX/+xnP2twtGuvvfamm27K3lNcXNy3b99+/foVFhYuXbp08eLF69atyxxduHDhOeecM3Xq1BYuGHL22Wffcccd9Xb26dOnX79+5eXl8+fP37BhQ93OcePGLV26tNEBW/djaXUzZswYPXr0mjVrsnf27t174MCBxcXFCxYsmD9/fmZ/dXX1eeedV1VVdf755zc6chNvm4y6yK9u3tXAgQNHjRpVWlo6Z86cZ555ZvXq1ZluN9xww2677XbNNdeUl5dHRFFR0ahRo4YMGbJq1apXXnkl+0/Bhg0bLrjggn/84x8N3hKtfoNNnjz5K1/5Sub2iIjCwsK99957l112WbJkybx58yorKzOH7r333o3vijYqrO2+4jzyBCIAAABsssw80Ijo0KHDqaeemn30hBNO6NSpU2ZzwoQJmzT4L37xi8zk3OLi4sMOO+yCCy4YO3bswQcfnN3t17/+dXYg0r9//1tvvXXFihXPPffcww8//Morr7z77rs//vGPs18A9/Of/3zixIkbX3Hx4sXXXHNNZrNbt25XX3318uXL58+f/9RTT/3jH/948803V65c+ac//WmPPfbIdJs+ffq0adM26Uer509/+lO99PC888577bXXlixZMmPGjNmzZy9fvvyGG27o1q1b3dGmfJKt+LE0qk+fPo/80z777JPZP378+Mz+7Fm9a9euPeuss7Kjpc997nNPPfXU0qVLp06d+vjjj7/99tuzZs3KzqNra2svuuiipjzs2cTbJuPkk08uKyvr0KHD+PHj586de+ONN1533XWTJ09+8803v/zlL2f3vPzyy+tyxv3333/WrFkPPfTQL3/5y5tvvnnmzJl//etfd95550zPJ5988vXXX9/4Wq1+g61YseLss8/OpIeFhYXf/e53Fy1aNGvWrEceeWT27NkfffTR+PHjs9etuvvuuydNmtTWhbXpV5xH3oEI0DDvQIRN4h2IAE3kHYjbhtra2j322CMzPXbMmDEbx0/ZS6lExFtvvZX7ZXnZL7Pr0KHDhg0bCgoKLrnkkssvv3yXXXbZuP/bb7+93377Zd60eMQRRzzwwAMNLvP94osvHnvssZkJwnvsscfs2bPbt2+f3ed73/veVVddVdcuKip6+OGHR44c2WCdCxYsOPzwwzOTsr/3ve/9+Mc/zvFz5bBy5cpBgwZ98MEHmetOmDDhtNNO27jnokWLRowYkf3cViTegdi6H8sm+cxnPvPMM8/UtZ9//vl6y4/U+e53v3vttddmNr/zne9cf/31DT7IduONN15wwQWZzdGjRz/00EMbd9vU2yb7HYgR0bFjxyeffHLjxWQqKir23XffepHWcccdd99993Xs2LFe54kTJ2YH6Pfcc0+9PD3a4AY744wzMtFz+/btH3jggdGjR2/cbeHChQceeOCqVavqNg8//PCnn366TQtr9a94C+EJRAAAANg006dPz3653plnnrlxn3pB2MazdHOoi4HuuOOOX/7ylw3GQBExbty4TEzWtWvXiRMnNhiTRcRBBx3029/+NrP59ttvX3/99fX6ZJKviDj//PNTGUpE7Lrrrtk/75IlSxr5YdL++Mc/ZtLDiPjVr37VYHoYEf379580aVJTFvlt3Y+lda1bt+53v/tdZvOYY45JRUsR8Y1vfCP7nY8PP/zw7Nmzc4/flNumnrFjxza4FHX79u2vuOKK7D2dOnX63e9+t3F6GBGnnHLK/vvvn9lssM7WvcHeeeed7IdMx40b12B6GBEDBgy48cYbs8uoN8W7dQtr6684jwSIAAAAsGmyn+Hq1q1b9pIpGS2cxfztb3/79NNPTx1ds2ZNdg0/+tGPevfunWO0U045JbN4cUTccsst9Tpkv1vwuOOOy11b9pTYTFrXDNlRy+GHH/6tb30rR+e999773//933MP2OofS+u66667MoFpYWFhjmipzve///3s+rODsJTct009PXv2/O53v5s6Wm9p4P/4j/8YMGBAqvNBBx2UaS9fvnzjDq17g/3+97+vqampaw8ePPjb3/52jtFOOeWUPn36ZDanT5/edoVthq84XwSIAAAAsAkqKyuz5yafeuqpDT4ZV28t5jlz5mQvN5FbYWHh5ZdfnqPDgw8+mHnJWr9+/S688MJGx8zM04yIV1999b333ss+et999732T1/84hebWGdLvPnmm9kzZC+77LJGF2O58MIL27XLlWO0+sfSuiZPnpxpH3PMMXvttVfu/p07dz7nnHMym1OmTMndv9Hbpp7hw4dnZ9z1ZL/yLyJGjBiRY6h6nTfWujfYfffdl2l//etfLywszN3/+OOPz7Tnzp3bdoW19VecRwJEAAAA2ASTJ09euXJlZrPe+svZmj2Lefjw4Tme9opPP0V15JFHFhUVNTrmkUce2blz58zmq6++mn10r732GvJPjc4Uzp712WzZr6Lr2rXriSee2Ogp/fr1O/zww3N0aPWPpXXNmDEj0x4zZkxTTsl+meCcOXPqLexbT6O3TT1Dhw7NcbTebZA9SbnRzhtrxRts1apVb7zxRmbz5JNPzj1aRFx33XWL/6lextq6d35bf8V5JEAEAACATXD77bdn2v369TvqqKNSPevNYr7jjjuauJBpg6+ly5YdZBx22GFNGbOoqCj7eai33nqrKWfVs3Tp0u9///vjx49vxrn1ZD+PecghhzRx9ZLBgwfnOJqvj6UpysrKst+bmXtFnYwDDjiguLi4rl1TU/PSSy/l6NzobVPPbrvt1sSehYWFvXr12qTBm6cpN9jzzz+f+XO0ww47DBw4sNFhO3fu3PefMit6t3phm+ErzqPGw3gAAACgzpo1a+6///7M5hlnnJFj4m3dLObMfOfFixc/9dRTOQLHjN133z13h3rL4z7xxBONjhkR2aVmVh9OqaysnDdvXt1E4/nz58+dO/fVV19dvHhxUy7UFNkF5H66Lduuu+6a4+hm+Fiard7IuX+QjPbt2w8aNCiztkaDrxfMaPS2qafRmb8Zjc4ub4Zm32DZby3MHShv5sI2w1ecRwJEAAAAaKp777133bp1mc2f/exnP/vZz5p++oQJE5oSIOZ+SKq2tnb16tWZzUsvvbTpBWSUlZU1uH/WrFm33nrro48++vLLL1dWVjZj5CZatWpVpt2jR48mnpVjim6bfiwtl73edLt27fr169fEE3fccccGB9lY856t28xafoNlf0fZH07eC9sMX3EeCRABAACgqbLnLzfDPffcc/3112dmLKZ07Ngxx9Hy8vLq6uqWlBERFRUV9fYsW7bsyiuvvPnmm3PPs+7du/eQIUMeffTRFhaQncNmv4Uwt/79+6cOtdHH0lqy32234447NnoPZGR/ONkJ6cZy3zZ511o3WHl5eaadYxGYzV/YZviK80iACAAAAE3y7rvvPvbYYy0ZoaysbMqUKV/60pdaq6Rmq5eULVy48LOf/eyiRYvqdSsqKho8ePCgQYP22muvoUOHHnjggUOHDr333ntbHiDusMMOmfZHH33UvLJbXduNnx0SlZWVVVVVNWWNl/h00lpSUtL6lW0WrXiDZd85LZ9y3oqFbdtfsQARAAAAmuTOO+/MfsZt2LBhXbp0afSs8vLymTNnZjYnTJjw/9m77/iq6vt/4OdmsMKQlTDCdAKCDBF3HSyR+kXrAMFRR7WtWquohVa/amuViq3UWatYRaEOrFsQtIiAyhDZW0wIK2wCgUCS+/vjfnt/tyE3QEgI4/l8fB/fx+d8zuec887NxeLLz+d8DjBArFmzZmJiYrSSjIyM/dp7d0/5+fk9evSIzVBSU1N/+ctfnnfeeaeeemqZTPLaU+x62/Xr1+/jVSUsMS7zj6Vs1a5dO9ouLCzMysraxz1MYte0xt7kMFK2X7DY7VwyMjIOncKO7F+xABEAAAD2Sez65Zo1a06aNGlfFo3u2LEjNTV127ZtkcP33ntv+/btKSkppS4jFArVrl07Grpt2rTpAJOyt956a+HChdHD22+//bHHHiun3DCqYcOG0facOXP28ar58+fHO1XmH0vZKvKex4yMjH1JlwoKCmI3hq5bt26ZF3YQlO0XLDZAzMrKKigo2PfdYMq1sCP7V5xQ0QUAAADAYWDhwoUzZsyIHl5++eX7+Mq5qlWr9unTJ3qYm5v73nvvHWAxJ598crS9ePHiA7zbq6++Gm336NFj2LBhJWcoJb8qbh916tQp2p42bdo+blvxzTfflHC2bD+WslW3bt3YFzguXbp0X66aN29e7PrW9u3bl31l5a9sv2CxOy8XFBT88MMPey1gwoQJ9f8jdhejsi3syP4VCxABAABg74psnzJgwIB9v/bqq6+OPRw5cuQBFnPmmWdG26NHj96XS3JzcwcPHjxo0KBBgwYNHjw4Pz8/emrZsmXRdr9+/UKhUMm3WrVq1X7WW4zOnTtH21u2bPnwww/3ekl2dvYXX3xRwoCy/VjK3Omnnx5tv/vuu/tyyVtvvRVtH3fccfXr1y/7sspf2X7BGjVq1KFDh+jhv/71r70W8MEHH6z/j9gpfmX+zT+Cf8UCRAAAANi72NSvcePGP/rRj/b92m7dusUubxw7duy+v/WvWF27do2233777dgcJJ7nnnvu0Ucffeyxxx577LExY8bEbu+wcuXKaPvYY4/d662++uqr/ay3GM2aNYudMDh06NC9Tmx89tlnSw74yvZjKXM9evSItseMGbPX8nJzc19++eXoYffu3cursnJW5l+wH//4x9H2888/X/LWN+Fw+IMPPogexk59LfPCjuBfsQARAAAA9mLKlCnff/999LB///4JCfvxL9RJSUlXXnll9DA/P//tt98+kHrOP//8Vq1aRdoFBQV33HFH7O4ue1q/fv2f/vSn6GHskuogCGrWrBlt73Xl74QJE2LnTB2Im266KdqeMmXKCy+8UMLgZcuWxf4IxSrbj6XM9e3bN/pR5+fn33777SVnpg8//HBswnXrrbeWa3nlp8y/YFdffXU06l22bNkjjzxSwuBhw4bFvmTwsssuK7/CjuBfsQARAAAA9uJA1i9H9OvXL/bwwFcx33XXXdH2xx9/fMstt+Tl5RU7cvPmzd26dcvOzo4cVqtW7Re/+EXsgNiXyv3jH/8oIXR77733LrnkktgBJSd0Jbv22mtj15Pedttt8Zajrlq1qmfPnrGviounDD+WMpeSknLzzTdHDz/55JO77747XsD00ksvxYabXbt2bdu2bbmWV37K/At24oknxv6yfv/73z/77LPF3nDy5MmDBw+OHp533nmtW7cuv8KO4F+xABEAAABKsnv37jfffDN62LZt21L8e/5ZZ50VuynwpEmTMjMzD6SqG2+88YILLogevvTSS6eddtq7774buxtJfn7+8OHDO3bs+N1330U7hw0bVmS72EsuuSTa/vLLL2+44YZorBa1ZMmS6667rk+fPjk5ObH9s2fPLiwsLN2PULt27SeeeCK22ssuu+zmm2+O3Rg3Nzf3pZdeateuXWRLioSEhNhZY3sqw4+lPDz00EMtWrSIHv7lL3/p2rXr1KlTY8csXrz4uuuuu+mmm6LBU0pKyvPPP1/etZWf8viCPfTQQ9HXBYbD4V/+8pcXXXTRJ598snPnziAIduzY8d13391+++3nnntuNHdOSkqK/b6VX2FH5K+4HNf2AwAAwBGgyCsLr7nmmlLcJBQK9evXb8iQIZHDcDj8z3/+89577y11VaFQ6JVXXjnjjDOysrIiPbNnz7700ktr1ap1/PHH16tXLysra9myZUVm7f3mN7+JXTgccfPNN//pT39as2ZN5PDVV18dPXr0j370oxYtWlSvXn3dunXTpk2bM2dOdHy/fv1GjRoVaS9atKhXr16XXnpp8+bNY18At4+uu+66sWPHRu8WBMGLL7744osvNmvWLD09fdu2bUuWLMnNzY2efeKJJ15//fXp06cfhI+lPKSkpLz22mvdu3ffvn17pOfzzz/v0qVLkyZNjj322OTk5IyMjCJraRMSEp577rl9eUPfIas8vmDHHHPM2LFju3fvHv2zOWbMmDFjxgRBUKtWra1bt+457++pp57q2LFjeRd2pP6KBYgAAABQktj1ywkJCUUWI++7q6++OhogBkEwcuTIAwkQgyBIT0+fMmVK9+7dY6fsbdmyJV6+1r9//z/+8Y979levXv3NN9/s3r17ZPZWEATbt2//+OOP9xxZpUqVF1544Zprrvn3v/8djV3Gjh07duzYyy+/vBQBYhAEI0aMKCwsfOONN2I7MzIyMjIyioy844477rzzziLLyfdUVh9LOTnzzDPHjRvXq1evzZs3RztXrFixYsWKPQcnJye/+uqrffv2PWjllYdy+oJ16NDhiy++6N69e+xrBIMg2LJlS5HbVq5c+cknn9zzDYPlVNgR+Su2hBkAAADi2rZt2/vvvx89PO+889LT00t3q3bt2sW+f23WrFnz588/wPKaNGkybdq0+++/v1q1aiUMa9y48auvvvraa6+FQqFiB5xzzjkzZswoeRPYK664Yt68eZEJmIMGDTqQsmMlJiaOGjVq+PDhJawgrl69+ogRI4YNG7aP9yyrj6WcnHHGGXPnzr3mmmtKfm737t1nzpx56EdL+6KcvmCtW7eeP3/+PffcU7ly5WIHhEKh//mf/5k6dWq8/UnKqbAj71cc2usu6QBHp8LCwo0bN0YPq1atmpKSUoH1wCEu9OjQii4B4PAQHjSwokvgyLRu3boPP/zwww8/XLBgwdq1a3Nyco455piGDRuefvrpPXv2/PGPfxzdtbZkH3/88ciRI7/++uvs7Oy8vLy0tLQmTZr06NHjJz/5SZs2baLDwuHwSy+99MwzzyxbtqygoKB58+Y333zznXfeeSA/wrZt2z744IN33nln3rx5q1ev3rlzZ6NGjZo3b3755Zf37du3du3apbhnWX0s5WTJkiXvvffeJ598kpGRkZ2dnZ+fn5aW1rhx465du15yySVF1tseGcrpC7Zx48YxY8a88847o0ePbtiwYZcuXVJTUzt37tytW7dmzZpVYGFHzK9YgAhQPAEi7BcBIsA+EiAClJPbb7/96aef/sc//nHddddVdC1HGkuYAQAAADi8bdmy5R//+EcQBMOHD7/wwgtvvPHGsWPHVnRRRw6bqAAAAABweHvppZe2bdsWBMHEiRMjPcOHD3/kkUcGDx5coXUdIcxABAAAAODw1rVr14kTJ65bt+6f//xnWlpapPP3v/99fn5+xRZ2ZBAgAgAAAHB4a9eu3TnnnFOvXr2rrrrqF7/4RaRz586dq1atqtjCjgwCRAAAAAAOS8OHD9+yZUuRzmhoWLNmzfT09INe1BFIgAgAAADA4Wf8+PE33nhj8+bNBw8e/O233+7YsSM3N/eFF1546aWXIgOuuOKKhATZVxmwiQoAAAAAh5+VK1c2bNhw9erVjz766KOPPhoKhYIgCIfDkbNnnXXWU089VaEFHjmksAAAAAAcfq677rrMzMwPP/zwhhtu6Ny5c2pqapUqVU488cRevXq98847X375ZdWqVSu6xiOEGYgAAAAAHJaSkpIuvvjiiy++uKILOcKZgQgAAAAAxCVABAAAAADiEiACAAAAAHEJEAEAAACAuASIAAAAAEBcAkQAAAAAIC4BIgAAAAAQlwARAAAAAIhLgAgAAAAAxCVABAAAAADiEiACAAAAAHEJEAEAAACAuASIAAAAAEBcAkQAAAAAIC4BIgAAAAAQlwARAAAAAIgrqaxuFAqFyupWJQuHwwfnQQAAAACAGYgAAAAAQFwCRAAAAAAgLgEiAAAAABBXmb0D8euvvy6rW0WsWLHinnvu+eGHH8r2tgAAAADAviuzALFLly5ldavCwsLnnntu0KBBOTk5sf3169d/8skny+opAAAAsI9Cjw6twKeHBw2swKcDlFmAWFbmz59/0003ffXVV0X6r7vuuj//+c916tSpkKoAAAAA4Oh0CL0DcdeuXQ8++GCHDh2KpIctW7YcN27cP/7xD+khAAAAABxkh8oMxMmTJ998880LFiyI7UxMTPz1r3/90EMPVatWraIKAwAAAICjWcUHiFu3bh00aNBzzz0XDodj+zt06PDiiy927NixogoDAAAAACp4CfN7773XunXrZ599NjY9rFq16p/+9Kdp06ZJDwEAAACgYlXYDMQ1a9bccccdb731VpH+rl27/u1vf2vZsmWFVAUAAAAAxKqAGYjhcPill15q1apVkfSwTp06L7/88rhx46SHAAAAUN5q164dCoVCodA111xT0bUAh7SDPQNxyZIlP/vZzyZMmFCkv2/fvsOGDUtNTT3I9QAAAAAAJTh4AWJ+fv7QoUMfeuihnTt3xvY3bdr0ueee69Wr10GrBAAAAKhYw4cPX758eRAEvXr1OuOMMyq6HKAkBylAnD59+k033TRr1qzYLeib7gAAIABJREFUzoSEhNtuu+2RRx6pXr36wSkDAAAAOBSMGDEisjyxXr16AkQ4xJV7gLh9+/YHHnhg2LBhBQUFsf1t27b9+9//3qVLl/IuAAAAAAAotfINEMeOHXvrrbf+8MMPsZ2VK1e+//7777333uTk5HJ9OgAAAABwgMorQFy/fv1dd901YsSIIv3nnnvu3//+9xNOOKGcngsAAAAAlKGE8rjp66+/3qpVqyLpYa1atf72t79NmDBBeggAAACUwubNm1esWFHRVcBRp4wDxB9++KFnz54DBgxYv359bP9ll122YMGCn/3sZ6FQqGyfCAAAAFSgDRs2PP300z169GjevHnVqlUbN2587rnn3n777fPnz99z8JAhQ0KhUCgUiuygEgTBnXfeGek5//zzIz2vv/56pOfnP/95pGfhwoVXXnllo0aNateuPXXq1CL3LCwsfO+992655Za2bdumpqZWqlQpPT399NNPv/zyy0eNGrV79+6S61+wYMGvfvWrHj16HHfccVWrVm3ZsmXXrl1vu+22RYsWHcjHAkeSMlvCXFBQ8NRTT/3ud7/bvn17bH+jRo2eeeaZPn36lNWDAAAAgEPE008/ff/992/evDnas2rVqlWrVn355ZdPP/30RRdd9PLLL6elpR3II8aMGdOnT5+8vLxiz06fPv3aa69dsGBBbOfKlStXrlz5zTffjB49+u67737hhRd69+6957Vr1qy5884733rrrcLCwmjn8uXLly9f/tlnnz3//PMDBgx4/vnnq1SpciD1wxGgzALEM844Y9q0abE9oVDolltuGTJkSM2aNcvqKQAAAMChIBwO/+IXv3j++edjO0OhUDgcjh5+8sknXbp0+eijj9q0aRPpadu27fXXXx8EwZgxY9asWRMEwWmnnda6desgCE466aQ9nzJ16tRoehgKhRo0aFCrVq3o2a+++urCCy/csWNH7CUJCQmxgeDq1auvuuqqf//736eddlrssB07dlxyySVFoozYawsKCl555ZXk5OS///3v+/qhwBGqzALEIn/kgiCoUqXK+PHjO3XqVFaPiFiyZEnZ3hAAAADYX0888UQ0PWzQoMGDDz545plnnnjiidnZ2bNmzfrrX//66aefBkGQkZHRq1ev+fPnp6SkBEHQq1evXr16BUFw/vnnRwLEq6+++le/+lWxj9i+ffuAAQPy8vK6des2ZMiQNm3aVKpUKXp29+7dP/vZzyLpYVJS0m233Xbttde2bNmyVq1amzZtWrx48YgRI5599tlwOJybmzto0KDPPvss9uZ33HFHNMoYMGDArbfe2rp162OOOSY7O3vixIkPPvhgZAn2iy++ePnll/fo0aOsPz84nJTXLsxBEOzYsWPp0qXld38AAACgQnz//fe//e1vI+2LLrpo1KhR0YmB6enp6enpF1988d/+9rdbb701CILMzMwHHnjgiSee2N+njBo1Kj8///HHHx84cOCeZ6dNmzZ37txI+29/+9sNN9wQPVW7du0uXbp06dKlWbNm9957b2RwYWFhQsL/bQWRm5v72muvRdp33nnnX/7yl+i1aWlpV1xxxbnnnnvyySdHNniYMGGCAJGjXLnswgwAAAAcwZ588sldu3YFQdCwYcMRI0bELiuOuuWWW6655ppI++mnny6y0Hhf5Ofnt23b9q677ir2bDQ9TE1N/elPf1rsmKuuuirSyMnJycrKivZnZGTs3Lkz0u7Xr9+eF6alpfXr1++444477rjj1q5du7+VwxGmHGcgAgAAAEeecDg8cuTISHvQoEF169aNN/Lhhx8eMWJEEAS7du2aNGlSt27d9vdZDzzwQHTaYBF9+vQ566yzgiBISUkJhULFjklOTo4tO9qOrXnmzJlFXo8Y8de//nV/q4UjVZkFiNGpvwAAAMARbO7cuRs2bIi0L7jgghJGNm/evHbt2ps2bQqCYPLkyaUIEE855ZR4p1JTU1NTU0u4dteuXX/+85/jXdukSZMVK1YEQfCrX/1q9erVP//5zw9wt2g4gpVZgNi/f/+yuhUAAABwyIrsLhIEQSgU+vOf/xxvhmBE9Ozq1av390EJCQnNmjXbx8E5OTlLlixZvnz5Dz/8kJGRsWjRomnTpkWyy2K9+OKLF110UWFhYV5e3kMPPfTwww+3a9fu7LPP7tKly2mnnXbiiSfub7VwBLOEGQAAANgP0emH4XB4+PDh+3hVTk7O/j4oLS0tdtvlYi1evHjYsGFjx45dtmzZft28e/fuY8eOHThw4KxZs4IgCIfDs2bNmjVr1jPPPBMEQXp6eu/eva+88srzzz9/f8uGI49NVAAAAID9kJeXV4qrIpuu7JfKlSuXPGDQoEFt2rR59tlno+lhKBRq3Ljx2WeffcMNNzzzzDORcDCerl27fvvttx988MH111/ftGnT2FNZWVnPP//8BRdccMkll6xcuXJ/K4cjjBmIAAAAwH6oU6dOpFG7du2NGzdWVBn/+7//+9hjj0Xa6enpt9566znnnNOhQ4caNWpEx2zZsqXkmyQkJPTu3bt3795BEGRmZn799ddff/31xIkTv/3228imKx988MHatWsnT56clCRC4ejl2w8AAADshyZNmkQamzZtysnJiQ3sDpoNGzYMHTo00v7xj388evTo2A2XS6dp06ZNmza98sorgyDIzMy8++6733777SAIpk6d+vbbb/ft2/cA7w+HLwEiAAAAsB+6dOmSnJy8e/fuIAgmTJjw4x//ON7I3Nzcp556KtK+8cYb69WrV1Y1zJgxIzc3N9J+6qmn4qWH8TZRef/99xcsWBAEQfPmza+66qo9BzRt2nTUqFHTpk3LyMgIgmDmzJkCRI5mAkQAAABgP6SkpHTt2vWTTz4JguDBBx/s1atXYmJisSP/8pe//O53vwuCoFmzZvfcc08Z1hBdOp2QkNCwYcN4w959991i+2fMmPHwww8HQdCwYcNiA8QgCJKSkmrVqhVpl+IFjnAksYkKAAAAsH8GDhwYaXz77bc33nhjZDZiER9//PEf/vCHSPuGG25ISCg+gigoKChFAe3atYs0CgsLP//882LHjBw58t57740eRt5pGNG5c+dIY/Xq1S+//HKxl3/++eezZ8+OtNu3b1+KIuGIIUAEAACAo1pOTs6yfbN58+bIJRdccMGAAQMi7VdeeaVjx44jRozIzs4Oh8O5ubnffvvtrbfe2qdPn507dwZBcPzxx//yl7+M9/QZM2aUouaTTjqpbt26kfa11147evTowsLCyOG2bdsmTJhw7rnn9u/fPzbZjM0Zzz777LS0tEj7hhtuuOqqqyZOnLhmzZrI5d99990999xz8cUXRwY0aNDgJz/5SSmKhCNGKDaAByCqsLAwdke5qlWrpqSkVGA9cIgLPTq0oksAODyEBw2s6BIojYr9X7py+trUrl07Ggjuo8cee+y+++6LtLdt29a7d+8vvvgidkBSUlJ+fn5sT1pa2pQpU1q2bFnkVtdff/0rr7wSaTdt2rRmzZonnHDC6NGjgyB4/fXXI+lk8+bNly9fHq+Yd99999JLL40eVqtWrUmTJrm5uStWrIj0hEKhBx54YOTIkUuWLAmCICEhoVOnTjfffPPNN98cBMFnn33WvXv3aOwYr/6qVat+8MEHF1544d4+GziSmYEIAAAA7Lfq1at/+umnd9xxR+wGJkXSt0svvfTLL7/cMz0MgmDAgAHRRc2ZmZlz586N/e/3+6JPnz5PPPFE9D/z5+bmLlq0KJoeHnfccR999NGDDz54xRVXRHoKCwunTZu2ePHiyOGFF1746quvRneULrb+rl27Tpw4UXoINlEBAAAASqNSpUrDhg371a9+9dprr40dO3b58uUbNmxo0KDBCSeccOKJJ/70pz/t1KlTvGu7du36/vvvDxkyZP78+Vu2bDnmmGNOPPHE/S3grrvu6tev39ChQ2fOnLl48eL169enpaV16NDhsssu69evXyTZfOCBB7Zt2/b222+vW7euQYMGsU/p37//FVdc8fLLL3/22WeZmZkZGRmbN29u2rRpixYtjjvuuOuuuy76qkQ4ylnCDFA8S5hhv1jCDLCPLGE+TB2RS5gB9pElzAAAAABAXAJEAAAAACAuASIAAAAAEJcAEQAAAACIS4AIAAAAAMQlQAQAAAAA4kqq6AIAAADgUBceNLCiSwCoMGYgAgAAAABxCRABAAAAgLgEiAAAAABAXN6BCAAAAHsxtOefKvDpA8fcW4FPBzADEQAAAACIS4AIAAAAAMQlQAQAAAAA4hIgAgAAAABxCRABAAAAgLgEiAAAAABAXEkVXQAAAABwSMjLy/viiy8+/PDD6dOnr127ds2aNYmJiWlpaWlpaaeffnqvXr3OPvvsSpUqVXSZwMEmQAQAAICj3Y4dO5566qnHHnts06ZNRU7l5OQsXbp08uTJTzzxRL169QYPHvyLX/yicuXKFVInUCEEiAAAAHBUmzJlypVXXrly5cq9jly/fv1dd901bNiwt99++9RTTy2neoYPH758+fIgCHr16nXGGWeU01OAfSdABAAAgKPXyJEjb7jhhry8vMhhYmLi2Wef3bt371atWjVs2LCgoGDt2rVz5sz58MMPv/rqq3A4HARBRkbGj370oxEjRlx22WXlUdKIESMmTJgQBEG9evUEiHAoECACAADAUWrs2LHXXHNNYWFh5PDiiy9+/PHHW7VqVWRY7969Bw0aNHPmzIEDB37++edBEOTm5l511VWff/75Oeecc7CLBg46uzADAADA0SgzM7N///7R9PCRRx758MMP90wPozp06DB+/Pjf/OY3kcP8/Py+fftmZ2cfjFqBCiVABAAAgKPRwIEDN2zYEGn/4Q9/GDx48F4vCYVCjz766MCBAyOHq1at+t3vfleOJQKHBgEiAAAAHHUWLFgwevToSPv8888fNGjQvl/7xz/+sWPHjpH2K6+8si+7rxwEmzdvXrFiRUVXAUcmASIAAAAcdZ588sno4uU//vGPCQn7kQ8kJyc//PDDkfauXbueeeaZ2LP3339/KBQKhUJXXHFFCTe59NJLI8MeeuihSM+QIUMiPZEdVIIguPPOOyM9559/fqTn9ddfj/T8/Oc/j/QsXLjwyiuvbNSoUe3atadOnbrng6ZPn37PPfd07NgxLS2tcuXKDRs27Ny5829+85uZM2fu+48MRzkBIgAAABx1xowZE2mcfvrpp59++v5e3qtXr+OPPz7SHjt2bFlWtj/GjBnTvn37t956a/Xq1XueXb9+/RVXXNG5c+ehQ4fOnDkzOzt7165da9asmT59+pAhQzp16tS3b99NmzYd/LLhsGMXZgAAADi6LFq0KDMzM9Lu1atXKe4QCoV69uy5ZMmSIAi+++67jRs31qlT5wCratu27fXXXx8EwZgxY9asWRMEwWmnnda6desgCE466aQ9x0+dOrVPnz55eXmReho0aFCrVq3o2aysrAsvvHDx4sVFyg6Hw5F2OBx+4403Zs+ePX78+EaNGh1g8XBkMwMRAAAAji6zZs2Kts8999zS3eScc86JNAoLC8tkOXCvXr1efvnll19+ORoXXn311ZGe++67r8jg7du3DxgwIC8vr1u3bt9+++3OnTtXrVrVtWvXyNmCgoK+fftG08OTTjrplVdemTdv3s6dO+fMmTN8+PBjjz02cmrBggXXXHNNNFUEiiVABAAAgKNLdnZ2tN2sWbPS3aRFixbR9vr16w+0pv00atSoJUuWPP74459++mmHDh0qVaoUe/bFF1+cPHlypH3FFVdMmzbt2muvbd26daVKlU4++eSf/vSnM2bM6N27d2TA559/PnLkyINcPxxeBIgAAABwdFm3bl20Xbdu3dLdJPbC2BseHPn5+W3btr3rrruKPfvkk09GGunp6SNGjKhevXqRAbVq1Ro1alS9evUih8OGDSu/UuEIIEAEAACAo0uZrNiNnfQXeRHhQfbAAw8Uu3n0woULFy5cGGnff//9lStXLvby6tWrDxw4MNKeNm3aqlWryqlOOAIIEAEAAODoUr9+/Wh7w4YNpbtJ7KzDCtmE5JRTTim2f9KkSdF23759S7hD//79o+0pU6aUVWFw5BEgAgAAwNElNTU12o5ux7y/srKyou3GjRsfaE37KSEhId7bG5cvXx5p1K9fv2bNmiXcpHHjxtH5idGrgD0JEAEAAODo0rZt22j7yy+/LN1NJk6cGG1HNzU+aNLS0opsnBK1cePGSKNly5Yl3yQUCjVv3rzIVcCeBIgAAABwdGndunV00fEnn3xSupuMGTMm0jj11FMP/gzEeG823F/RFHL37t1lckM4IgkQAQAA4KjTo0ePSGPy5MnTpk3b38vHjRs3Z86cSPuyyy4rRQG5ubmluGpf1KlTJ9L4/vvv9zo4OqbUu1HD0UCACAAAAEedO+64I9oePHjwfu3LnJ+f/7vf/S7Srly58tVXX12KAqIbJZe56KrkdevW5eTklDBy9erV27dvj7TjvVERCASIAAAAcBRq37597969I+3x48cPGTJk368dPHjw1KlTI+277747XvSWl5cX7w4bNmxYsWLFvj9xv5x11lnR9ptvvlnCyLfeeivaPvvss8upHjgCCBABAADgaPTnP/85uknx4MGDH3/88b1eEg6HY0c2btx48ODBRcYkJPxf1DB//vx493n44Yf3a87jfmnVqtUJJ5wQfdCuXbuKHbZ9+/ZHHnkk0u7QoUPTpk3LqR44AggQAQAA4Gh0/PHHv/LKK6FQKAiCcDh877339unTZ/HixfHGf/fdd926dXv00Ucjh7Vq1XrvvfdSUlKKDGvVqlWksWzZsvfff3/P+4wbN+6ZZ57ZlwoLCgr2ZVgRoVDozjvvjLQzMzOvv/76Pd+3uHXr1gEDBmRnZ0cO77777lI8CI4eAkQAAAA4SvXp0+eFF15ITk6OHL733ntt2rTp1q3bsGHDxo0bN3v27FmzZo0dO/bxxx8/99xzO3bs+Nlnn0VGpqSkfPzxx506ddrznqeddlq0fd11173wwgvRDY4zMjJ+85vf9OzZcx+TwRkzZpTu57r55ptPP/30SHvUqFFdunQZNWrUkiVLCgoKFi1aNGLEiE6dOr377ruRAd26dSvdaxzh6JFU0QUAAEeCx78orOgSAA4Tgyq6APhvN910U8uWLfv16xeZjpefnz9+/Pjx48eXcEnbtm1fe+21du3aFXu2ZcuWd9xxx1//+tcgCDZv3nzLLbfcdtttLVq0WL9+/caNG6PDunbtGu8p0Zcqjhw5ctKkSTVr1jzhhBNGjx697z9UUlLSG2+8ceGFFy5dujQIgrlz50YiwoSEhMLC//pLS7t27V577bXINEwgHjMQAQAA4Kh2wQUXLFu27OGHH46+EjGe9PT0IUOGTJs2LV56GDF06NArr7wyerh79+7FixfHpoe//e1vBwwYEO/yAQMGRF+kmJmZOXfu3Nhr91HTpk2nTJly6aWXxnbGpoehUGjAgAFffvllamrq/t4cjjYCRAAAADjaVa9e/f7771+zZs1HH330y1/+skuXLs2bN69WrVrVqlWbNGnSpUuXX//61++///73339/7733Vq5cueS7JScnv/HGG1999VX//v07deoUm0vWqVNnxIgRf/jDH0q4vGvXru+///4555xTt27dpKSkevXqnXjiiaX4oerXr//OO+9MnTr17rvvbt++ff369ZOTk1NTUzt16nTfffd99913I0aM2GtmCgRBECq/bY8ADmuFhYWx/52zatWqe74fGoga2vNPFV0CwOFh4Jh7K7oESqNi/5fuCPjarF27duHChbVq1Wrbtm1iYmJFlwPsH+9ABAAAAMpXWlpaWlpaRVcBlJIlzAAAAABAXAJEAAAAACAuASIAAAAAEJcAEQAAAACIS4AIAAAAAMRlF2YAAADYi4Fj7q3oEgAqjBmIAAAAAEBcAkQAAAAAIC4BIgAAAAAQlwARAAAAAIhLgAgAAAAAxCVABAAAAADiEiACAAAAAHEJEAEAAACAuASIAAAAAEBcSRVdwKFo165dDz74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lGs0GvsOBgAAoL3TmEwme48BAAAAAAAAQBvFJcwAAAAAAAAAVBEgAgAAAAAAAFBFgAgAAAAAAABAFQEiAAAAAAAAAFUEiAAAAAAAAABUESACAAAAAAAAUEWACAAAAAAAAEAVASIAAAAAAAAAVQSIAAAAAAAAAFQRIAIAAAAAAABQRYAIAAAAAAAAQBUBIgAAAAAAAABVBIgAAAAAAAAAVBEgAgAAAAAAAFBFgAgAAAAAAABAFQEiAAAAAAAAAFUEiAAAAAAAAABUESACAAAAAAAAUEWACAAAAAAAAEAVASIAAAAAAAAAVQ72HgAANEtxcfHs2bOltpOT04cffhgaGmrNhv/4xz+2bNkihIiJiVm+fHkLDhEAcDPKysoOHDhw8eLF1NTUkpKS8vJyDw8PPz8/X1/fvn37xsXFderUSW3bb775Zu3atUKIfv36vfbaa604agAAgI6MABFAx1FTU7Ny5cpXX31Vo9HYpMO6urpPP/10//79Go1mwIABEyZM6N+/v0ajMRgM8+fPz83NnTt37rRp02yyLwBAVVXVF198sX379pqaGuXzer1er9dfuXLl1KlT69at69u378KFC638cxEAAACajwARQIdy/vz5+Pj4CRMm2KS3zz777KeffpLa+/fv379/v7e3d69evXJycnJzc4UQ/fr1s8mOAADXr19funRpdnZ2o5UXLlz44x//+NRTT40ZM6blxwUAAAACRAAdzqeffjp48GBfX99m9qPX67du3SqEiIiICA8PP3PmTGlpqV6vP3LkiFQwaNCg6Ojo5g4XACBETU3NSy+9JKeH7u7uU6ZMue222zp16uTj46PX669du5aenr5ly5a0tDQhRFVV1fvvvx8cHNyzZ0+7DhwAAOCWQIAIoKMpLy9fvXr14sWLm9nPhQsXdDqdl5fX22+/7erqajAYTp48uWfPngsXLhgMhkGDBv3hD3+wyYABAN98801mZqbUHjx48Isvvuji4iK/GhgYGBgY2Lt370mTJh08eHD58uUGg8FoNL777rsrVqxwdXWVK6dNm3b33XcLIbRalgoEAACwGQJEAB1H586ds7KyhBCHDh06duzY0KFDm9NbbGxsbGys/FCn0w0dOrSZfQIA6jOZTDt27JDaERERixcvdnZ2brBSo9HExcUVFxd/8sknQoj8/Py9e/dOmTJFLtDpdDqdrhXGDAAAcEvhb7MAOo6ZM2f6+/tL7Y8//riiosK+4wEAWCMzM7OgoEBqx8XFqaWHsnvvvTcgIEBqHzp0qGUHBwAAAAJEAB2Ju7v7k08+KbWvX7++bt06+44HAGANOT0UQkRGRlqzSbdu3epv2wQ1NTV6vd5gMDSnEwAAgA6PS5gBdCjDhg2LjY2VJqRs27ZtzJgxzbm/vslkOnbs2IkTJxITE4uLi8vKynx8fPz9/QMCAkaMGBEbG9vohXIpKSkHDhw4e/ZsQUFBeXm5p6env7//gAED4uLioqKimjwwAOhIlLc7tGYVZiHEjBkzhg8fLoRQ3gBRCPHjjz9KVzf369fvtddeU7509OhR6ZkxY8Y8//zzubm5n3zyydmzZ2tqaoQQnp6egYGBsbGxd911l7u7u7RJeXn5tm3bjhw5kpeXV1lZ2alTp5CQkMmTJw8ePLhZbxgAAKC9IUAE0NHMmzfvzJkz5eXlJpNpxYoVH3zwgYNDUz7rUlJS3nvvvYyMDOWTBQUFBQUFSUlJhw8f/uc//7lw4cIhQ4Y0uHlJSclHH31kdm1dUVFRUVFRSkrKt99+O3LkyPnz53t4eDRhbADQkXTu3Fluf/PNN7GxsYGBgZY3iYqKas6fYRISEpYtW1ZZWSk/U1paWlpaevny5V27dr388sshISHnz59fvny5coZjRkZGRkbGsWPHhg8fvmTJEo1G0+QBAAAAtC9cwgygo/H19Z0zZ47UzsjI2LRpUxM6SUxMXLJkiVl6aPZdsaio6O23305KSqq/+fXr1xcvXmyWHio3N5lMBw4cWLx4cWFhYROGBwAdiaenZ9++faW2Xq9/+umnv/32W71e30K7y83Nff3116X0UKPRBAcHm02BfOutt06dOvW3v/1NSg+dnJyCg4OVyzr/8ssv//73v1toeAAAAG0QMxABdEATJ07cu3dvQkKCEGLTpk0jR47s0qWL9ZsbDIaVK1dKF7XpdLq77777zjvvDA4OdnNzKysry87O3rNnz9atW00mU3V19bp161599VXl5kaj8Z133pHWgxZChIWFPfDAA926dQsJCcnKykpOTt64cWNubq4QIiMjY/ny5a+88grTWADc4ubNm/fcc89J9yKsqKj4/PPP165d27t379tvv71v377dunWz4drKiYmJQggXF5fHH3989OjRbm5uJpPp3LlzK1asyM/PF0Jcvnz5r3/9qxAiJCRkwYIFffr00el0NTU133///VdffSUNcuPGjffdd5+thgQAANDGESAC6IA0Gs3ChQufeeaZ2traurq6//u//3vzzTetD+mSk5PT0tKk9oIFC8aPHy+/5OHh0b179+7duwcGBn7++edSsclkUna+Y8eOS5cuSe3Y2Nhnn31WntsSERERERExYsSIv//978ePHxdCnDt3bt++fWPGjGnmWwaAdi0yMvK111576623ioqKpGdMJlNCQoL0pyAXF5fevXv379+/X79+0dHRysmATePs7Pzuu++Gh4dLDzUazYABAxYtWvTiiy+aTCbpyaioqDfffFP+AHdycnrooYfKysq+//57IURpaWlRUZGvr28zRwIAANAucAkzgI6pc+fOM2bMkNqXLl3avn279dvK6aG3t/e4ceMarImLi5MalZWV169fV74kX9cWEBDw/PPPK6+Mk7i5uS1atMjLy0t6+OOPP1o/NgDoqHr37r1ixYo5c+bIuZ6sqqrq1KlTn3/++QsvvDBr1qwPP/xQmkXYZI8++mj9vfTo0UMZKS5cuLD+B/ikSZPktpXrvQAAAHQAzEAE0GHdf//9Bw4ckNLAtWvXDh061N/f35oN77jjjl69egkhXFxc1OYtKhdmkaerCCEyMzMzMzOl9owZMxwdHRvc3MXF5Te/+c3atWuFEMnJyYWFhX5+fla9KwDouLy8vKZPnz59+vTMzMzz589fuHDh/PnzxcXFypqKior4+Pj4+PiePXu++OKLAQEBTdiR/EcgM6GhodJPjS5dusTExNQvkG6GaDQahRB1dXVN2DUAAEB7xAxEAB2WTqd7+umnpQSwoqLi448/tnJDb2/v8PDw8PDwoKCgBgvq6uqkS9jqu3jxotxW+4IqGT16tNyWL3kGAAghwsLCpkyZsmjRonXr1q1atWr+/PlxcXHyxG1JYmLic889l5KScrOde3p6qv3NxtnZWWp07dq1wQKdTqf8AxIAAMAtgl+AAHRk3bt3v+eee6RrhI8ePXro0KHY2Nib7aSysjI7OzsvLy8/Pz8/P19aCKWsrKzB4ry8PKnh7e3t5uZmoVt/f39HR8fa2lrlVgAAM2FhYVKeaDQaExISdu/evXv3bmnqt16v/+CDD95///2bWmLFmgTQw8Oj6SMGAADocAgQAXRwjz322C+//CLdpnD16tUDBw50d3e3ZsOsrKwff/zx1KlT0orJVpKDxU6dOlmu1Gg0QUFB0mLNanEkAECm1Wr79evXr1+/e+6557XXXpM+2NPS0uLj45W3JgQAAIDNcQkzgA7OxcXlqaeektpFRUWfffaZNVutW7du4cKFW7duldNDjUbj7+/fu3fv8ePHP/nkkx9++GHzxybPguFGWgBuWeXl5dtvkJdgtiw6OvpPf/qT/LCZC6oAAACgUcxABNDxDR48OC4u7sCBA0KInTt3jhkzpm/fvhbqv/zyy82bN0vtgICAyZMn9+nTJyoqytXVVa6pqKhocFv5qjdrrkqWa8xu7AUAt46qqqpVq1ZJbTc3t1GjRlmzVUxMTEhISE5OjhAiPT29BccHAAAAZiACuEXMmzfP09NTCGEymVauXFlTU6NWWVpa+t1330ntoUOHfvLJJw899FCfPn2U6aEF8rorer2+srLSQmVRUVFVVZXUDgwMtKZzAOh4fHx85OnY0l0drCTfj8LFxcX2wwIAAIACASKAW4K3t/fjjz8utbOysr7++mu1ypSUlOrqaqk9b948tRvzq921sHfv3nL74MGDFoakfFW5FQDcUnQ6XUxMjNTevn272vxuM+Xl5fLEwy5durTU4AAAACCEIEAEcOsYP358//79pfa333579erVBsvkZFCj0fj5+an1duTIkQafDwsL69y5s9TesGGD2s0Nq6qqNm7cKLWjoqKYgQjgVnbfffdJDevvVPvZZ5/Jc8mtvOoZAAAATUaACOAWsmDBAicnJyGEwWBISEhosCYyMlJqmEymc+fONVizb98+ta+4Go1m6tSpUvvatWvvv/++PJ9RVlFRsXz5cr1eLz2cNm3azb0NAOhYRowYERUVJbV//vnn999/v7S0VK24trZ27dq1O3bskB727duXSdwAAAAtjUVUANxCQkJCHn744bVr11qoCQsL8/T0lL67vvfee/Pnzx8+fLhGoxFCVFVVJScnf/nll2bh47lz58aPHy8/nDhx4u7du3/99VchxP79+9PS0h588MGYmJjg4OCcnJykpKQNGzZIN/4XQgwcOHD06NE2f6cA0I5oNJrnn3/+z3/+s/SXld27dx8+fHjkyJG9e/cOCQmRFqcqLi4uLi5OSkrau3evHC+6ubktXLjQnkMHAAC4NRAgAri1TJs2bf/+/VeuXFEr0Gg0Tz/9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" alt="Conhecimento em outras línguas por área de formação" width="864" />
<p class="caption">
(#fig:area_linguas)Conhecimento em outras línguas por área de formação
</p>
</div>
<p><br></p>
<div class="figure"><span id="fig:fluxo-1"></span>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABsAAAASACAIAAADOHB9sAAAACXBIWXMAAB2HAAAdhwGP5fFlAAAgAElEQVR4nOzdeXhU9aH4/89ksrCERaXVqmVRFgUrty7Vql8Qt1a45bmtWvWnFSlKBS0ufQSuWotPFbQuF/GCuNGC0FoUrRZ5nqpV1NJy9VJFCqgVkV3RCgIhZJ3fH6d3bm7gQEgmmWTyev3hM5xz8pnPJM4keedzziRSqVQAAAAAANiTvGxPAAAAAABovgREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABArP9sToEGqqqoqKipCCAUFBclkMtvToVGkUqmysrLCwsK8PMU/N1VXV5eXl4cQkslkQUFBtqdDY9m1a5fX6hwWvVaHEPLy8goLC7M9HRpLWVlZXl6e1+octmvXrhBCIpEoKirK9lxoLNHPXV6rAfaLHtGylZeX79ixY8eOHVFGJCdVV1fv2LGjsrIy2xOhsVRWVkZP5OjHWXKVL3Fui16rd+zYEdUHctXOnTs9kXNb9ETeuXNntidCI9q1a5fXaoD9JSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiPW0fv369evXZ3sWAAAAANC48rM9gf3w8ssvT58+fcqUKYcccsjue3ft2jV79uzFixdv27btyCOP/Jd/+Zfzzz8/mUzW47DS0tJXX331o48+6tKly0knnfTVr3611iCbN28eM2bMZZdddvjhh2f2MQIAAABAs9KSAuKLL764a9euPe767LPPfv7zn69evTqE0KlTp+XLly9fvnzp0qX//u//3qFDh/06bM2aNT//+c83b94c/XPOnDlXXnnl4MGDa97dnDlzDjjggCFDhjTGwwQAAACA5qNlnMK8c+fOGTNmLF++PO6A//iP/1i9enW/fv1mzJjx+OOPT58+/atf/erf/va3xx57bL8Oq66uvueee7Zv3z527Njf/va3kydPPvLIIx955JEPP/wwPchHH320cOHCSy65pKCgoJEeLwAAAAA0E809IL700ktjx44dNmzY7373u7hj3n333WXLlhUXF990001dunQJIRx66KG33nprMpl85ZVXPv3007oftnbt2jVr1lxwwQWnnXZa27ZtjzjiiLFjx1ZVVf3lL39J393MmTO7du06aNCgxn3kAAAAANAMNPeA+NFHH23cuLGoqKhjx46JRGKPx/z5z38OIZxwwgk1z1Y++OCDjz766FQqtXjx4roftn379hDCgQcemD6gc+fOyWRy69at0T+XLVu2ZMmSYcOGxU0GAAAAAHJJcw+IV1xxxez/UTP81bRq1aoQwnHHHVdre7Ql2lvHw4488siioqLf//73O3fujPY+9dRTVVVV/fr1i/45c+bMfv36nXDCCZl4cAAAAADQ3LWkN1GJs3HjxhBCdFZyTdGWDRs21P2wdu3ajRgxYtq0aSNHjjz66KM//vjjNWvWHHvssQMHDgwhLFq06P3337/77rsb9/EAAAAAQLORCwGxpKQkhLD7+sTi4uIQQnotYR0P+/a3v92lS5ennnpq2bJlBx100EUXXXTBBRckEomqqqrZs2efcsopffr0aeCEt23blkqlGjhIpKqqKrpRWlpaVlbW8AG3bNkybty49JtQ00xE/8M4cb5ZKS4uvv3227t3797woaqrq6MbZWVllZWVDR+QZmvXrl3l5eXZngWNIv2dvbKy8osvvsjuZGg8VVVVGXytXrNmzc0337xjx46MjEZGpJ/Lfu5qVr785S/feeedNa801RDRUziDr9WJRKJjx46ZGg2gecqFgFhRURFCaNu2ba3t7dq1CyGks1odDwshnHDCCbufpPzCCy9s2rTplltuyciEMxUQ06qqqtIxsSFmzZo1d+7cho8DrUGXLl0yuyS5uro6HRPJSZl6raY580TOeRn8Et9///3z58/PyFCQ844++uhrrrkmgwNGvx5mhNwMtAa5EBA7dOiwdevW0tLSWtujRYXpJYd1PGyPysrKnnjiibPPPvuwww6LPmTWrFl//etfS0pK+vTpM2zYsG7dumXq4WRXtE4TqIuVb74/7+7nsz0LAFqqlW+8n+0pQIuRPmMMgKzIhYB44IEHbt26dfezP6ItBxxwwH4dtkfPPvvszp07L7744hBCWVnZT37ykw0bNvTs2fPggw9eunTp9ddff+edd/bu3bvuE67jkftUWloafStt3759mzZtGj5geoXmI488ct555zV8QMg9b7311plnnhlCyE/m776ouR6qqqqi01rz8/MLCgoaPiDNU2lpaUFBQX5+LnznZXepVGrXrl0hhGQyWVhYmO3p0Fh27dqVTCYz9VqdTCajGy+++OLxxx+fkTEhxzzzzDMjRowIIbRt2/aggw7KyJjbt28P+1pBAkAtufBrTOfOnUMIn3/+ea3tW7ZsCSGkv83U8bDdbdu27emnnx46dGgU/p5++ukNGzZcffXV3/rWt0IIa9euvfHGG6dPn37ffffVccIZXOKeHiqRSGRk2PQg7du333tUhVbrf3/cTGTm6VxzEKfA5Dxf4lxV8+Ikvso5L2Nf4v8ZpkOHDn7ugj1q3759dCNTv++kea0G2C952Z5ABnTt2jWE8Pbbb9favnTp0hBCjx499uuw3c2dOzeZTKaX4/3tb387+OCDo3oYDXvGGWesWrVq95OjAQAAAKCly4WA+I1vfCOE8N///d813whl27Zty5YtKywsHDhw4H4dVsvmzZsXLFjw/e9/P3qvlUitv1bl5eWFGu+jCgAAAAA5IxcC4jHHHNOnT58tW7ZMmTIlenfLsrKyO++8s6KiYsCAAelF73U8rJbZs2cfeOCBgwcPrnl3H3/88Ysvvhj9c8OGDS+//HKPHj3iRgAAAACAlisXroEYQrjhhhvGjh37+uuvL1mypGvXrh9++GF5efmhhx46fPjwehyWtnr16ldfffW6666reans733ve6+99toDDzzwwgsvFBcXL1u2rLq6etSoUY37CAEAAAAgG3JhBWII4Stf+cr9999/zjnntG3b9oMPPujcufO//du/3XfffbXeWquOh6XNnDmza9eup59+es2NRUVF99577+DBg7du3fr+++9/7Wtfu++++/r06dN4jw4AAAAAsqUlrUCcPXv2XvYeeOCB11xz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iouL27Rp07dv32HDhn3wwQd7fLCvvvrqqFGjBg0a9JWvfKVDhw5HH330kCFD5s2bV1VVtd+fOABoTAIiAADQLMyfP79///5TpkxZuXJlSUlJSUnJ+++//+CDD/bv33/SpEnpw9q2bfvYY48lEolVq1ZFBTDtiy+++PGPfxxCGDBgwDXXXNMEk6mptLR04MCBDz300LZt20II5eXlK1eunDVrVt++fV9++eWaR1ZWVv7gBz84/fTTp0+fvnDhwo8//njHjh3vvvvuggULzj///LPOOquioqIhkweAzBIQAQCA7Js/f/53vvOdzz77LD8/f/jw4Q8//PCMGTNGjhxZVFRUVVV10003zZ49O33wgAEDRo8eHUK4995733rrrfT2sWPHbty4sX379r/85S/3fvrw1KlTKysrb7311hBCp06dKisrKysrx44dW4/JpN18881Llizp3bv31KlTFy9evGDBggsuuCCEUFFRcemll1ZWVqaPnDx5cjRCjx497rjjjrlz5z755JOTJk3q06dPCGHhwoUTJ05swOcSADLMNRABAIAsq6qqGjduXAjhgAMOeOaZZwYOHBhtHz58+A9/+MOhQ4du3rz51ltv/f73v19YWBjtuvPOO+fPn79mzZoRI0a88cYb+fn5r7322iOPPBLtOuKII/Z+j3l5een/JhKJZDLZkMlEPvzww9NOO+3555/v2LFjtOXcc8+97LLLHn/88U2bNq1YseLYY4+Ntk+bNi2E0LNnzzfffLNz587pEa655prjjjvu73//+8svv/yzn/2sPp9KAGgEViACAABZNmfOnBUrVoQQbr755nSwi5x00km33XZbCGH16tUzZsxIby8uLo5y4VtvvXXfffeVlZWNHDkylUoNHDjw6quvbuLJRPLy8qZOnZquh5GRI0dGN9JXQiwvL6+srDz88MNHjx5dsx5GD+rMM88MIXz44YcNeQgAkFkCIgAAkGWLFi0KIXTo0OGqq67afe/w4cMPOuig9GFpZ5999ogRI0IIEyZMGDly5Hvvvde+ffsZM2Y08L2P6zeZEMI3vvGN9BrDtPQbQKdSqehGYWHh2rVr161bd/311+8+/qefftqQyQNAYxAQAQCALItW5/Xu3bt9+/a77y0qKurbt28IYdWqVbV23XvvvYceemhpaemsWbNCCL/4xS/2efJy400muoJhLdFZ0nuRSqU2bty4aNGixx577KKLLpo3b1495w0AjcY1EAEAgCyLml2PHj3iDujevfvrr7++e7Pr1KnT1KlTv/vd74YQTjzxxFGjRmVxMoccckjd72XlypUPPvjg66+//t5775WWltZvqgDQNAREAAAgy9Kn98bJz88PIezatWv3Xe+88050Y8WKFWvWrOnevXu2JlP3U6fvueee8ePHV1VVhRAKCgq+/vWv9+rVq0+fPqeccspzzz334IMP7v+sAaARCYgAAECW9erVa926dR999FHcAatXr44Oq7X9nXfeuf3220MIeXl5JSUlI0eOfOGFF7I1mTp65ZVXbrzxxhBCv379Jk6ceM4557Rp0ya99w9/+EP9hgWAxuMaiAAAQJb17NkzhPDee+/t3Llz970VFRXR2yL37t271vbLL7+8oqLixBNPfOCBB0IIL7744syZM7MymbqLLtdYVFT00ksvDR06tGY9DCFUVlbWb1gAaDwCIgAAkGXf/OY3Qwjbt29/6KGHdt/7q1/9avPmzSGEk08+ueb2iRMnvvXWW/n5+Y8++uioUaNOPfXUEMINN9zwySefNP1k6m7Dhg0hhO7du+9+zcRUKvXGG2/Ub1gAaDwCIgAAkGWXXnrpUUcdFUK4/fbbFy1aVHPXm2+++dOf/jSE0K1bt5EjR6a3L1269I477gghjBs37thjj00kEg899FBBQcHnn38+ZsyY/br3Wov+6jGZ/RKd+7x69epNmzbV3F5WVnbddddFATG6PCIANBMCIgAAkGX5+fl33XVXCOHzzz8/44wzfvSjH82cOfPxxx+/+uqrBwwYEK0onDRpUvps3/TJy717977llluijf369Rs3blwIYe7cuc8991wd7zeEsGPHjrlz565YsSJaG7i/k9lfQ4YMCSGUl5efeeaZv/71r995552FCxc+8MADxxxzzJQpU4qLi0MImzZtmjdv3rZt2+p3FwCQWQIiAACQfUOHDr3//vsLCgrKy8sffvjhyy+//LLLLps2bdquXbs6der0xBNPXHzxxemD77jjjrfffjuRSDzyyCM1Q97NN98cre8bPXr0F198sc87Pe6446IbF154Yb9+/WbPnl2PyeyvwYMHjx49OoSwcuXKSy65pH///oMGDRozZsyqVauuvfba3/zmN9Fh559//nnnnVfvewGADBIQAQCAZmHMmDHLly+/5pprjjrqqPbt27dr165Xr16jRo1aunTphRdemD5s6dKlEydODCFceeWVAwYMqDlCmzZtogsXbtiwIVqNuHfnnnvupEmTunXrVlhYeOihh37pS1/a38nUz9SpU+fPn3/OOed07dq1qKioa9eul19++ZIlSyZPnvyv//qv11577QEHHNCmTZtu3bo18I4AICPysz0BaO2uuOKKxx57LIQwfvz4SZMmZXs6AADZ1KtXr+j9lPeif//+5eXlcXsHDRqUSqVqbTz11FN33xgZP378+PHj6z2ZyPbt2+N2HXbYYXu86yFDhkTnMu9u8uTJkydPrsv9AkDTEBAhm55//vmoHk6aNCn9k+u6devWrl2bTCbr/dZ+AAAAAJniFGbImn/84x9XXHFFXl7etGnTav7de8aMGaeddtq5556bxbkBAAAARKxAhKwZNWrUZ599NmvWrEsuuSTbcwEAAADYMysQITtSqdTdd9+9fv169RAAAABozqxAhOxIJBJN/LZ6FRUV5eXl7dq1SyQSTXm/AAAAQItmBSLs28aNG6+99tq+ffsWFxcXFxf36dNn9OjRy5cvr3lMaWlpr169EolEz549S0tLa43w9NNPJxKJRCJR8438Fi1aFG1csmRJtGXUqFGJRGLChAkhhK1bt0Z777rrrv2dTKRDhw6JROLZZ58tKSm56qqrunTpUlxc3KZNm759+w4bNuyDDz7Y44N99dVXR40aNWjQoK985SsdOnQ4+uijhwwZMm/evKqqqv3+xAEAAAAtn4AI+zB//vz+/ftPmTJl5cqVJSUlJSUl77///oMPPti/f/9JkyalD2vbtu1jjz2WSCRWrVoVFcC0L7744sc//nEIYcCAAddcc00TTKam0tLSgQMHPvTQQ9u2bQshlJeXr1y5ctasWX379n355ZdrHllZWfmDH/zg9NNPnz59+sKFCz/++OMdO3a8++67CxYsOP/8888666yKioqGTB4AAABoiQRE2Jv58+d/5zvf+eyzz/Lz84cPH/7www/PmDFj5MiRRUVFVVVVN9100+zZs9MHDxgwYPTo0SGEe++996233kpvHzt27MaNG9u3b//LX/5y76cPT506tbKy8tZbbw0hdOrUqbKysrKycuzYsfWYTNrNN9+8ZMmS3r17T506dfHixQsWLLjgggtCCBUVFZdeemllZWX6yMmTJ0cj9OjR44477pg7d+6TTz45adKkPn36hBAWLlw4ceLEBnwuAQAAgBbJNRAhVlVV1bhx40IIBxxwwDPPPDNw4MBo+/Dhw3/4wx8OHTp08+bNt9566/e///3CwsJo15133jl//vw1a9aMGDHijTfeyM/Pf+211x555JFo1xFHHLH3e8zLy0v/N5FIJJPJhkwm8uGHH5522mnPP/98x44doy3nnnvuZZdd9vjjj2/atGnFihXHHntstH3atGkhhJ49e7755pudO3dOj3DNNdccd9xxf//7319++eWf/exn9flUAgAAAC2WFYgQa86cOStWrAgh3HzzzelgFznppJNuu+22EMLq1atnzJiR3l5cXBzlwrfeeuu+++4rKysbOXJkKpUaOHDg1Vdf3cSTieTl5U2dOjVdDyMjR46MbqSvhFheXl5ZWXn44YePHj26Zj2MHtSZZ54ZQvjwww8b8hAAAACAlkhAhFiLFi0KIXTo0OGqq67afe/w4cMPOuig9GFpZ5999ogRI0IIEyZMGDly5Hvvvde+ffsZM2Y08L2P6zeZEMI3vvGN9BrDtPQbQKdSqehGYWHh2rVr161bd/311+8+/qefftqQyQMAAAAtl4AIsaLVeb17927fvv3ue4uKivr27RtCWLVqVa1d995776GHHlpaWjpr1qwQwi9+8Yt9nrzceJOJrmBYS3SW9F6kUqmNGzcuWrToscceu+iii+bNm1fPeQMAAAAtnGsgQqyo2fXo0SPugO7du7/++uu7N7tOnTpNnTr1u9/9bgjhxBNPHDVqVBYnc8ghh9T9XlauXPnggw++/vrr7733Xmlpaf2mCgAAAOQSARFipU/vjZOfnx9C2LVr1+673nnnnejGihUr1qxZ071792xNpu6nTt9zzz3jx4+vqqoKIRQUFHz961/v1atXnz59TjnllOeee+7BBx/c/1kDAAAALZ6ACLF69eq1bt26jz76KO6A1atXR4fV2v7OO+/cfvvtIYS8vLySkpKRI0e+8MIL2ZpMHb3yyis33nhjCKFfv34TJ04855xz2rRpk977hz/8oX7DAgAAAC2dayBCrJ49e4YQ3nvvvZ07d+6+t6KiInpb5N69e9fafvnll1dUVJx44okPPPBACOHFF1+cOXNmViZTd9HlGouKil566aWhQ4fWrIchhMrKyvoNCwAAALR0AiLE+uY3vxlC2L59+0MPPbT73l/96lebN28OIZx88sk1t0+cOPGtt97Kz89/9NFHR40adeqpp4YQbrjhhk8++aTpJ1N3GzZsCCF0795992smplKpN954o37DAgAAAC2dgAixLr300qOOOiqEcPvtty9atKjmrjfffPOnP/1pCKFbt24jR45Mb1+6dOkdd9wRQhg3btyxxx6bSCQeeuihgoKCz3OlVXMAACAASURBVD//fMyYMft177UW/dVjMvslOvd59erVmzZtqrm9rKzsuuuuiwJidHlEAAAAoFURECFWfn7+XXfdFUL4/PPPzzjjjB/96EczZ858/PHHr7766gEDBkQrCidNmpQ+2zd98nLv3r1vueWWaGO/fv3GjRsXQpg7d+5zzz1Xx/sNIezYsWPu3LkrVqyI1gbu72T215AhQ0II5eXlZ5555q9//et33nln4cKFDzzwwDHHHDNlypTi4uIQwqZNm+bNm7dt27b63QUAAADQEgmIsDdDhw69//77CwoKysvLH3744csvv/yyyy6bNm3arl27OnXq9MQTT1x88cXpg++444633347kUg88sgjNUPezTffHK3vGz169BdffLHPOz3uuOOiGxdeeGG/fv1mz55dj8nsr8GDB48ePTqEsHLlyksuuaR///6DBg0aM2bMqlWrrr322t/85jfRYeeff/55551X73sBAAAAWhzvwgz7MGbMmHPPPXfKlCkvvfTSunXrUqnUYYcddtZZZ40bN65bt27pw5YuXTpx4sQQwpVXXjlgwICaI7Rp0+ahhx4644wzNmzYMG7cuOnTp+/9Hs8999xJkyZNnz5906ZNXbp0+dKXvrS/k6mfqVOnDh48eMqUKe++++4nn3xy8MEHn3HGGWPGjPn6178eQrj22mtnzZpVWlra8DtqbX7wswv2fkB5eXm0rrNt27bt27dvkkmRBZ999ln79u3btm2b7YnQKKqqqrZs2RJCKCws7NixY7anQ2PZsmVLYWHhfr1W37/4z3G7yt9oF97OxLQAABqZgAj71qtXr+j9lPeif//+5eXlcXsHDRqUSqVqbTz11FN33xgZP378+PHj6z2ZyPbt2+N2HXbYYXu86yFDhkTnMu9u8uTJkydPrsv9Usvjtz259wOqqqrKyspCCPn5+YWFhaEOzRGA7NpLFgQAyD0CIkCzs8/mmCY1AmTcXuJgaWlpMpmM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pUsPOOCA4447ru4fdfDBB4cQPv/881QqtceX/m3btj399NNDhw498MADQwhPP/30hg0brr766m9961shhLVr1954443Tp0+/77776niPGfydobq6OgqI+fn5RUVFDR8wPz+n/peARpXIS2TkKVNVVRUFxEQiMwPSPJWXl+fl5e3zSzz3zudCCN5opcVJn7mcl5cX9x05epsUT/MWraKiIoOv1XmiA9RZMpnMyO87IYToF6hMjQbQSuTUj7B//OMfU6nUwIED8/Jq/zl3586df/zjH/Py8gYPHlyrEn722WchhK5du8b94Wju3LnJZPK8886L/vm3v/3t4IMPjuph9IFnnHHGggULSktLXfkCgIx4/LYng4yYQ7zDMgAALVpOBcQ//elPIYSTTjpp911t27adO3fuF198ccghhxx//PE1d73yyishhLj3Vt68efOCBQuGDRvWrl279MZaqTHqlS6DDUBmRRkxKIktmXQIAEAOyJ0Lr/zjH/9Yt25dMpns1avX7nsTicSQIUNCCJMnT166dGm0cdeuXXPmzHnhhRc6dOiw+7s2R2bPnn3ggQcOHjw4veWYY475+OOPX3zxnxer2rBhw8svv9yjR4/27dtn+CEBQAghhMdvezIdE2kp7l/8Z/UQAIDckDsrEKMseOSRR8ZdYfCCCy4oLS195plnfvrTn3bo0KFt27affvppKpXq0KHDDTfc0Llz590/ZPXq1a+++up1111X8/1Jvve977322msPPPDACy+8UFxcvGzZsurq6lGjRjXS4wKAiPOaWwrdEACAHJNrAbFv375xBySTyeHDhx9zzDHz58//4IMPtm3b1qtXr969e1944YWdOnXa44fMnDmza9eup59+es2NRUVF995776xZs5YsWbJx48avfe1rw4YN6969eyYfDADEcF5zMzf9rSUuzA8AQI7JnYB4/fXXX3/99fs87MQTTzzxxBPrOOaECRP2uL1du3ZXXXVV3ecGABlnQWJz88g7b4cQkslkticCAAAZljsBEQBaIRmxObh/8Z+9lxoAADlMQASAFs95zdnicocAALQGAiIA5A4LEpuMdAgAQOshIAJArpERG5V0CABAa5OX7QkAAI3i8dueTJ/aTKaohwAAtEJWIAJALnN5xEyRDgEAaLUERABoFZzXXG/SIQAArZyACACtiIy4X6RDAAAIAiIA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liwRka1bt7Zu3dqgn/v37+/du1dEevfuXbt2bYNXo6KiJk6cWO6hn6iCXZVjaeX4wpoQASIA4D+KnrViZzGicKtEh2H30aGQHgIAKmzHjh39+vUTERcXl2HDhr300ksqlero0aNr1qzJy8ubNGmSr6+vcoG+adOmpaSkKHVPQUFBGRkZK1eu3L59e25ubkhISEpKSumDrl27VgnU6tatO3To0LZt2967d++bb7757rvvzp8//9prr50+fVqjKS2pGDdu3OrVq0XEy8tr8ODB7du3v3bt2u7du3/66aeQkBBdLqmzZMkSJeLx9/d/5513mjRpUlhYeOHChS+//PLChQvfI+fZiAAAIABJREFUfffdsmXLJk+eXO7+b9261bVr17t374rIoEGDunbtWqNGjePHj69cufLevXvTp09XqVQfffRR6R9LJayrFMnJyR9//LGItGnTpm/fvo0aNTpx4sSmTZtu3Lhx5MiR0NBQ/fI9k4xrfCft2rVr1KjR5cuXt23b9sknnxj0s3PnzpycHBEpekbQv/71r08++eTpp5+eOHFikyZNOnbsaPLPrYJdlXVp5fvCmhABIgDgvxQtSLS/GFGhH5jCbjhCdCikhwCACisoKJg6daqI1KpVa8eOHbrKwdDQ0KFDh/bp0+fOnTszZsx44403DEqoUlJSgoODd+zY4enpqbT07t27f//+33777aVLl1JSUho3blzSoDk5OX/7299EpHnz5nv37m3YsKHSPnLkyOnTp8+fP//8+fPr168fOnRoST2cOXPmyy+/FJGAgIBdu3Y1adJEaZ86deqkSZM+++yzom9ZsWKFiDRr1uyXX37RzVlExo0bFxgYePny5cOHD+tSnnL0P2fOnLt372o0mi1btvTt21dpHDhw4Pjx43v27Hn+/PmPP/548ODBpVdWmntdpcvOzhaRkSNHfv7550p6+/bbb3/44Yd9+vQ5ceLEtm3bfvnll3bt2plw3DJ1MnDgwEWLFp05c+bixYtNmzbV7+frr78WEW9v7z/96U8GQ8ydOzc4OPibb76pXr16uYc24SqKZfzSyv2FNSHugQgAKJ7u7oF2eXtEHe6TaE9IDwEAMFJsbOy5c+dEJDw83GDfcYcOHWbMmCEiSUlJBtszRUStVkdFRenHJSLyzjvvKA9+//33UgaNjo5W9vl+9tlnuvRQ8fHHH3t5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8KMf/eiAm5cPKOnJRHcwrCXaJd2IxC8d0HJS2BAtPwQAgHzmHojkhZ49e9Z7PB7m3njjjX79+kWvN27ceM899zz//PObNm2K7p94QN26dat7MGp2DZ06hNCjR4/nn3++brPr1KnTvHnzzj777BDC0KFDJ0+enMgcGpf0ZI444ojEz5LEpQMyn3oIAAB5TkAkr8X3Ncdr109+8pMZM2ZUVlZG7x533HG9e/fu27fvsGHDHnvssXvuuafecYqLi+sejG/vbUhhYWEIIdo9Xcv69eujFxs2bNiyZUuPHj0S+XYakfRkEt86ndylA1pUap+moh4CAEB+EhDJC5s3b+7atWvd4/FngPTu3TuE8Mwzz3zve98LIQwYMGDWrFmnn356zTL4u9/9rkkn7d279zvvvPPWW281Mqv4qWtav379bbfdFkJo06bNnj17Jk2a9OSTTzbp1CmcTIJSe+mAzFFz+SEAAJCf3AORvLB27dp6j7/wwgvRi169eoUQonsOtmvX7umnnx43blytdYUVFRVNOmk05qZNm/bu3Vv33fLy8uixyH369Kl1/NJLLy0vLx86dOjcuXNDCE899dSSJUuadOpUTSZxqb10QAo1506INi8DAABBQCRP/OxnP6vbsLZt27Z48eIQwqBBgzp06BBC2Lp1awihR48edW/8V11dHa+NCTrppJNCCJ9++un8+fPrvvvLX/5y+/btIYSvfe1rNY/PmjXrxRdfLCwsvPfeeydPnjx8+PAQwrXXXvvBBx806ewpmUziUnvpgNRKriGqhwAAQERAJC9s2bJlypQpNRvijh07JkyYEN3y79Zbb40ORht4N2/e/N5779X88n379l199dVRBYvu8ZeIiy666Nhjjw0h3HbbbaWlpTXfWrNmzY033hhC6N69+6RJk+LH161bN3PmzBDC9OnTBw0aFIvF5s+f37Zt2507d06dOrVJ33KtYJrEZJoktZcOAAAAyBwCInmhffv2CxcuHDFixO2337506dLp06cPGTLkueeeCyGMGDFi3Lhx0cfGjh0bQti/f/+pp57661//ev369StXrpw7d+7AgQPvuuuuaJXie++9t3z58l27dh3wpIWFhXfccUcIYefOnaeccsq//Mu/LFmy5P7777/yyitHjhwZrSicPXt2fLdvfPNynz59brjhhujggAEDpk+fHkJYtmzZY489lsg3Gz0OZffu3cuWLduwYUO0NrCpk2mq1F46IOWaugjR8kMAACDOQ1TIC4888siECRNWr169evXqmsfPOeecaBdz5Mwzz5wyZcrdd9+9cePGCy+8MH48FotNmzZtzJgxZ511Vgjh3HPPHTNmzFNPPXXA844bN+7nP//5d7/73f379y9YsGDBggXxtzp16jR//vzzzz8/fmTmzJkvvfRSLBZbuHBhzZB3/fXXL1269LXXXpsyZcqoUaM6derU+EmPP/746EU0+O233x4lyCZNpqlSfumANFIPAQCAmqxAJC+MGDFiw4YN06ZNO+aYY4qLi7t06TJixIh77733oYceOvjgg2t+ct68eStWrDj99NO7devWrl27bt26XXrppWvXrp0zZ843vvGNadOmdenSpbi4uHv37gmeeurUqa+88spVV1117LHHlpSUHHTQQb179548efK6detqBrt169bNmjUrhPDtb3975MiRNUcoLi6Obly4devWKAU27owzzpg9e3b37t2LioqOPPLIQw89tKmTSU7KLx2QWgkuQlQPAQCAWqxAJF8cccQRc+bMmTNnzgE/OXbs2GhDbl11RygvLz/ggL17946ep9yIwYMH79+/v6F3Tz755Orq6loHhw8fXvdgZMaMGTNmzEh6MpFPP/20obe6du1a76mbdOmA1hc1xMGjB6R7IgAAQDaxAhEA+DvLDwEAgLoERADII41sZFYPAQCAegmIAAAAAECDBEQAyC/1LkK0/BAAAGiIh6iQy7p27Tp69OgQQkFBQbrnApBBaj1NRT0EAAAaISCSy8aPHz9+vL8JAzRGPQQAABpnCzMA5KNGnqYCAABQk4AIAPnL8kMAAOCABEQAyFPfHv/aB29tj16rhwAAQEMERADIX4f3OCzdUwAAADKdh6gAQD6Kb17+4K3tWzpPSu9kAACATGYFIgDknZq3PtzSeZKnqQAAAI2wAjENPvnkk+rq6pQMVVVVFb3Yu3dvWVlZ8wdMySCQJyoqKlP7I1NZmeIByTTl5eUVFRXpnkUYfsiKivK/vy7d8Y0QyioqKvyzlyp+kHNbdXV1Cn+LKyorUzIO5IPPPvvs448/TslQ0d+hUjVaCCEWi3Xu3DlVowFkJgExDYqKilIVECsqKsrLy0MIhYWFBQUFzR8wJYNAnojFYin5kYn+OhoN2KaNheE5q6Kiok2bNpnwWxyrMYfon+GvjOz3n8+/OvAfj03fpLJezR9k/zLNYRUVFSn8szoWi6VkHMgHBQUFRUVFKRlq//79IYRUjRb8LAP5QUBMg4MOOihVQ5WVlUUBsaioqLi4uPkDpvDfo5DzCgrapORHprKyMuoObdqkZkAyU0VFRUFBQdu2bdM7jRM6/zaEv+etFz4ZH/8nLoV/MctPVVVVfpDzQWVlZQp/iwsy4H9RgGzRtm3bkpKSlAwV/XGdqtEA8oT/agGAfFHz1ocvfDK+5luDRw9wJ0QAAKBeAiIA5IVG6mFEQwQAAOolIAIAAAAADRIQASD3HXD5YcQiRAAAoC4BEQByXIL1EAAAoF4CIgDw3yxCBAAAahEQASCXJbH8UEMEAABqEhABIGfZvAwAADSfgAgAuak59dAiRAAAIE5ABAAAAAAaJCACQA5q/uZlixABAICIgAgAuSZVtz4cPHpAKqYDAABkNwERAHJKah+cYhEiAAAgIAIADbKRGQAAEBABIHekdvkhADVdfvnlsVgsFot9//vfT/dcAKBVCYgAkCNaqB5ahAgQQnj88ccXLVoUQpg9e/bs2bOjg++8805paemqVavSOjUAaHECIgAAQGM++uijyy+/vE2bNnffffeMGTPixxcvXjxixIgzzjgjjXMDgFYgIAJALmjRzcsWIQJ5bvLkyTt27LjvvvsmT56c7rkAQBoIiACQ9Vrh1ocaIpC3qqurf/zjH7/77rsXXnhhuucCAOkhIAJAdvPgFCAz7d69u7KyskVPUVVV9cEHH7ToKUIIsVise/fuhx9+eEufKK68vHzPnj3V1dWtdkYAaJyACAAkxCJEoBHz5s2LxWL9+vULITzwwAP9+vXr2LFjYWHhoYceOnr06IULFzYUE5999tnJkyeffPLJX/rSlzp27NivX7+xY8cuX7687ufbtm0bi8Uef/zxEMKjjz56/PHHFxcXP/jggzU/s23btmnTpvXv379Dhw4dOnTo27fvlClTXnnlc392lZWV9e7dOxaL9erVq6ysrNZZHn744ehRy3Pnzo0fLC0tjQ6uXbs2OjJ58uRYLHbzzTeHED755JPo3TvuuKOpk4l07NgxFos9+uije/bsueKKKw455JAOHToUFxf379//kksuef3115t56QCgmQrTPQEAIHmWHwKZZubMmTfccEP8lzt27Hj22WefffbZRYsWPf7441/84hfjb1VUVEycOPFXv/pVzS9/9dVXX3311SeeeGL06NFPPvlk27Zt655iwYIFV1xxRd0FeitWrJg4ceKOHTviR/7617/+9a9/XbBgwa233vr9738/Oti+fftFixaNHj36jTfeuPnmm2tWv7/97W/f+c53QggjR4686qqrkr8KCU+mprKyslGjRsUb5f79+zdu3Lhx48b/+3//7//7f//vlFNOiX8y6UsHAMmxAhEAslXr10OLEIHGbdmy5cYbbwwhDBky5Ic//OH9999/zTXXdO3aNYSwevXq8847r+aH58yZEyWwnj17zpw5c9myZb/5zW9mz57dt2/fEMLKlStnzZpV9xR//vOfr7zyysMOO2zmzJlLly4999xzo+MrVqw466yzduzYUVhYOHHixAULFixevHjSpEnt2rWrrKz8wQ9+UDO3jRw5csqUKSGEO++888UXX4wfv+6667Zt21ZSUvKLX/wiFos18p3OmzevoqLiX//1X0MInTp1qqioqKiouO6665KYTNz111+/du3aPn36zJs3b9WqVU888UR0xcrLyy+66KKKiopmXjoASJoViACQldK19jBqiINHD2i1MwJZJNoRPHHixPnz50cr4C666KIZM2acffbZf/zjH5955pmnn356zJgx0YfvvvvuEEKvXr3WrFnTuXPn+CBXXXXV8ccf/9prr/3hD3+46aabap1i5syZw4YN++1vf9ulS5f4wcrKyunTp4cQunTp8sgjj4waNSo6PnHixP/1v/7XuHHjtm/f/q//+q//43/8j6Kiouit22+/fcWKFVu2bLnsssteeOGFwsLC5557buHChdFbRx99dOPfaZs2beL/PxaLFRQUNGcykTfffHPEiBGPP/74wQcfHB0544wzvvWtb91///3vvffehg0bBg0a1JxLBwBJswIRAABImW7dusXrYeSwww578MEHo1gWr1r79++vqKj48pe/PGXKlJoJLITQoUOHU089NYTw5ptv1h2/oqLirrvuqlkPQwgPPPDAhg0bQgjXX399PNhFTjzxxFtuuSWEsHnz5sWLF9c8S5QLX3zxxZ/+9Kf79u2bNGlSdXX1qFGjrrzyyuZcgSQmE2nTps28efPi9TAyadKk6EX8TohJXzoASJqACADZJ723PrSRGWjE1VdfXffue0cdddTFF18cQvjTn/702WefhRCKiorefvvtd95555prrqk7yIcfftjQ+CeeeOLgwYNrHSwtLQ0hdOzY8Yorrqj7JRMnTozuvRh9LO6000677LLLQgg333zzpEmTNm3aVFJSsnjx4sY3Lx9QcpMJIZxwwgnxNYZx3bt3j17E7/mY9KUDgKQJiACQZTw4BchkQ4cOrff4sGHDQgjV1dWbN2+u+251dfW2bdtKS0sXLVp0wQUXLF++vKHx691cHK3O69OnT0lJSd1327Vr179//xDCG2+8UeutO++888gjjywrK7vvvvtCCD/60Y8OuHn5gJKeTHQHw1qiXdKNSPzSAUDS3AMRALJJhtRDd0IEGtKzZ896j8fD3BtvvNGvX7/o9caNG++5557nn39+06ZN0f0TD6hbt251D0bNrqFThxB69Ojx/PPP1212nTp1mjdv3tlnnx1CGDp06OTJkxOZQ+OSnswRRxyR+FmSuHQAkDQBEQAAaHHxfc3x2vWTn/xkxowZlZWV0bvHHXdc7969+/btO2zYsMcee+yee+6pd5zi4uK6B+PbextSWFgYQoh2T9eyfv366MWGDRu2bNnSo0ePRL6dRiQ9mcS3Tid36QAgaQIiAGSNDFl+GLEIEajX5s2bu3btWvd4/BkgvXv3DiE888wz3/ve90IIAwYMmDVr1umnn16zDP7ud79r0kl79+79zjvvvPXWW43MKn7qmtavX3/bbbeFENq0abNnz55JkyY9+eSTTTp1CieToNReOgBIhHsgAkB2yKh6GPE0FaCutWvX1nv8hRdeiF706tUrhBDdc7Bdu3ZPP/30uHHjaq0rrKioaNJJozE3bdq0d+/euu+Wl5dHj0Xu06dPreOXXnppeXn50KFD586dG0J46qmnlixZ0qRTp2oyiUvtpQOARAiIAJAFMrAeAtTrZz/7Wd2GtW3btsWLF4cQBg0a1KFDhxDC1q1bQwg9evSoe+O/6urqeG1M0EknnRRC+PTTT+fPn1/33V/+8pfbt28PIXzta1+reXzWrFkvvvhiYWHhvffeO3ny5OHDh4cQrr322g8++KBJZ0/JZBKX2ksHAIkQEAGA5FmECNSyZcuWKVOm1GyIO3bsmDBhQnTLv1tvvTU6GG3g3bx583vvvVfzy/ft23f11VdHFSy6x18iLrroomOPPTaEcNttt5WWltZ8a82aNTfeeGMIoXv37pMmTYofX7du3cyZM0MI06dPHzRoUCwWmz9/ftu2bXfu3Dl16tQmfcu1gmkSk2mS1F46AEiEgAgAmc7yQyCLtG/ffuHChSNGjLj99tuXLl06ffr0IUOGPPfccyGEESNGjBs3LvrY2LFjQwj79+8/9dRTf/3rX69fv37lypVz584dOHDgXXfdFa1SfO+995YvX75r164DnrSwsPCOO+4IIezcufOUU075l3/5lyVLltx///1XXnnlyJEjoxWFs2fPju/2jW9e7tOnzw033BAdHDBgwPTp00MIy5Yte+yxxxL5ZqPHoezevXvZsmUbNmyI1gY2dTJNldpLBwCJ8BAVAMhomV8PPU0FqOmRRx6ZMGHC6tWrV69eXfP4OeecE+1ijpx55plTpky5++67N27ceOGFF8aPx2KxadOmjRkz5qyzzgohnHvuuWPGjHnqqacOeN5x48b9/Oc//+53v7t///4FCxYsWLAg/lanTp3mz59//vnnx4/MnDnzpZdeisViCxcurBnyrr/++qVLl7722mtTpkwZNWpUp06dGj/p8ccfH72IBr/99tujBNmkyTRVyi8dAByQFYgAkLlq1sNMZiMzEDdixIgNGzZMmzbtmGOOKS4u7tKly4gRI+69996HHnro4IMPrvnJefPmrVix4vTTT+/WrVu7du26det26aWXrl27ds6cOd/4xjemTZvWpUuX4uLi7t27J3jqqVOnvvLKK1ddddWxxx5bUlJy0EEH9e7de/LkyevWrasZ7NatWzdr1qwQwre//e2RI0fWHKG4uDi6ceHWrVujFNi4M844Y/bs2d27dy8qKjryyCMPPfTQpk4mOSm/dADQOCsQASA7ZObyQ4C6jjjiiDlz5syZM+eAnxw7dmy0IbeuuiOUl5cfcMDevXtHz1NuxODBg/fv39/QuyeffHJ1dXWtg8OHD697MDJjxowZM2YkPZnIp59+2tBbXbt2rffUTbp0ANBMViACQIbK/M3LNVmECAAAuUpABIBMlF31EAAAyGECIgBknGy59WEtFiECAEBOEhABIKNl1/JDz2IGAIDc4yEqAJBZsn3z8rqVr8iIkIe6du06evToEEJBQUG65wIApJiACAAZJNvrYfivjcwaIuSb8ePHjx+flX9qAQAHZAszAGSKLL31IQAAkNsERADIRFm6/DDiaSoAAJBLBEQAyAg5sHkZAADISQIiAKRf7tVDixABACBnCIgAkGa5Vw8jGiIAAOQGAREAAAAAaJCACADplKvLDyMWIQIAQA4QEAEgbXK7HgIAALlBQASA9MiTemgRIgAAZDsBEQDSoGY9zHmDRw9I9xQAAIDkCYgAkGY5vPwwziJEAADIXgIiALS2PNm8XJONzAAAkL0ERABoVXlYDwEAgKwmIAJA68mrWx/WYhEiAABkKQERANLD8kMAACArCIgA0EpO+sJj8df5WQ8tQgQAgGwkIAJAaxh+6OPx1/lZDyMaIgAAZB0BEQBanAenAAAA2UtABICWlc8PTqmXRYgAAJBdBEQAaD2WHwIAAFlHQASAFlRz+eGfdo5L40wyikWIAACQRQREAGgpNeth6Ydj0ziTDDR49IB0TwEAAEiIgAgALcKtDw/IIkQAAMgKAiIApF6teujWh/WykRkAALKCgAgALUs9BAAAspqACAApVnP5oXrYOIsQAQAg8wmIAJBK6iEAAJBjBEQASBkPTkmCRYgAAJDhBEQASA0PTkmahggAAJlMQASA1FMPAQCAnCEgAkAKuPVhM1mECAAAGUtABIDmUg8BAIAcJiACQLN4cEqqWIQIAACZSUAEgOR5cEpqaYgAAJCBBEQASJJ6CAAA5AMBEQBSQD1MFYsQAQAg0wiIAJAMD04BAADyhIAIAE2mHrYoixABACCjCIgA0DQeuwwAAOQVAREAmsCDU1qHRYgAAJA5BEQASJR62Jo0RAAAyBACIgAkRD0EAADyk4AIAE2mHrYOixABACATCIgAcGAeuwwAAOQtAREADsBjl9PIIkQAAEg7AREAGuPWh2mnIQIAQHoJiADQIPUQAABAQASA+qmHmcMiRAAASCMBEQDqoR4CAABEBEQAqE09zEAWIQIAQLoIiADQGPUwcwwePSDdUwAAgHwkIALA59RafkhGsQgRAABan4AIAP/N5uUMZyMzAAC0PgERAP5OPQQAAKhLQASAENTD7GERIgAAtDIBEQDUQwAAgAYJiADkO/Uw61iECAAArUlABCCvqYdZSkMEAIBWIyACkL/UQwAAgAMSEAHIU+phtrMIEQAAWoeACEA+qlUPAQAAaIiACEDeqVsPLT/MUhYhAgBAKxAQAcgv6mGO0RABAKClCYgA5BH1EAAAoKkERADyhXqYqyxCBACAFiUgApAX1EMAAIDkCIgA5D71MOdZhAgAAC1HQAQgx6mHeUJDBACAFiIgJundd99999130z0LAA5APQQAAGimwnRPIGXeeuut3/72ty+//PInn3zyxS9+sVu3buecc06/fv1qfmbp0qUPPPBAvV9+zz33dO3aNXpdVlb27LPPvvXWW4cccsiJJ5541FFH1frw9u3bp06d+q1vfevLX/5yS3wvAKSEephvokWIg0cPSPdEAAAgp+RIQPyP//iPO++8s7KyMoRw2GGH7dy58/3331+zZs3555//P//n/4x/7P333z/gUFu2bLn11lu3b98e/fKBBx749re/feaZZ9b8zAMPPNClS5exY8em9JsAIJXUQwAAgJTIhYD4t7/9bc6cOZWVlf/4j/942WWXfeELX6isrPz3f//3X/ziF0uXLh04cOCgQYOiT0YB8c4776y7qLBdu3YhhKqqqp/85CeffvrpddddN2TIkPfee+/uu+9euHDhsccee/TRR0effOutt1auXDlt2rS2bdu24ncJQBOoh3nLIkQAAEi5XLgH4lNPPbV///5+/fpde+21X/jCF0IIBQUF48eP/+Y3v1ldXb1ixYr4J6OAeNRRRxXXEYvFQghvv/32li1bzjvvvBEjRrRv3/7oo4++7rrrKisr//SnP8UHWbJkSbdu3U4++eRW/0YBSIh6mOc8TQUAAFIrFwLi66+/HkIYPXp0QUFBzePDhg2LvxtC2L9//86dOzt37lxcXNzQUJ9++mkIIaqQkc6dOxcUFHzyySfRL19++eW1a9decsklUXAEINOohwAAAKmVCwGxoqLikEMOqfs8k2iLcXRjxBDCBx98UF1dfcQRRzQy1DHHHNOuXbt///d/37t3b3TkoYceqqysHDDg7zuhlixZMmDAgK9+9asp/h4ASAX1kIhFiAAAkEK5cA/EG264od7jq1evDiEcc8wx0S+j/cudO3devnz5ypUrP/jgg0MOOaRnz57nnHNO/P6GBx100GWXXXb33XdPmjSpX79+77///pYtWwYNGjRq1KgQQmlp6V//+tcf//jHrfFdAdBE6iEAAEBLyIWAWK9169YtX748hHD22WdHR6KAuGrVqlWrVhUWFh588MHvvvvuu++++8c//nHixInjxo2LPvZP//RPhxxyyEMPPfTyyy9/8YtfvOCCC84777xYLFZZWfmrX/1q2LBhffv2bebcPv7446qqqmYOEqmuro5e7NmzZ8+ePc0fML70EjigioqK1P7IVFRUVFRUpHDA/DH80MdDCOXlnztY+uHYEDLrz7Ty8vLyWrOkxfQ+oeefn3qp//A+rXzeyspK/zLNbSn8s7qiojIl40A+KCsr++ijj1IyVPR3qFSNFkKIxWI174IFkJNyMCDu27dv6dKlDz/8cFVV1YUXXviVr3wlOh4FxA4dOkydOvWrX/1qYWHhnj17HnzwwUcffXTx4sX9+/fv1atX9MmvfvWrdTcpP/nkk++9915Dqx2bpKqqKh7+UiXlAwJki6ge1lT64di0zIRM0394nw2lf239hghAylVXV6f2rzz+AgXQJLkWEEtLSxctWrRjx47i4uLLLrvs61//evytMWPGDBkypFu3boccckh0pKSk5LLLLvv444+fe+65ZcuW/eAHP2ho2H379j344IOnnXZa165dQwh79+697777/vKXv+zZs6dv376XXHJJ9+7dE59kQUFBqv51FW+Rbdq0SclzXTwcBpoilqofmegH2Q9gEoYfsqLWkdId38jMC1ldXe23uPXFYin7OT2g+L/c/UbnsBT/IPsnBRLWpk2bWs/MTFq0G6xNm5Q9D8Af+0A+yJ2AuGvXrnvuuae0tDSEMGLEiEsvvfSwww6r+YGePXv27Nmz7hd+/etff+655958881GBn/00Uf37t07YcKEEMK+ffv+9//+31u3bu3Vq9fhhx++bt26a6655vbbb+/TJ9EFDp07d070uzqQsrKyaOfyAk8dnwAAIABJREFUQQcd1MjTpRPXvn375g8CeaKwsCAlPzKVlZX79u0LIRQUFBQVFTV/wPxxQuffhtC25pEXPhmfsX+M7d27t7CwMHrAF61myJjB61a+Mnj0gJY+UVVV1WeffRZCKCgoaNeuXUufjnQpKytL4Z/VhSmqIZAPiouLu3TpkpKhdu3aFUI4+OCDUzIaQJ7IkYC4ffv26dOnf/TRR926dbvqqquOPfbYxL/28MMPDyHs3Lmzof9JedeuXQ8//PC4ceOiG1s8/PDDW7duvfLKK6PljW+//fb3vve9f/u3f/vpT3+aou8GgAPzyBQAAIDWkQsBce/evTfddNNHH300ZsyYyZMn17u4Y+/evb///e/btGlz5pln1qqEO3bsCCF069atoZXny5YtKygoOOecc6Jf/ud//ufhhx8e3xzdrVu3U0455YknnigrK7N8D6AV1E2HQT2kYYNHD2idRYgAAJCrciEgPv3001u3bv3qV786derUhj7Tvn37ZcuW/e1vfzviiCOGDBlS861nnnkmhNDQs5W3b9/+xBNPXHLJJQcddFD8YK3UGN0+I1UPVgagEeohSVAPAQCgOVJ249g0evLJJ0MI48ePr2pACCEWi40dOzaEMGfOnHXr1kVf+Nlnnz3wwANPPvlkx44do/sb1vWrX/3qC1/4wplnnhk/MnDgwPfff/+pp56Kfrl169Y//OEPPXv2LCkpadFvEwD1kKStW/lKuqcAAADZKutXIFZWVr777rshhBtuuKHeD3zpS1+aP39+COG8884rKyt75JFHbrzxxo4dO7Zv3/7DDz+srq7u2LHjtddeW++DTTZv3vzss89effXVNbdF//M///Nzzz03d+7cJ598skOHDi+//HJVVdXkyZNb5vsD4O/UQ5rDRmYAAEha1gfEDz/8MMG9wwUFBRMnThw4cOCKFStef/31Xbt29e7du0+fPueff36nTp3q/ZIlS5Z069Zt9OjRNQ+2a9fuzjvvvO+++9auXbtt27avfOUrl1xySY8ePZr9rQBQP+kQAAAgjbI+IB5xxBGPPfZY4p8fOnTo0KFDE/zwzTffXO/xgw466Iorrkj8pAAkTT0kVSxCBACA5OTCPRAByEkndP6tekhqRQ0x3bMAAIAsk/UrEAHISdIhAABAhrACEYCMox7ScixCBACAprICEYAMUm86DOohAABA+liBCECmUA9pHRYhAgBAk1iBCED6SYe0Mk9kBgCAxAmIAKRTQ+kwqIcAAACZwRZmANKmkYWH6iEtzUZmAABIkBWIAKSBhYcAAADZQkAEoFVJh2QOd0IEAIBE2MIMQOtRD8k0NjIDAMABWYEIQGuQDgEAALKUFYgAtKwTOv9WPSSTWYQIAACNswIRgJbSSDcM0iEAAECWEBABSD3pkOziaSoAANAIARGAVJIOyVIaIgAANERABCA1pEMAAICcJCAC0CyNd8OIekhWsAgRAADqJSACkCTpEAAAIB8IiAA0TSLdMEiHZCeLEAEAoC4BEYBESYfkAw0RAABqERABODC7lQEAAPKWgAhAgyw5JD9ZhAgAADUJiADUlmA3DNIhuUtDBACAOAERgL9LvBsG6RAAACBvCIgA+U43hHpZhAgAABEBESBPNakbBukQAAAgXwmIAHmkqdEw6IbkN4sQAQAgCIgA+UA3hKRpiAAAICAC5KYkomFEOgQAAKAmAREgd4iG0BIsQgQAIM8JiADZLeloGHRDAAAAEiAgAjTLtK8Na+YI+/fv37VrVwihffv2JSUliXxJ9e65NX51VCOfXPXuO3UP6obQVBYhAgCQzwREgGb5+ao/JvFVSWTHz0fDRH3ty/+dF2MdvhO9OCmJgWi2HTt2lJSUtG/fvqEPJPfPEq1GQwQAIG8JiABpUDMVVVZW7tu3L4RQWFhYVFQUPx7fm1wzAjZVPBqS+Zq/mjVLKacAAJDhBESATHHSF/+9oKCg7vF6tyHXUu9KQ8gK2VROvzbs/lt+c/FN59V9p7Ky8uOPPw4hFBUVHXzwwU0aVUIFACDDCYgA6RFfYFhdVVVRWRlCCKFN0qPd9Z9DavyqnhiRTY0GMtjFN53XUENMmh/PlpPczR8aUVZWVlBQUHO1eHO82OWjF1IyEABACxMQAVpJcx6XXK8mPQulkSVO4gXknpSHMwAA8pmAyOdUVFRELxYtWrRy5cq0zgUy1Icffhi9qCgvb+gzKW+FcS3xAGVtEZokkUWI+h0AALlEQORzXnrppejF73//+9///vfpnQxkuG2vvxFashVGWqIYJq7etqgqko1SW/S+MuSV6t3vf+5QVVX7qs9CCAXlBdW726XwXAAAkHYCIp/TpUuXdE8BskaPQ6unDlwbwgEekZzII1BqSm8xTISqSKpk7zK9waMHrFv5yuDRA9I9EQAAaA0CIp9zzDHHRC8mTJjwD//wD+mdDGSmd999d+7cuSGEPr0OS+TzNZ+PXK/yon/ZtWtXCKF9+/YlJSUvZOfzWOtWRUkxe2Vv12tNGiIAAPlDQKR+Z5111oQJE9I9C8hEa9asiQJi0mIdvvO5X+/fX/NXCXa3Rm5cmCFqzVBPbD5dDwAASAsBEaBl1c6FKXLAHpdphTHHemISLa991d6Cz9pWV7ZtifmQFhYhAgCQJwREgJRpoVaYnAwvjE3qiVbekbE0RAAA8oGACJAyyXWuNpWV7av2hRAK9xVWVxelelINmjqw/uNNfepLSvzp1f9+mPUB7xoJAABAaxIQAfichvpdq4XFWifSE8lw0SLEr4zsl+6JAABASxEQAUhIvSGvFapi/BRKIhlr8OgBLz3zn31OPDrdEwEAgBYhIAKQvLpRr+WSYs2RxUQAAIBWIyACkEqtkxQtSyTTDBrV/y+/X99/eJ90TwQAAFJPQASgZdVqfKntiZYlAgAAtDQBEYBW1XI90bJE0qv/8D4bSv/qaSoAAOQeARGAdGqJnqgkki79h/d55T82HX/qoHRPBAAAUklABCCD1Ex+zY+JSiIAAEDzCYgAZKgUxkQlkVYzYETfdStfGTx6QLonAgAAKSMgApAFUhUTlURaweDRAzREAAByiYAIQJaJt7/ml0QZEQAA4IAERACyVfNLogWJtBCLEAEAyCUCIgBZr/kbnJVEUk5DBAAgZwiIAOSUZi5LtLUZAACgFgERgNzUnJJoQSIpYREiAAC5oU26JwAALetrXz4q+r8kvnbVu+8051EtEDXEdM8CAACaxQpEAPJF0msSLUgEAADymRWIAOQdCxJpTRYhAgCQ7axABCBPWZBIq3EzRAAAspqACEC+a2ZJlBEBAIDcZgszAPxdclub7WsmETYyAwCQvaxABIDPSW5Bon3NHJCNzAAAZCkrEAGgfhYkAgAABAERABoXZcSmlkQZkXrZyAwAQDYSEAEgITIiKaEhAgCQddwDEQCaIIk7JEafLC8vd3tEAAAgG1mBCADJSGJB4pptWy1IJFiECABAthEQASB59jWTHA0RAIAsYgszADRX0vuabWoGAAAynxWIAJAyTV2QGK1GtCAxP1mECABAthAQASDF7GsmQRoiAABZQUAEgBYhIwIAALlBQASAFhRlxCT2NbfclMgoFiECAJD5BEQAaA1DDj9i6JFdE/+8jJg/NEQAADKcgAgArcdqRBqiIQIAkLEERABobTIitQwePSDdUwAAgAYVpnsCAJCn4g0xwTgY/1hTn81CVog2MiuJAABkICsQASDNLEgkzkZmAAAykIAIABlBRsTyQwAAMpOACAAZREbMc57IDABABhIQASDjyIj5TEMEACDTCIgAkKFkRAAAIBMIiACQ0aKMmHhJlBFzgEWIAABkFAERALKDjJhXNEQAADKHgAgA2URGzCsaIgAAmUBABIDsIyPmg8GjB6R7CgAAEIKACADZS0bMeTYyAwCQCQREAMhuSWREJTGLaIgAAKSdgAgAuaBJGTFYkJhtNEQAANJIQASA3CEj5iQ3QwQAIL0ERADINTJi7rGRGQCANBIQASA3yYg5RkMEACBdBEQAyGUyYo7REAEAaH0CIgDkvigjNvVhzS06JZLgZogAAKSFgAgAeURGzHY2MgMA0PoERADIOzJiVtMQAQBoZQIiAOQpGTGraYgAALQaAREA8pqMmI3cDBEAgNYkIAIAMmL2sZEZAIBWIyACAH8nI2YXDREAgNYhIAIAnyMjZhENEQCAViAgAgD1kBGziIYIAECLEhABgAbJiJnPA1UAAGhpAiIAcAAyYoazkRkAgBYlIAIACZERM5mGCABAyxEQAYAmkBEzmYYIAEBLKEz3BPLRnj17qqurUzJURUVF9GLfvn3x182xf//+5g8CeaKysiolPzJVVVXxF34Gc1tlZWWq/vxPu+MPOzyEsOa9bYl8uHTLWyGEoV86skWnlF7x39k0/iD3G9b7P59/9S+/Xz/wH49NywTyQXV1dQp/iysrq1IyDuSD/fv37969OyVDVVRUxGKxVI0WQojFYiUlJakaDSAzCYhpUFFRkaq/QNbsDikZMz4gkIDqlPzIxH94o7+XNn9AMlbu/RYPOfyIEMKf338vkQ+/sG1rCOGrR3ypZeeUJhnyg9x/eJ9X/mPTy89tHDCib7rmkPNS+lucI/+LArSCqqqqlCyYCP/1J3aqRgshxGKxVA0FkLEExDTo1KlTqoYqKyvbs2dPCKF9+/bFxcXNHzAlg0CeKCgoSMmPTGVl5b59+6IBi4qKmj8gmWnv3r2FhYVt27ZN90RSb0SPniGEBLcqv7TjwxBC4pugs0VVVdVnn30WQigoKGjXrl0aZzJkzOB1K1/xL/QWUlZWlsI/qwsKClIyDuSD4uLizp07p2SoXbt2hRAOPvjglIwGkCfcAxEASAH3RswcHqgCAEBqCYgAQMrIiBlCQwQAIIUERAAgxWTETKAhAgCQKgIiANAiksiISmLKaYgAADSfgAgAtKAmZcRgQWJKDR49IGiIAAA0m4AIALQ4GTFdNEQAAJpPQAQAWomMmBYaIgAAzSQgAgCtKsqInrLSmqKGCAAAyREQAYD0kBFbk4cyAwCQNAERAEgnGbHVaIgAACRHQAQA0k9GbB0aIgAASRAQAYBMISO2Ag0RAICmEhAhr11++eWxWCwWi33/+99P91wA/k5GbGkaIgAATSIgQv56/PHHFy1aFEKYPXv27Nmzo4PvvPNOaWnpqlWr0jo1ABmxZWmIAAAkTkCEPPXRRx9dfvnlbdq0ufvuu2fMmBE/vnjx4hEjRpxxxhlpnBtAnIzYcjREAAASJCBCnpo8efKOHTvuu+++yZMnp3suAAcgI7YQDREAgEQIiJCPqqurf/zjH7/77rsXXnhhuucCkCgZsSVoiAAAHJCASJbZvXt3ZWVlk76kqqrqgw8+SNfZmyqFs21ELBbr3r374Ycf3tIniisvL9+zZ091dXWrnRHIVTJiymmIAAA0TkAko82bNy8Wi/Xr1y+E8MADD/Tr169jx46FhYWHHnro6NGjFy5cWDfntW3bNhaLPf744yGERx999Pjjjy8uLn7wwQdrfmbbtm3Tpk3r379/hw4dOnTo0Ldv3ylTprzySu2/OyVx9sizzz47efLkk08++Utf+lLHjh379es3duzY5cuXt9xsy8rKevfuHYvFevXqVVZWVussDz/8cPSo5blz58YPlpaWRgfXrl0bHZk8eXIsFrv55ptDCJ988kn07h133JHEpQshdOzYMRaLPfroo3v27LniiisOOeSQDh06FBcX9+/f/5JLLnn99debeemAPCcjppaGCABAIwREssPMmTMvuuiiV199Nfrljh07nn322UmTJg0fPvyjjz6q90sWLFhw9tlnv/jii+Xl5TWPr1ixYvDgwXfdddfGjRv37NmzZ8+ev/71r/fcc8/gwYPjTyJO+uwVFRUXX3zx6NGj/+3f/m3lypXvv//+7t27X3311SeeeOLcc88dM2ZMrcmkarbt27dftGhRLBZ74403ogIY97e//e073/lOCGHkyJFXXXVVvWdPUBKXrqysbNSoUfPnz9+1a1cIYf/+/Rs3brzvvvv69+//hz/8oeYnk750QD6TEVNIQwQAoCGF6Z4AHNiWLVtuvPHGEMKQIUO++c1v9uzZ8y9/+cuyZcu2bt26evXq8847r1aKCiH8+c9/vu222w477LCpU6f26tVr+PDh0fEVK1acddZZIYTCwsKLL774pJNOKiwsXLVq1ZIlS/bt2/eDH/zgqKOOuuiii5I++5w5c371q1+FEHr27Hn55ZdHqwJff/31X/7yl5s2bVq5cuWsWbNuuummlpjtyJEjp0yZMm/evDvvvPOCCy447rjjouPXXXfdtm3bSkpKfvGLX8RisUau87x58/7P//k/P/zhD3/4wx926tQpaqNt2rRJ+tKFEK6//vo333yzT58+06ZNGzJkyM6dO3/xi1/85je/KS8vv+iii95+++3CwsLmXDqAEELUEBOMg/GPJV4e80e8IQ4ePSDdcwEAIIPE3JIsq5WVle3ZsyeEEG0Obf6At9xyS7R+7de//vWECROaP2AzzZs3L75obuLEifPnz2/btm30y+3bt5999tl//OMfQwhPPfXUmDFjouNt27atqKho27btSSed9Nvf/rZLly7x0SorKwcNGrRhw4YuXbo88sgjo0aNir+1evXqcePGbd++vWfPnq+++mpRUVFyZz/66KM3b97cq1evNWvWdO7cOT7+7t27jz/++Ndee23kyJHPPvts/HgKZxudZeDAgVu2bDnuuONeeOGFwsLC5557bvTo0dXV1XPnzq21/LC0tHTEiBEhhD//+c9DhgyJH4/+GejcufPHH3/cnMl07Nhx9+7dIYQRI0Y8/vjjBx98cPxLvvWtb91///0hhHXr1g0aNCi5S5dGa9asOeGEE0IIF08YumTBxc0fsLKyct++fSGEwsLC+AUk9+zdu7dt27bxP0ZoIU1dY5iqjFhVVfXZZ5+FEAoKCtq1a5eSMdNFQ2xEWVlZQUFBqv6snnjFr5Y88EIIYdWqVSeeeGJKxoQcs3Tp0gsuuCCEcNNNN9XaZ5O0aGdMzf86BeCAbGEmO3Tr1q1mvwshHHbYYQ8++GD0X/B1F6ZVVFTcddddNXtcCOGBBx7YsGFDCOH666+vmcBCCCeeeOItt9wSQti8efPixYuTO/v+/fsrKiq+/OUvT5kypWYCCyF06NDh1FNPDSG8+eabdb+7VM22Q4cOCxcuDCG8+OKLP/3pT/ft2zdp0qTq6upRo0ZdeeWVdc+buKQvXZs2bebNm1frv88mTZoUvYjfCTHpSwdQS5M2NQf7musTpUPbmQEAiBMQyQ5XX3113WU7Rx111MUXXxxC+NOf/hSt+4g78cQTBw8eXOvzpaWlIYSOHTteccUVdU8xceLEL37xi/GPJXH2oqKit99++5133rnmmmvqjv/hhx829N2lcLannXbaZZddFkK4+eabJ02atGnTppKSksWLFze+efmAkr50J5xwQnyNYVz37t2jF/EV0ElfOoB6yYjNpCECAFCTgEh2GDp0aL3Hhw0bFkKorq7evHlzzeNHH3103Q9H69369OlTUlJS99127dr1798/hPDGG2808+yR6urqbdu2lZaWLlq06IILLli+fHm9g6R8tnfeeeeRRx5ZVlZ23333hRB+9KMf1Tt+kyQ9mb59+9b9fPy+ig1J/NIBNEJGbA4NEQCAOA9RITv07Nmz3uPxNPbGG2/069cvfrxbt251PxxVsIaGCiH06NHj+eefr1vBmnT2jRs33nPPPc8///ymTZvKysoaOldNqZ1tp06d5s2bd/bZZ4cQhg4dOnny5ETm0LikJ3PEEUckfpYkLh3AAcUbYpOesuIRK+G/nqmybuUr7ocIAJDnBESyW3xnca3eVO8jZQ74yKDoicC1dkM36ew/+clPZsyYUVlZGb173HHH9e7du2/fvsOGDXvsscfuueeeesdJ+WzXr18fvdiwYcOWLVt69OiRyLfTiKQnk/jW6eQuHUDiknhYs4wYX4eoIQIA5DMBkeywefPmrl271j0efwpH7969DzhI796933nnnbfeequRs9Q7VIJnf+aZZ773ve+FEAYMGDBr1qzTTz+9Zhn83e9+d8AZpmS269evv+2220IIbdq02bNnz6RJk5588skmnTqFk0lQai8dQCOSyIgh70titBQxeDQzAEC+cg9EssPatWvrPf7CCy9EL3r16nXAQaLPbNq0ae/evXXfLS8vjx403KdPn+TOHt1zsF27dk8//fS4ceNqrSusqKg44AybP9vy8vJLL720vLx86NChc+fODSE89dRTS5YsadKpUzWZxKX20gEckNsjNpVbIgIA5DMBkezws5/9rG5F2rZt2+LFi0MIgwYN6tChwwEHOemkk0IIn3766fz58+u++8tf/nL79u0hhK997WvJnX3r1q0hhB49etS98V91dXW8NiYoudnOmjXrxRdfLCwsvPfeeydPnjx8+PAQwrXXXvvBBx806ewpmUziUnvpABIkIzaJhggAkLcERLLDli1bpkyZUrPi7dixY8KECdFN92699dZEBrnooouOPfbYEMJtt91WWlpa8601a9bceOONIYTu3btPmjQpubNHG3g3b9783nvv1fzyffv2XX311VEFi+7x10KzXbdu3cyZM0MI06dPHzRoUCwWmz9/ftu2bXfu3Dl16tQEzxupFUyTvnQJSu2lA2gSGTFxg0cPiD9ZJd1zAQCg9bgHItmhffv2CxcuXL9+/fjx43v27PmXv/zlwQcffPvtt0MII0aMGDduXCKDFBYW3nHHHd/85jd37tx5yimnXHrppcOGDWvTps2qVasWL14c1cDZs2fXfaRJgmcfO3bs3XffvX///lNPPfWGG24YOHDgzp07X3755bvuuuv111/v0KHD7t2733vvveXLl5922mkHH3xwamcb37zcp0+fG264ITo4YMCA6dOn33bbbcuWLbvwwgsTuVDR41B27969bNmygQMHdurUqWvXrklfugSl9tIBJKFJ90YM+f2UFU9nBgDINwIi2eGRRx6ZMGHC6tWrV69eXfP4OeecE+0jTtC4ceN+/vOff/e7392/f/+CBQsWLFgQf6tTp07z588///zzkz77mWeeOWXKlLvvvnvjxo0XXnhh/HgsFps2bdqYMWPOOuusEMK55547ZsyYp556KrWznTlz5ksvvRSLxRYuXFgz5F1//fVLly597bXXpkyZMmrUqE6dOjV+0uOPPz56EQ1+++23T58+vamTaaqUXzqA5MiICdIQAQDyii3MZIcRI0Zs2LBh2rRpxxxzTHFxcZcuXUaMGHHvvfc+9NBDTV2PNnXq1FdeeeWqq6469thjS0pKDjrooN69e0+ePHndunUNJbDEzz5v3rwVK1acfvrp3bp1a9euXbdu3S699NK1a9fOmTPnG9/4xrRp07p06VJcXNy9e/fUznbdunWzZs0KIXz7298eOXJkzRGKi4ujGxdu3bo1SoGNO+OMM2bPnt29e/eioqIjjzzy0EMPbc6lS1zKLx1A0pLY1Lx667trP3i/5aaUgWxnBgDIH7Hq6up0z4HklZWV7dmzJ4TQoUOHpHeP1nTLLbfcfPPNIYRf//rXEyZMaP6AzTRv3ryrrroqhLB79+6SkpK8OjsZa82aNSeccEII4eIJQ5csuLj5A1ZWVu7bty+EUFhYWFRU1PwByUx79+5t27Zt27Zt0z0RmiyRBYnV1dXR3WPbxGLDe/Rs+UllkCgg5slSxLKysoKCglT9WT3xil8teeCFEMKqVatOPPHElIwJOWbp0qUXXHBBCOGmm26K/p7SfLt27QohuCsOQJNYgQgA0BhPWWlc/OnMliICAOQqAREA4MBkxEZE25nDf61GBAAgxwiIAACJSi4j5klJtBQRACBXCYgAAE3T1IwY8mZBoqWIAAA5qTDdE4DGdO3adfTo0SGEgoKCfDs7ABkuaohNyoLRh5saH7NOzacz58nDVQAAcpuASEYbP378+PHj8/PsAGSFqAZWVVWVbnkrwS+JN8cc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0tK0KQkJCQkJCd9888306dPHjx9fnNrz8vJCQkLWrVune/sff/zxxx9/7Ny5s127dnv27LGxsbF4ax0cHFatWtWuXburV69++umnulG/v/76KyIiQgjRtm3bkSNHGlZtOjO6LjMzMzg4WBujzMnJuXjx4sWLF7///vvY2NgOHTpoc5rddQCACosAIgAAAID/Sk5Onjx5shCiefPmvXr18vHxOXny5MaNG1NSUo4ePdqvX799+/bp3XLixInIyMjnnntu1KhR9evXDwoKkunbt2/v0aOHEEKtVr/11luBgYFqtfrIkSNRUVHZ2dkTJkzw9PQcNGiQ2bUvWLBAhsB8fHyGDRsmZwVeuXJlzZo1ly5dOnDgwMyZM6dOnVoSrW3btu2IESOWLFkyd+7c/v37v/jiizJ97NixqampTk5O3377rUqlMtLPS5YsWbx48bRp06ZNm1a5cuV79+4JIaysrMzuOiHExIkTExMTfX1933///ebNm9+/f//bb7/dtGlTbm7uoEGDrl+/rlari9N1AICKjAAiAAAAgP+Sa3JDQkKWL18u56ANGjTok08+6dOnz+HDh/fv3x8XF9epUyfdW2bMmNG6deutW7e6urpqE/Pz88eNGyeEcHV1jYmJCQ4OlukhISFDhw7t2bPnnTt3pkyZ8sYbb9ja2ppX+9KlS4UQ9evXP378eJUqVbSFjBw5slmzZpcvX963b59hFMxSrZ09e/b27duTk5NDQ0OPHTumVqt//vnnFStWyEt169Y13s8yVij/q1KprK2ti9l1QojExMQ2bdrs2LGjUqVKMqVr165vv/322rVrb926deHChcaNGxen6wAAFRl7IAIAAAD4m5eXlzZ+Jz333HMbNmyQ4SrDuFJeXt6iRYt043FCiPXr11+4cEEIMXHiRG0ITGrVqtVnn30mhEhKSlq9erV5tefk5OTl5dWuXXvEiBG6ITAhhLOzc8eOHYUQiYmJhk9nqdY6OzvLcOHvv/8+b9687OzssLAwjUYTHBz83nvvGdZrOrO7zsrKasmSJdrooRQWFiY/aHdCNLvrAAAVGQFEAAAAAH8bPXq04f53np6eb731lhDit99+y8rK0r3UqlWrJk2a6OU/dOiQEMLFxWX48OGGVYSEhMjdDGU2M2q3tbW9fv36jRs3PvjgA8Py7969q/R0Fmxt586dQ0NDhRCffvppWFjYpUuXnJycVq9ebXzx8lOZ3XUtW7bUzjHU8vb2lh+0ez6a3XUAgIqMACIAAACAv7Vo0aLQ9NatWwshNBpNUlKSbnqhy3XlfDdfX18nJyfDq3Z2dgEBAUKIq1evFrN2SaPRpKamHjp0aNWqVf3799+8eXOhhVi8tXPnzq1Vq1ZmZuZ3330nhJgzZ85TFy8/ldmN8fPzM8yv3VdRieldBwCoyNgDEQAAAMDffHx8Ck3XhsauXr3q7++vTffy8jLMLKNgSkUJIerUqfPLL78YRsGKVPvFixe//vrrX3755dKlS3L/xKeybGsrV668ZMmSPn36CCFatGgRHh5uShuMM7sxNWrUML0WM7oOAFCREUAEAAAA8HTalcV68SZ7e3vDzNoFs0rkicB6q6GLVPuXX375ySef5Ofny6svvvhigwYN/Pz8Wrdu/eOPP3799deFlmPx1p45c0Z+uHDhQnJycp06dUx5HCPMbozpS6fN6zoAQEVGABEAAADA35KSkjw8PAzTtadwNGjQ4KmFNGjQ4MaNG9euXTNSS6FFmVj7/v37P/74YyFEw4YNZ86c2aVLF93I4O7du5/aQou09syZM5GRkUIIKyurjIyMsLCwPXv2FKlqCzbGRJbtOgBABcEeiAAAAAD+Fh8fX2j6sWPH5If69es/tRCZ59KlS0+ePDG8mpubKw8a9vX1Na92ueegnZ1dXFxcz5499eYV5uXlPbWFxW9tbm7ukCFDcnNzW7Ro8dVXXwkh9u7dGxUVVaSqLdUY01m26wAAFQQBRAAAAAB/mz9/vmEUKTU1dfXq1UKIxo0bOzs7P7WQwMBAIcTjx4+XL19ueHXNmjV37twRQrz88svm1Z6SkiKEqFOnjuHGfxqNRhttNJF5rZ05c+bvv/+uVqtXrlwZHh4eFBQkhPjwww9v375dpNot0hjTWbbrAAAVBAFEAAAAAH9LTk4eMWKEbhQvLS1twIABctO96dOnm1LIoEGDnn/+eSFEZGTkoUOHdC8dP3588uTJQghvb++wsDDzapcLeJOSkm7duqV7e3Z29ujRo2UUTO7xV0KtPX369IwZM4QQ48aNa9y4sUqlWr58uY2Nzf3790eNGmVivZJewNTsrjORZbsOAFBBsAciAAAAgL85ODisWLHizJkzvXv39vHxOXny5IYNG65fvy6EaNOmTc+ePU0pRK1Wf/7557169bp//36HDh2GDBnSunVrKyurI0eOrF69WkYDZ82aZXikiYm1d+/efenSpTk5OR07dpw0aVKjRo3u379/9uzZRYsWXblyxdnZOT09/datW5s3b+7cuXOlSpUs21rt4mVfX99JkybJxIYNG44bNy4yMnLjxo0DBw40paPkcSjp6ekbN25s1KhR5cqVPTw8zO46E1m26wAAFQQBRAAAAAB/i4mJGTBgwNGjR48ePaqb3rdvX7mO2EQ9e/ZcuHDhmDFjcnJyvvnmm2+++UZ7qXLlysuXL3/zzTfNrr1bt24jRoxYunTpxYsXBw4cqE1XqVTvv/9+p06devToIYR4/fXXO3XqtHfvXsu2dsaMGadOnVKpVCtWrNAN5E2cODE6Ovry5csjRowIDg6uXLmy8UqbNWsmP8jCZ8+ePW7cuKI2pqgs3nUAgIqAJcwAAAAA/tamTZsLFy68//779erVs7e3d3V1bdOmzcqVK3/44YeizkcbNWrU+fPnR44c+fzzzzs5OTk6OjZo0CA8PPz06dNKITDTa1+yZMn27du7dOni5eVlZ2fn5eU1ZMiQ+Pj4BQsWvPrqq++//76rq6u9vb23t7dlW3v69OmZM2cKId555522bdvqlmBvby83LkxJSZGhQOO6du06a9Ysb29vW1vbWrVqVatWrThdZzqLdx0AoNxTaTSasm4DzJeZmZmRkSGEcHZ2NnsVg67PPvvs008/FUL8+9//HjBgQPELBMqf48ePt2zZUgjx1oAWUd+8VfwC8/Pzs7OzhRBqtdrW1rb4BeLZ9OTJExsbGxsbm7JuCEpEQUGBXFdobW1tZ2dX1s1BScnMzLS2trbUd3XI8HVR648JIY4cOdKqVSuLlFkcS5YsGTlypBAiPT3dycmpQtWOZ1Z0dHT//v2FEFOnTpX/Tim+R48eCSFYnQ0ARcIMRAAAAAAAAACKCCACAAAAAAAAUEQAEQAAAAAAAIAiAohmunnz5s2bN8u6FQAAAAAAAEDJUpd1A0pbVlbWunXrjhw58ujRo3r16jVt2vT111+3trbWzZOZmXnw4MFr1665u7u3atXK09NTr5A7d+6MGjXq7bffrl27dim2HQAAACgpHh4e7dq1E0Lo/d24ItQOAACMq1gBxLS0tOnTpyclJQkhKleufP78+fPnz58+fXr8+PEuLi4yT3Jy8vTp0+/cuSP/uH79+nfeeadbt2665axfv97V1bV79+6l3H4AAACghPTu3bt3794Vs3YAAGBcxVrCPH/+/KSkpIYNG65evXrt2rXLli3z9PQ8d+7cqlWrZIaCgoIvv/zy8ePHY8eOjY6OXrBgQb169VasWJGYmKgt5Nq1awcOHBg4cKCNjU0ZPQcAAAAAAABQSipQAPGPP/44e/ass7PzhAkT3N3dhRC1atWaMmWKtbX1/v377969K4S4fv16cnJyv3792rRp4+DgULdu3bFjx+bn5//222/acqKiory8vNq3b19mTwIAAAAAAACUlgoUQDx8+LAQ4qWXXtKuVhZCVK9e3d/fX6PRHDlyRAjx+PFjIUTVqlW1GapUqWJtbf3w4UP5x7Nnz8bHxw8ePFilUpVq6wEAAAAAAICyUIECiFevXhVCNGvWTC9dpsir9erVs7Oz++mnn548eSKv/vDDD/n5+Q0bNpR/jIqKatiw4UsvvVR67QYAAAAAAADKTgU6RCU1NVUIIRcv65IpKSkpQghHR8fQ0NClS5eGhYX5+/v/+eefycnJjRs3Dg4OFkIcOnQoISHhiy++KPW2AwAAAAAAAGWjAgUQMzIyhBC665clZ2dnIYR2yuErr7zi7u7+ww8/nD171s3NrX///v369VOpVPn5+evWrWvdurWfn18xW5Kenq7RaIpZiJSfny8/ZGVl5ebmFr/A7Oxs+WHhwoUxMTHFLxAof+7fvy8/5OcXaF+Z4tB+IeTn51ukQDyz8vPzCwoKyroVKFkFBZb5ZsCzSaPRWPC7Oj//v18IEydO1N1CB4DWjRs35IecnBy531Tx5eXlif/fvcpSDP+ZCQDlTAUKIMr4moODg166o6Oj0AmcCSFeeuklw0XKe/bsuXXr1qRJk4rfkuzsbEsFELXy8vLkL8Ji0jbs6NGjR48eLX6BQLmm0QbxLVOcxsIF4llD9LAi4EUu9yw6xP/9e9d//vMfCxUIlFsW//+sFiyN/fEBVAQVKIDo4uLy8OHDzMxMvXQ599D4/zLKzs7esGFD586dPTw85C3ffffdyZMnMzIy/Pz8Bg8e7O3tXXItL01t27adP38+UyeAp7KysmrfOTzTqndZNwQA8L+qfedq/974Dv9rAXgqOzs7uakUAKCsVKAAYtWqVR8+fJienq6XLlNcXV2N3Ltt27YnT54MGDBACJGdnf3RRx+lpKTUr1+/evXqp0+f/uCDD2bPnu3r62tiS6pUqWLWExQiKytLhkQdHR3t7OyKX2CXLl1SUlK0KzTxLCgoKEhPT3d0dFSrK9AL++xzcXGpVq2aRYrKzc2VX0T29vaGs6RRbjx48MDBwcHe3r6sG4ISkZ+f/+jRIyGEjY2N3B0F5dJff/1lY2Mj168U3+DBg7t162bZdZQoJvkiW1lZ8SI/U6pWrWrBf0PJv3cxxABQJBUoHiF/5RiGxh48eCCEcHNzU7rx0aNHW7Zs6dmzp9ybZsuWLSkpKe+9994///lPIcT169c//vjjZcuWzZs3z8SWWFtbm/cIhqysrLQfLFWsm5ubkd5A6cvPz3/w4EGlSpVsbW3Lui0oEdqlcCqVyoLfD3gGWfC7Gs8sXuTyTaVSWfZFrlGjRo0aNSxVGoovLS1NCGFtbW18egH+p8kVx3xXA0CRWJV1A0qPl5eXEOLUqVN66adPnxZC+Pj4KN24ceNGa2vrvn37yj+eO3euevXqMnooi+3QocPVq1cNF0cDAAAAAAAA/+sqUACxZcuWQogTJ07obvD36NGjs2fP2traKu2pcefOnZ07d77xxhu6a1X0dsmV0wDZvwYAAAAAAADlTwUKIDZq1MjPz+/BgweLFi2SCwazs7Nnz56dm5vbtm1bJyenQu9at25d1apVu3XrplvOn3/+uXfvXvnHlJSUffv2+fj4KJUAAAAAAAAA/O+qQHsgCiE+/PDDsWPH/vLLL/Hx8V5eXomJiTk5ObVq1QoJCSk0f1JS0sGDB0ePHm1jY6NNfO21137++eevvvpqz549zs7OZ8+eLSgoCA8PL62HAAAAAAAAAEpPBZqBKISoWbPmwoULu3Tp4uDgcOXKlSpVqvTu3XvevHkuLi6F5o+KivLy8mrXrp1uop2d3dy5c7t16/bw4cOEhIQXXnhh3rx5fn5+pfEAAAAAAAAAQOlSaTSasm4DzJeZmZmRkSGEcHZ2tre3L+vmoERwCnO5l5OT8+jRIyGEg4MDmyGUY2lpaU5OTg4ODmXdEJQI+V0thLC1ta1UqVJZNwcl5cGDB7a2tnxXl2OcwlwRyL938V0NAEVSsWYgAgAAAAAAACgSAogAAAAAAAAAFBFABAAAAAAAAKCIACIAAAAAAAAARQQQAQAAAAAAACgigAgAAAAAAABAEQFEAAAAAAAAAIoIIAIAAAAAAABQRAARAAAAAAAAgCICiAAAAAAAAAAUEUAEAAAAAAAAoIgAIgAAAAAAAABFBBABAAAAAAAAKCKACAAAAAAAAEARAUQAAAAAAAAAigggAgAAAAAAAFBEABEAAAAAAACAIgKIAAAAAAAAABQRQAQAAAAAAACgiAAiAAAAAAAAAEUEEAEAAAAAAAAoIoAIAAAAAAAAQBEBRAAAAAAAAACKCCACAAAAAAAAUEQAEQAAAAAAAIAiAogAAAAAAAAAFBFABAAAAAAAAKCIACIAAAAAAAAARQQQAQAAAAAAACgigAgAAAAAAABAEQFEAAAAAAAAAIoIIAIAAAAAAABQRAARAAAAAAAAgCICiAAAAAAAAAAUEUAEAAAAAAAAoIgAIgAAAAAAAABFBBABAAAAAAAAKCKACAAAAAAAAEARAUQAAAAAAAAAitRl3QAUi5WVlVqtFkKoVKqybgtKikqlUqvVVlaE+8st7YvMKJdvvMjlm/yuFkJYW1uXdVtQgqytrXmRyzd+I1cE1tbWGo2mrFsBAP9jVHx1AgAAAAAAAFDC/1sDAAAAAAAAoIgAIgAAAAAAAABFBBABAAAAAAAAKCKACAAAAAAAAEARAUQAAAAAAAAAigggAgAAAAAAAFBEABEAAAAAAACAIgKIAAAAAAAAABQRQAQAAAAAAACgiAAiAAAAAAAAAEUEEAEAAAAAAAAoIoAIAAAAAAAAQBEBRAAAAAAAAACKCCACQMUSFxc3fPjwJk2auLu729nZ1a1bt3PnzsOHDz948GBZN630/PnnnxMnTuzRo0dAQICDg8Nzzz3XpEmTIUOGxMbG5uXl6WW+d++eSqVSqVSrVq2yeEsKLTw/P18mzp071+I1FlO1atVUKtXkyZNLuqK0tDQbGxvZD82aNTOSs6y6KyoqSmUaBweH0myYxcXExMgHcXR0TExMLOXaS/QFBAAAgInUZd0AAEApOXXqVEhIyKlTp3QTk5KSkpKS4uLili9f3rZt2xkzZrRp06asWlgK8vLyJk6cuHjx4idPnmgTs7Ky7t69e+bMmaioqJdeemnDhg316tUrw0ZCCLFp0yZtMPf3339PSEjw9fUtUgk3b95MSUlRq9XNmzcvgQZWFI8fP46IiBBC1KlT59q1a8OHD9+zZ09ZNwoAAACljQAiAFQI27dv79u3b05OjhDC2dm5c+fOjRs3dnV1vXXr1tWrV3ft2pWRkfHzzz937Nhx586dHTt2LOv2lpRx48bNmzdPCGFnZzdgwICmTZt6eHjcuXMnKSkpOjr6xo0bJ06caNGixenTpz09Pcu6sRXa999/r/vH6Ojook57XL58eWRkpLu7+927dy3aNH0hISGtWrUyksHa2rpEG1CiJkyYkJKS0r9//+XLlwcGBu7du3fdunWDBg0q63YBAACgVBFABIDyb/fu3TJ6aG1tPXbs2PHjx7u4uOhmePDgwdy5c2fOnJmTk9OnT5+DBw+++OKLZdXakrN9+3YZPWzcuHFsbGzNmjV1r86YMWPWrFmffvrpgwcPBg8evG/fPpletWrVP//8UwhRqVIlizepRAv/33Xz5s1ff/1VCPHqq6/u378/IyNjw4YNpbBu2jwdO3YcOHBgWbeiRBw7dmzp0qUvvvji6tWrHRwcfvrpp5YtW37wwQddu3Z1c3MrnTbwjgAAADwL2AMRAMq5x48fh4SEyOjhli1bZs6cqRc9FEK4urpGRkZ+/fXXMv+UKVPKoqUlTj6gEOLHH3/Uix4KIWxtbadOnfr6668LIfbv3x8fHy/TVSpV9erVq1evXhI72ZVo4f+7oqOjNRqNEGLYsGHdunUTQly4cOHcuXNl3a4K59atWzNnzty6dav8+axbt+6uXbvGjBlz5cqVUmsD7wgAAMCzgAAiAJRzkZGRt27dEkKEhYX17NnTSM533303KChICBEbG3v79m3jxebn59+5c8ciLUxPT8/Pz7dIUcadOXNGCOHn5+ft7a2U51//+pf8cPjw4SIV/vjx46ysrOI0rxRYcNRKlFy/XKVKlVdeeUWGdIUQ0dHRZdqoEvGMj0ivXr3GjRvn5eWlTWnRosW4ceOML9kWQuTm5j558kRGgQEAAFAOEEAEgPIsPz9fHl3q6uo6ffr0p+aPjIwcPnz4sGHDkpKSdNPlebi7d+8WQmzevLlp06b29vYxMTFCiNu3b8szUjdv3mxY4LZt2+TV5ORkmbJkyRKVSvXCCy8IIaKionx9fV1cXNRqdbVq1Tp06LBmzZqCgoJC23bz5s2IiAh/f39nZ2cXFxd/f/+IiIiEhATTe0MeypGRkWEkT1BQ0CeffPLJJ580adJEpmRkZBR6CKyLi4tKpdqxY8fZs2eDgoIqV67s4ODg4uLSokWLNWvWyDyPHj0aP368n5+fo6NjzZo127dvv3PnTt1ClAo3Yt++fcOHD2/Xrl2NGjVcXFwCAgJ69Oixbds2w34zMmpPtX379u7du9eoUcPe3t7Hx+fdd9813tUZGRlffPFFYGCgm5ubi4tLkyZNwsPDL126ZOJD6bp8+bKc/vn666/b2dl1795dTj0zPYAYHh6uUqkiIyOFEGlpabKHFy5cqJvH9G60oKeOSFG7MTY2tk+fPrVq1bK3t/f29n7rrbeOHj0qhBgwYIDuYdlFfUnNaI/2dUhPT3/nnXfc3NycnJzs7e0bNmwYGhp67dq1Qtt/5syZsLCwevXqycPQg4ODFy9eLLdq1W2DkXekTMYRAACgItIAAMqvAwcOyG/7yZMnF6cctVothIiNjV28eLH2N8iyZcs0Go3cnkwI8cMPPxjeuHXrVnn12rVrMkWW0KhRo6lTpxb6iyk4OPivv/4yLKdq1aqGmW1sbBYsWGDiU/zjH/+Qd82dO9f0Z09PT5d3rVy5Ujfd2dlZCDFjxgz5Qc+ECROSkpLq1KljeOmrr74yXrj29OEvv/xSt8acnJwBAwYo/D4XXbt2zcvL081vZNSMyM3N/eijjwzLd3Bw2LJli7u7uxBi0qRJurf8/vvvtWvXNrxFpVLNnDnT9K6Wpk2bJm/ft2+fTOnTp49MOXnypGF+w+4aPny4YWO0PydF7UYl2jDxunXrTHw04yNSpG7My8sLCQkxzGxtbT1x4sTXXntNd5iK+pKa0R75FkRHRzdt2tTwFjs7u8OHD+vdMmvWrEKPl/Hz89NtidILaKlxBAAAgCkIIAJAefbZZ5/Jf04fOHCgOOXIwMfUqVOtra1r1ao1c+bMjRs3pqamaswNIDo4OKhUKiHESy+9NH369LVr144ePVq7L2Hv3r11C9m2bZtMt7W1DQsL+/bbb9esWRMWFmZrayvTY2JiTHkKbcRHCNGhQ4fvv//+8ePHT73LeABRRkAGDBiwffv2w4cPT5482cbGRgZZ5OMMGzZs9+7dP//886hRo+Qju7i4aOstUgBx9sVnHfMAABInSURBVOzZMt3X1/eLL76IiYnZsmXL7NmzfX19Zfq8efN08xsZNSOGDRsmS3N1dR0xYkRUVNTMmTPl2nYHBwfZ57oBxDt37ri6uspb3nzzzeXLl0dHR3/88ceVK1eWibNmzXpqJ+vy9/cXQtSqVSs/P1+mrF+/XhY1duxYw/xK3TVp0iQhhLu7u17+onajErMDiIWOSFG78eOPP9YOU3h4+Jo1a+bMmdO+fXvdIFpxAohFbY98HerWrSuE8Pf3X7p06ZEjR3bs2NGrVy+Z38fHp9Deq1GjxtixYzdt2rRy5cquXbvKRD8/v9zcXJlT6QW01DgCAADAFAQQAaA8007FSklJKU45MvChVqs7duz48OFD3UvmBRCl0NBQbZhAo9GkpKQ0b95cXjp69KhMzMvLe/7552UkSG8S06+//iqnJQYEBJgy26igoEDvtFwbG5s2bdpMnTr14MGD2dnZhd5lPIAohIiMjNRN110qvmjRIt1LI0aMkOnHjh0zUrhSRExu3fj8888/evRIN/2vv/6SUx179uypm25k1JScO3fOyspKRnAuX76sTc/Pz4+IiDCMTGk0GpmuVqu3bt2qW1RSUpKfn58QwsHBQW9qmxGnTp2SVXz44Ye6D2hnZyeEqFOnjuEtRQ0gFrUblWhDYKGhoSuV/fbbb9pbjIxIkbrxxo0b9vb2MnaWkJCgm1/3BKTiBBCLOqza16Fdu3Z6HSunQwohrl69KlMyMzPl3EZ/f//k5GTdzOPHj5eZo6KiZIrSC2ipcQQAAIApCCACQHnWu3dv+W9veaCBHqWNyYQQL7/8sm5OGfiwsrI6d+6cXiFmBxC9vLxycnL08ickJMg5fV27dpUp2jCN7spfrblz58qra9euNa1LNFFRUYUeAeHo6PjKK69s2LBBr1XGA4i+vr56scuLFy/K/E2bNi0oKNC99PPPP8tLGzduNFJ4oRGxrKwsT0/P2rVr6wUlpSFDhgghGjVqpJtoZNSUaE8sOXLkiN6lgoKCgIAAvchUUlKSnJP40UcfGZb2n//8R+afOHGiiQ0YN26cvOXEiRO66T169FBqWJECiGZ0oxLdCa1GjB49WnuL0ogUtRvDwsJkim50Ukv74212ANGMYdVOyD1//rxe/l27dsn8u3fvlina1zYuLk4vc25urpz5OHjwYJlS6DtiwXEEAACAKThEBQDKMxmwEEI8efKk+KUFBQU1bNiw+OVIo0ePlqt9dTVo0KBfv37i/9dcCyEOHTokhKhSpUpoaKhhIWFhYTJyIbOZ4u233z5y5EhiYuLKlSsHDBhQvXp1mf7kyZPY2Nj+/fs3aNDg999/N7G04OBgvX3cPDw85IeOHTvKNcta2h3lzDjhwc7O7vr16zdu3NCdCah19+5dpRuLNGq//vqrEKJTp06GMVaVSvXBBx/oJe7cuVMeeTF69GjD0jp06NCgQQNRlNGRJ6U0aNBAOxdVstRZzGZ3owUZjkhRu3HPnj1CiI4dO7788suG+ceMGVPMFpo9rK1bt9ZGmbW0h55r/v9Q5r179wohGjZs2LFjR73MarX666+/nj17dqdOnYy08FkYRwAAgApFXdYNAACUIHnkhRDi9u3bbm5uelfd3NyWLVumlxgVFfXbb78VWprc4MxSWrRoUWh6YGDghg0bMjMz//zzz5o1a165ckUI8fzzz8ujePU4OzvLeN/Vq1eLVLuPj09oaKgMSl64cCEuLm7z5s2//vprQUFBcnJyUFDQsWPHGjVq9NRytPFHLbkEWOjETQwvFZ9Go0lNTU1KSrp48eLu3bt37NihlNP0UXv8+LGcqlZoWEoI0bZtW72Uy5cvCyE8PDwKPW1DCBEQEHD58uVz586Z0oDffvtNzor917/+pXepZ8+etra2OTk5GzdunDt3rl5k1mymd6MR69at01sab5zhiBSpG3Nycq5fvy6Uh0npzTKd2cOq3X9Ql+GPvSz/xRdfLLTwN998s6gNtsg4AgAAwAgCiABQnvn4+MgPx48fN5wZ5Ozs/O677+olyslBhfL09LRg2wo9oVjohFeuXr2qDSAqZZaXzAgg6goICAgICBg1atSFCxfeeeedw4cPZ2ZmfvDBB0a6whQWDBdqnT9/ftmyZb/88ktCQkJmZqYpt5g+arKrhXLM0cvLq9BbUlJSjEf07t+/b0oDvv/+e/nhs88+057/oyclJeXXX3/VHqhtHjO60YIMR6RI3ZiUlCRnsNarV6/QbLVr11ar1dqV3WYwe1hr1Kjx1MLz8vKSk5OFJb5PynYcAQAAKhQCiABQngUHB8sPe/bsGTx4sCm3JCUlKV2S5zZYilJsQruuWXfZtZFAhlymnZWVZby6EydOXLp0SQhhZLJYQEDArl27GjdunJycvG/fvqysLMs+cjHNmTNnwoQJ+fn5QghbW9tmzZo1aNDAz88vKCgoOjp69erVhd5l+iPIg0qEcm/b29s7Ojrqjsvt27dNKbmgoCAvL0+7oF4pz6ZNm0wpLTo6ujgBRPO60YIMR6RI3ajdE1BpmKysrKytrYsTQDR7WE2ZGZqTkyPbpv15M0+ZjyMAAECFQgARAMqz5s2bV69e/fbt25s3b54/f/5zzz1nPP+NGzdM3/7PFEamnl27dk27XaAu7Tw4uRyyfv36N27cMHLei4x4yk3ZjIiNjZ08ebIQokOHDjVr1lTKVqlSpa5duy5btqygoCApKcnf3994saVm37598oCRRo0azZo1q3Pnzrrxl5iYmOJXUbduXZVKpdFolKZz3r17V28zTR8fn+PHjwcGBh4+fLiYte/fv18uoO7bt29ISIhhhtzc3DfeeCM3N3fTpk0LFy7U23rSRKXQjWYoUjdqJx4qDVNKSkp2drbptRu+pBYcVkOOjo61atVKTU2V8xDN82yOIwAAQDlGABEAyjO1Wv3ee+9NmTIlOzt74sSJK1asMJ5/5MiR2oMOiqrQG+Wkv0LFx8cHBQUZph87dkwIYWtrKxfM1q9ff//+/RcvXix0PmBmZmZCQoJQ2HxNl3Y19+HDh/v27WskZ2pqqvxguGtkGZJn/jo4OMTFxRluvFic6WZa9vb2NWvWTE1NPXr0aKEZTp06pZfi5+cnhEhMTNRoNIXOPpMTxFQq1VMXdGvXL0dERGhnzurp1KnTrl277ty5c+DAAcPzN0xRCt1ohiJ1Y5UqVdzc3O7du6c0TPHx8UoVmfiSWnBYC+Xr65uamqq0M+aMGTO2bt1avXr17du3K5XwbI4jAABAOcYpzABQzo0cOVJOuFu5cuX8+fONxAdXrVr1448/ml3RzZs39VLkkRdK+RcsWGD47/zExEQZSGrVqpWMTQQGBgohHj58uGrVKsNCvvnmm0ePHsn8xpvXrl07OUdp/PjxRtY737p168CBA0KIhg0bPnXCZmmS3Vu3bl3DcIlGozlx4oRFapGRu71798owrp45c+bopcizkm/fvl3oT05aWpqrq6tarZ4yZYrxenNycrZs2SKEqFmzppHlycU/i7l0urGoitqN8pgU04dJy8SX1FLDqkS+1MePHzec4VhQULBixYoTJ044OjoaKeHZHEcAAIByjAAiAJRzrq6uUVFRMhj34Ycf/vOf/zQMIjx48GDo0KHDhg0TQhS6rNiIatWqOTs7CyHWrVunGxDUaDSTJk0ysqNiUlJSRESEnMok3b59e+DAgbm5uUKIadOmycS33npLzof67LPP9MIlR44cmT59uhDC19f3qTs8enh4yAe8fPly8+bNCw0x3Lx5s3v37jIiaXZwpITUr19fCHH16tU7d+7opmdlZUVERMi5gbqdaZ6pU6fKpcFDhgxJTEzUvTRnzpy4uDi9/D179pTBrKFDhx48eFD3Uk5OztChQx8/fqxSqQpdkqxr9+7dDx48EEK8/vrrRia19erVS+64t2XLFvlz8lR6fVI63VhURe1G7Q+n4TBNmzbNMCpX1JfUUsOqZMyYMVWqVBFCvPfee7du3dK9NGPGDLm0uUuXLkZKeDbHEQAAoBxjCTMAlH+dO3det27d4MGDc3Nz9+7d6+vr26FDhxYtWri7uycnJ58+ffrYsWMPHz60srJavHixSqUKDw83vXArK6vg4OAdO3bEx8d36NBhzJgx3t7eFy9ejIqKio2NtbKykifGGnJwcFi2bNmpU6d69+5dp06d+Pj4f//73ykpKUKIbt26tWvXTmZTq9WzZ8/u06fP3bt3g4ODhw0bJqcvHT58eOXKlXKvtzlz5hg/oEOaNWtWfHz8kSNHLly4EBgY2KVLl5YtW7q7u+fl5d26devcuXOxsbEy6DBmzJg33njD9E4oBd26dVuxYkVWVlaHDh0mTZoUEBBw//79M2fOLFy4MDEx0cnJKSMj49KlS7t3727durWLi4t5tfj5+Q0ZMmTVqlUXL15s2bLloEGDWrZseffu3Z07d+7Zs8fOzq5u3boXL17U5lepVAsXLgwKCrp//37nzp0HDBgQGBjo6el5+fLl5cuX//HHH0KICRMmKJ0XrKVdv/zmm28ayebm5ta+ffu9e/feu3cvLi6ua9euRjLLH4mHDx/GxMT4+vpWrVq1Zs2apdONRVXUbgwMDOzVq9e2bdt0h+nOnTs7duyIi4tzcnLKy8vT3QaxqC+ppYZVSdWqVSdPnvzRRx+dOnWqefPmoaGhzZs3T09Pj4mJkRNRg4KCjEcnn81xBAAAKM80AICK4ZdffmncuLHSrwNfX9+4uDiNRnP+/HkhxMsvv6x7r4zFREZGFlry9evXq1WrVmix2tWU165dk5kXL14sU3bt2iVnIekZNGhQRkaGXhXz588vNERYtWrVmJgY0zvh4cOHQ4cONXJWrJWVVURERF5envYW7aG3K1eu1C1KTumaNGmSXhXa/IsXL9a7pD0KZsOGDUYK184R+/LLL3VvDw0NLbTBY8eO1V2F2rt3b5nf+KgpyczMfPXVVw0rsre337hxY//+/Q2fOi4urtCJq7Izn1pjRkaGk5OTEKJ27doFBQXGMy9fvlwWPnjwYJmi1F16y28XLFgg04vajUrkNnxCiHXr1j31GSXjI1KkbszIyHj77bcNMzs4OGzfvt3d3V1vmIr0kprRHqXXQaPRyICjECI2NlY3ffHixYUexNy0adOkpCRtNqUX0FLjCAAAAFOwhBkAKoo2bdqcPHly69atclFwpUqVHB0d69Wr99prr33//fdnzpyRp1L4+/vPmzcvIiLC9JI9PT3/+OOPjz76qEmTJjISJISoXLlyVFTU0KFDle76xz/+cf78+YiIiLp169rZ2VWtWjU4OHjt2rVr16413P5s9OjR586dGzFihK+vr5OTk5OTk5+f38iRI8+cOdO7d2/Tm1q5cuVVq1adPn16ypQpgYGBHh4ednZ27u7uzZs3f+2116ZNm5aQkLBo0SLzTvgtaStXroyJienUqZOnp6ednV2dOnVCQ0NPnTr1+eef9+3b9913361SpYqDg4M8fMZs9vb2P/3006ZNm7p16/bcc8/Z2tp6eHi8/fbbJ06c6NevX6G3dOzY8ezZs2PHjn3hhRcqVark4uLSrFmzIUOGnDlzZtGiRU+t8aeffsrIyBBC9OvXz0hsV+rTp48cna1btxo/a7hHjx4zZszw9va2s7Pz8PCQMTVRWt1ohiJ1o6OjY1RU1Pr169u3b+/m5mZra+vp6RkSEnLy5Mnu3bsbFm7GS1rMYX2q99577+jRo4MGDfLy8pID8corryxZsuTEiRN16tR56u3P7DgCAACUSyqNuadtAgBQqJs3b967dy8gIMDGxsbw6pIlS0aOHCmESE9P1wYyAFhQtWrV0tLSJk2aJDcJNWT8JQUAAAD0sAciAMDCateuXbt27bJuBQBFvKQAAAAoEpYwAwAAAAAAAFBEABEAAAAAAACAIgKIAAAAAAAAABSxByIAoFTVrl27U6dOQohn86RjoBxo06bN/fv3vb29y7ohAAAAKCc4hRkAAAAAAACAIpYwAwAAAAAAAFBEABEAAAAAAACAIgKIAAAAAAAAABQRQAQAAAAAAACgiAAiAAAAAAAAAEUEEAEAAAAAAAAoIoAIAAAAAAAAQBEBRAAAAAAAAACKCCACAAAAAAAAUEQAEQAAAAAAAIAiAogAAAAAAAAAFBFABAAAAAAAAKCIACIAAAAAAAAARQQQAQAAAAAAACgigAgAAAAAAABA0f8Bq88XFRzCBWEAAAAASUVORK5CYII=" alt="Fluxo de tonicidade no Grupo Similar de Alta Frequência" width="864" />
<p class="caption">
Figura B.1: Fluxo de tonicidade no Grupo Similar de Alta Frequência
</p>
</div>
<p><br></p>
<div class="figure"><span id="fig:fluxo-2"></span>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABsAAAASACAIAAADOHB9sAAAACXBIWXMAAB2HAAAdhwGP5fFlAAAgAElEQVR4nOzdeZhU1YHw/1PdDc3SCCoJJiiLskQxOi6oUV9RQRMhcZKoWV6NSFBGwGA0EXAdjQoYlUEcEFBJQEgUl8REzQSMog6Gn4YoEgVRQVBAUQHZml7r98edqfTbcKGX6q7q6s/n8clT3Lp96jSdKrq/fc6tRDKZDAAAAAAAe5KX6QkAAAAAANlLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERAAAAAIglIAIAAAAAsQoyPQHqpaKioqysLITQokWL/Pz8TE+HBpFMJktKSlq2bJmXp/jnpsrKytLS0hBCfn5+ixYtMj0dGsquXbu8Vuew6LU6hJCXl9eyZctMT4eGUlJSkpeX57U6h+3atSuEkEgkCgsLMz0XGkr0fZfXaoBa0SOattLS0u3bt2/fvj3KiOSkysrK7du3l5eXZ3oiNJTy8vLoiRx9O0uu8iXObdFr9fbt26P6QK7auXOnJ3Jui57IO3fuzPREaEC7du3yWg1QWwIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgFhHH3744YcffpjpWQAAAABAwyrI9ARq4bnnnps2bdrkyZMPOuig3e/dtWvXnDlzFi9evHXr1sMOO+xf/uVfzj///Pz8/DqcVlxc/MILL7z//vsdO3Y88cQTDznkkGqDbNy4cdSoURdffPHBBx+c3s8RAAAAALJKUwqICxYs2LVr1x7v+vTTT2+99dbVq1eHENq3b//mm2+++eabS5cuvfbaa9u1a1er09asWXPrrbdu3Lgx+uPcuXMvu+yygQMHVn24uXPn7r///oMGDWqITxMAAAAAskfT2MK8c+fOmTNnvvnmm3En/Md//Mfq1av79Okzc+bMhx56aNq0aYcccsg//vGPBx98sFanVVZW3nXXXdu2bRs9evQjjzwyadKkww477P7771+1alVqkPfff3/hwoUXXnhhixYtGujzBQAAAIAske0B8dlnnx09evTgwYN///vfx52zYsWKZcuWFRUVXXfddR07dgwhfPnLX77pppvy8/Off/75Tz75pOanrV27ds2aNRdccMGpp57aunXrQw89dPTo0RUVFX/9619TDzdr1qwuXbqcccYZDfuZAwAAAEAWyPaA+P77769fv76wsHC//fZLJBJ7POfll18OIRx//PFVdyt36tTp8MMPTyaTixcvrvlp27ZtCyEccMABqRM6dOiQn5+/ZcuW6I/Lli1bsmTJ4MGD4yYDAAAAALkk2wPipZdeOud/VQ1/Vb333nshhGOPPbba8ehIdG8NTzvssMMKCwv/+Mc/7ty5M7r3scceq6io6NOnT/THWbNm9enT5/jjj0/HJwcAAAAA2a4pvYlKnPXr14cQol3JVUVH1q1bV/PT2rRpM3To0KlTpw4bNuzwww//6KOP1qxZc9RRR/Xr1y+EsGjRopUrV955550N+/kAAAAAQNbIhYC4Y8eOEMLu6xOLiopCCKm1hDU87Rvf+EbHjh0fe+yxZcuWHXjggT/4wQ8uuOCCRCJRUVExZ86ck08+uXfv3vWc8NatW5PJZD0HiVRUVEQ3iouLS0pK6j/g5s2bx4wZk3oTarJE9H8YG+ezSlFR0W233datW7f6D1VZWRndKCkpKS8vr/+AZK1du3aVlpZmehY0iNS/7OXl5Z9//nlmJ0PDqaioSONr9Zo1a66//vrt27enZTTSIvVc9n1XVvniF784YcKEqleaqo/oKZzG1+pEIrHffvulazSA7JQLAbGsrCyE0Lp162rH27RpE0JIZbUanhZCOP7443ffpDx//vwNGzbccMMNaZlwugJiSkVFRSom1sfs2bPnzZtX/3GgOejYsWN6lyRXVlamYiI5KV2v1WQzT+Scl8Yv8T333PPUU0+lZSjIeYcffvgVV1yRxgGjHw/TQm4GmoNcCIjt2rXbsmVLcXFxtePRosLUksManrZHJSUlDz/88FlnndW5c+foQ2bPnv33v/99x44dvXv3Hjx4cNeuXdP16WRWtE4TqInlr658/M6nMz0LAJqq5a+szPQUoMlI7RgDICNyISAecMABW7Zs2X33R3Rk//33r9Vpe/Tkk0/u3Lnzhz/8YQihpKTkZz/72bp163r06NGpU6elS5deddVVEyZM6NWrV80nXMMz96m4uDj6p7Rt27atWrWq/4CpFZr333//eeedV/8BIfe89tpr/fv3DyEU5Bfsvqi5DioqKqJtrQUFBS1atKj/gGSn4uLiFi1aFBTkwr+87C6ZTO7atSuEkJ+f37Jly0xPh4aya9eu/Pz8dL1W5+fnRzcWLFhw3HHHpWVMyDG/+93vhg4dGkJo3br1gQcemJYxt23bFva1ggSAanLhx5gOHTqEEDZt2lTt+ObNm0MIqX9manja7rZu3frEE0+ce+65Ufh74okn1q1bN3LkyK9//eshhLVr115zzTXTpk2bOHFiDSecxiXuqaESiURahk0N0rZt271HVWi2/vntZiI9T+eqg9gCk/N8iXNV1YuT+CrnvLR9if93mHbt2vm+C/aobdu20Y10/byT4rUaoFbyMj2BNOjSpUsI4fXXX692fOnSpSGE7t271+q03c2bNy8/Pz+1HO8f//hHp06donoYDXvmmWe+9957u2+OBgAAAICmLhcC4gknnBBC+Nvf/lb1jVC2bt26bNmyli1b9uvXr1anVbNx48Znnnnme9/7XvReK5Fqv63Ky8sLVd5HFQAAAAByRi4ExCOPPLJ3796bN2+ePHly9O6WJSUlEyZMKCsrO+2001KL3mt4WjVz5sw54IADBg4cWPXhPvroowULFkR/XLdu3XPPPde9e/e4EQAAAACg6cqFayCGEK6++urRo0e/9NJLS5Ys6dKly6pVq0pLS7/85S8PGTKkDqelrF69+oUXXvjpT39a9VLZ3/3ud1988cV77713/vz5RUVFy5Ytq6ysHD58eMN+hgAAAACQCbmwAjGE8KUvfemee+45++yzW7du/e6773bo0OHb3/72xIkTq721Vg1PS5k1a1aXLl1OP/30qgcLCwvvvvvugQMHbtmyZeXKlV/96lcnTpzYu3fvhvvsAAAAACBTmtIKxDlz5uzl3gMOOOCKK67Y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UVFRUe/evUeMGPHmm29WPae4uLhnz56JRKJHjx7FxcXVRnjiiSeit1q+9957UwcXLVoUHVyyZEl0ZPjw4YlE4uabbw4hbNmyJbr3jjvuqO1kIu3atUskEk8++eSOHTsuv/zyjh07FhUVtWrV6ogjjhg8ePC77767x0/2hRdeGD58+BlnnPGlL32pXbt2hx9++KBBgx5//PGKiopa/8UBQEMSEAEAgKzw1FNPHX300ZMnT16+fPmOHTt27NixcuXK++677+ijjx4/fnzqtNatWz/44IOJROK9996LCmDK559//pOf/CSEcNppp11xxRWNMJmqiouL+/XrN3369K1bt4YQSktLly9fPnv27COOOOK5556remZ5efmPfvSj008/fdq0aQsXLvzoo4+2b9++YsWKZ5555vzzzx8wYEBZWVl9Jg8A6SUgAgAAmffUU09961vf+vTTTwsKCoYMGTJjxoyZM2cOGzassLCwoqLiuuuumzNnTurk0047bcSIESGEu++++7XXXksdHz169Pr169u2bfurX/1q79uHp0yZUl5eftNNN4UQ2rdvX15eXl5ePnr06DpMJuX6669fsmRJr169pkyZsnjx4meeeeaCCy4IIZSVlV100UXl5eWpMydNmhSN0L1799tvv33evHmPPvro+PHje/fuHUJYuHDhuHHj6vF3CQBpJiBChl166aXRlplrr70203MBAMiMioqKMWPGhBD233//Z599dubMmZdddtmQIUOmT5/+wgsvfPGLXwwh3HTTTaWlpakPmTBhQteuXSsqKoYOHRq1uRdffPH++++P7jr00EP3/oh5eXn5+fl5eXkhhEQikZ+fn5+fHzXHOkwmsmrVqlNPPfXVV18dMWLEiSeeeM4558ybN+9HP/pRCGHDhg1vvfVW6sypU6eGEHr06PH3v//9uuuuu+CCC84///yxY8f+7W9/69mzZwih2opFAMgsAREy6emnn37wwQdDCOPHj0/thfnggw8WLVq0ePHijE4NAKDxzJ07N+pr119/fb9+/aredeKJJ95yyy0hhNWrV8+cOTN1vKioKMqFr7322sSJE0tKSoYNG5ZMJvv16zdy5MhGnkwkLy9vypQp++23X9WDw4YNi26kroRYWlpaXl5+8MEHjxgxokOHDlVPLioq6t+/fwhh1apV9fkUACC9BETImM8+++zSSy/Ny8ubOnXq2LFjU8dnzpx56qmnnnPOORmcGwBAY1q0aFEIoV27dpdffvnu9w4ZMuTAAw9MnZZy1llnDR06NIRw8803Dxs27O23327btu3MmTPr+d7HdZtMCOGEE0446qijqh1MvQF0MpmMbrRs2XLt2rUffPDBVVddtfv4n3zySX0mDwANoSDTE4Dma/jw4Z9++uns2bMvvPDCTM+FNPjRv19Qtw8sLS2NLrXeunXrtm3bpnVSZJFPP/20bdu2rVu3zvREaBAVFRWbN28OIbRs2bLa4iNyyebNm1u2bFnP1+p7Fr8c3Sh9pU14PR3TygnR6rxevXrt8a+3sLDwiCOOeOmll957771qd919991/+tOf1q9fP3v27BDCL3/5y31uXm64yURXMKwm2iW9F8lkcsOGDatXr16xYsWCBQsef/zxuk4cABqKgAiZkUwm77zzznvvvbdTp06Zngvp8dAtj9b85DrXRgCyUyoLUjdRs+vevXvcCd26ddtjs2vfvv2UKVO+853vhBD69u07fPjwDE7moIMOqvmjLF++/L777nvppZfefvvt4uLiuk0VABqHgAiZkUgkUvtZGkdZWVlpaWmbNm3quamHtKhaGysqKkpKSkIIBQUFLVu2TB0XGQGyRCoOFhcX5+fnV32tJl1S23vjFBQUhBB27dq1+11vvPFGdOOtt95as2ZNt27dMjWZmn+Xddddd40dO7aioiKE0KJFi2OOOaZnz569e/c++eST//CHP9x33321nzUANCABEfZt/fr1d9xxx4IFC9auXRtC6Ny5c//+/UeOHNmnT5/UOcXFxUcdddS777572GGHLVu2rNouxSeeeOK8884LIUyePPknP/lJdHDRokWnnnpqCOFvf/vbcccdF0IYPnz4tGnTonu3bNkSfQ86YcKE6H0Aaz6ZSLt27bZv3/773/9+wIABP/vZz377299u3bq1ZcuWhx12WN++fW+88cYePXrs/sm+8MILDz/88IoVK1asWLF9+/aDDz740EMP/fGPf/ztb387Pz+/nn+T1Mo+lzQqjADpYv1gxvXs2fODDz54//33405YvXp1dFq142+88cZtt90WQsjLy9uxY8ewYcPmz5+fqcnU0PPPP3/NNdeEEPr06TNu3Lizzz67VatWqXv//Oc/121YAGg4AiLsw1NPPTVkyJBPP/00dWTlypUrV66cMWPGrbfeeu2110YHW7du/eCDD55++unvvffezTfffMcdd6TO//zzz6NoeNppp11xxRWNMJmqiouL+/Xrt2TJkuiPpaWly5cvX758+W9/+9v/+q//OvPMM1NnlpeXDxkyZM6cOVU/PCqJzzzzzOmnnz5//vwWLVrUZ/6k194Lo7wIUI1KmM169Ojx3HPPvf322zt37mzTpk21e8vKyqK3Re7Vq1e145dccklZWVnfvn0vueSSkSNHLliwYNasWYMHD278ydRcdLnGwsLCZ599dvddz+Xl5XUbFgAajoAIe/PUU09961vfCiEUFBT86Ec/+trXvlZQULB48eJZs2aVlJRcd911hxxyyEUXXRSdfNppp40YMWLKlCl33333D37wg2OOOSY6Pnr06PXr17dt2/ZXv/rV3je2TJky5T//8z9/8Ytf/OIXv2jfvv1nn30Wqlx4u1aTSbn++utXrVrVq1evK6+88rjjjtu0adOvfvWrRx99tKys7KKLLlq7dm20ByeEMGnSpKgedu/e/dJLL+3Zs2cikXj33Xd//etfv/322wsXLhw3bty///u/p+vvloYWlxeFRSDnCYVN0de+9rUZM2Zs27Zt+vTpu7838a9//euNGzeGEE466aSqx8eNG/faa68VFBQ88MADX/3qV3/zm98sWrTo6quv/sY3vlGfy0zXbTI1t27duhBCt27ddq+HyWTylVdeqduwANBwBESIVVFREe0d3n///X/3u9/169cvOj5kyJAf//jH55577saNG2+66abvfe97qWshTZgw4amnnlqzZs3QoUNfeeWVgoKCF1988f7774/u2ud7AkatMPrfRCJRdctwHSYTWbVq1amnnvr000+n3hX0nHPOufjiix966KENGza89dZbRx11VHR86tSpIYQePXq8+uqrHTp0SI1wxRVXHHvsse+8885zzz0nIOYAYRHIGUJhLrnooovuuOOOFStW3HbbbSeccMIpp5ySuuvVV1+98cYbQwhdu3YdNmxY6vjSpUtvv/32EMKYMWOi72emT59+zDHHbNq0adSoUY888kjNH73aor86TKZWevbsuWDBgtWrV2/YsOFLX/pS6nhJScno0aOjgBhdHhEAskRepicA2Wvu3LnR/pTrr78+FewiJ5544i233BJCWL169cyZM1PHi4qKolz42muvTZw4saSkZNiwYclksl+/fiNHjmzkyUTy8vKmTJmSqoeR1Pe70ZsMhhBKS0vLy8sPPvjgESNGVK2H0SfVv3//EMKqVavq8ymQ5R665dHd/8v0pAD+6Z7FL1f7L9MzIp0KCgqiK8Bs2rTpzDPP/Ld/+7dZs2Y99NBDI0eOPO200z7++OMQwvjx41PXCkxtXu7Vq9cNN9wQHezTp0/0C9d58+b94Q9/qOHjhhC2b98+b968t956K1obWNvJ1NagQYNCCKWlpf379//Nb37zxhtvLFy48N577z3yyCMnT55cVFQUQtiwYcPjjz++devWuj0EAKSXFYgQa9GiRSGEdu3aXX755bvfO2TIkBtuuOGzzz5btGhR1RPOOuusoUOHPvjggzfffPObb7759ttvt23bdubMmfV87+O6TSaEcMIJJ6TWGKak3gA69SaDLVu2jN6VZY8++eST+kyepmv3hmihItAIxMHm6dxzz73nnnt+/vOfl5aWzpgxY8aMGam72rdvP3369O9///upI7fffvvrr7+eSCTuv//+qiHv+uuvf+SRR955550RI0b069evffv2e3/QY489NroRDZ5687paTaa2Bg4cOGLEiKlTpy5fvvzCCy9MHU8kEldeeeWAAQOiq9acf/75AwYMWLBgQZ0fCADSRUCEWNHqvF69erVt23b3ewsLC4844oiXXnrpvffeq3bX3Xff/ac//Wn9+vXRFbJ/+ctf7nPzcsNNpnfv3rufn7quYpxkMrlhw4bVq1evWLFiwYIFjz/+eF0nTq6RFIGGoBgSGTVq1DnnnDN58uRnn332gw8+SCaTnTt3HjBgwJgxY1K//gwhLF26dNy4cSGEyy677LTTTqs6QqtWraZPn37mmWeuW7duzJgx06ZN2/sjnnPOOePHj582bdqGDRs6duz4hS98obaTqZspU6YMHDhw8uTJK1as+Pjjjzt16nTmmWeOGjUquoj2lVdeOXv27OLi4vo/EACkhYAIsaJm171797gTunXrtsdm1759+ylTpnznO98JIfTt23f48OEZnMzuF+fei+XLl993330vvfTS22+/XVxcXLep0txUS4p6IlATiiFxevbsee+99+79nKOPPrq0tDTu3jPOOCO1xyLllFNO2f1gZOzYsWPHjq3zZCLbtm2Lu6tz5857fOhBgwZFe5l3N2nSpEmTJtXkcQGgcQiIECvuu8yU6KI5u3bt2v2uN954I7rx1ltvrVmzplu3bpmaTM23Tt91111jx46NrtjdokWLY445pmfPnr179z755JP/8Ic/3HfffbWfNc2RngjskWIIANB0CYgQq2fPnh988MH7778fd8Lq1auj06odf+ONN2677bYQQl5e3o4dO4YNGzZ//vxMTaaGnn/++WuuuSaE0KdPn3Hjxp199tlVLyf056Si+vgAACAASURBVD//uW7DQtWeKCZCcyMaAgDkBgERYvXo0eO55557++23d+7c2aZNm2r3lpWVRW+L3KtXr2rHo/cE7Nu37yWXXDJy5MgFCxbMmjVr8ODBjT+Zmosu11hYWPjss8/uvuu5vLy8bsNCVWIi5DzFEAAgJ+3jjRSgOfva174WQti2bdv06dN3v/fXv/71xo0bQwgnnXRS1ePjxo177bXXCgoKHnjggeHDh59yyikhhKuvvvrjjz9u/MnU3Lp160II3bp1270eJpPJV155pW7DQpyHbnm06n+Zng5QL/csfjn6L9MTAQCgQQiIEOuiiy76yle+EkK47bbbFi1aVPWuV1999cYbbwwhdO3addiwYanjS5cuvf3220MIY8aMOeqooxKJxPTp01u0aLFp06ZRo0bV6tGrLfqrw2RqJdr7vHr16g0bNlQ9XlJS8tOf/jQKiNHlEaEhKInQ5KSioW4IAJDzbGGGWAUFBXfccce//uu/btq06cwzz7zkkktOPvnkvLy8xYsXz5w5M3q7kvHjx6euFZjavNyrV68bbrghOtinT58xY8bcdttt8+bNu/DCC88999yaPG4IYfv27fPmzTvyyCPbt2/fuXPn2k6mtgYNGjR16tTS0tL+/fvfcMMNRx555KZNm5YtWzZ58uR33323qKho+/btGzZsePzxx88666z99tuvbo8C+2SbM2QzrRAAoHkSEGFvzj333HvuuefnP/95aWnpjBkzZsyYkbqrffv206dP//73v586cvvtt7/++uuJROL++++vGvKuv/76Rx555J133hkxYkS/fv3at2+/9wc99thjoxvR4BMmTBgzZkxtJ1NbAwcOHDFixNSpU5cvX37hhRemjicSiSuvvHLAgAHf+ta3Qgjnn3/+gAEDFixYUOcHgppLxUQlETJLNwQAaOZsYYZ9GDVq1JtvvnnFFVd85Stfadu2bZs2bXr27Dl8+PClS5dWDXZLly4d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Bxt+eW5u7ocffrhw4UJty6VLl5YvX/7VV1+tWbOm8PVPnz6NiIhYt26dbuOZM2fOnDmzY8eO7t27b9++XbfgrrT9i8jx48dff/31q1evaltOnDhx4sSJzz//fPbs2VOmTDG8orJZl2HR0dEzZ87UPrxz587+/fv379+/atWqbdu26d6G0iLjGt9Jv379Fi1aJCKbN29u2bKlXj8PHjzYtWuXiPTo0aNq1ap6z8bGxo4fP97koUtkZlcmLM2ED6wFESACgEsrnME53L5mIUmEPXnlka+Xl5etZ1E00kMAgK5t27b17t1bRDw9PYcMGfLiiy8qinLo0KFVq1bl5ORMmDAhKt/D7gAAIABJREFUODhYvUDXlClTUlNT1bqnFi1apKenL1++fOvWrdnZ2QMGDEhNTTU86JdffqkGatWrVx88eHDr1q3v37//zTfffP/99+fOnXv11VdPnTrl7m4oqRgzZszKlStFxN/fv3///m3btr127drOnTt/+eWXAQMGaHNJrUWLFqkRT/369d9+++26desWFBScP3/+iy++OH/+/Pfff79kyZKJEyea3P/t27c7dep07949EenXr1+nTp0qVap09OjR5cuX379/f+rUqYqifPjhh4bfljJYlwEpKSkfffSRiLRq1apXr161a9c+duzYhg0bbty4cfDgwYiICN3yPYuMa3wnbdq0qV279qVLl7Zs2fLxxx/r9bN9+/YnT56ISOEzgv71r399/PHHzzzzzPjx4+vWrfvyyy9b/H0zs6vSLs20D6wFESACAEScoiBRSBJhay8/LC92ecsgokMAgJ68vLzJkyeLSJUqVbZt26atHIyIiBg8eHDPnj3v3r07bdq0119/Xa+EKjU1NTw8fNu2bX5+fmpLjx49+vTp8+233168eDE1NbVOnTrFDfrkyZO//e1vItKwYcNdu3bVqlVLbR8+fPjUqVPnzp177ty5tWvXDh48uLgekpOTv/jiCxEJDQ3dsWNH3bp11fbJkydPmDDh008/LfySZcuWiUiDBg0OHz6snbOIjBkzJiws7NKlSwcOHNCmPCb0P2vWrHv37rm7u2/atKlXr15q45tvvjl27Nhu3bqdO3fuo48+6t+/v+HKSmuvy7CsrCwRGT58+GeffaamtwMHDvzggw969ux57NixLVu2HD58uE2bNhYct1SdvPnmmwsWLEhOTr5w4UK9evV0+/n6669FJCAg4M9//rPeELNnzw4PD//mm28qVqxo8tAWXEWRjF+ayR9YC+IeiACA/+MEt0dUcZNElLHwJxVfflje1rMoGukhAKCwhISEs2fPikhUVJTevuN27dpNmzZNRE6fPq23PVNENBpNbGysblwiIm+//bb6xe+//25g0Li4OHWf76effqpND1UfffSRv7+/iOzbt89AD9HR0eqt5b788kttyiYibm5uixcvbtSokd712dnZ+fn5QUFBY8eO1ZtzhQoVwsPDRUS3arK0/V+6dOnzzz8XkXfffVebHqpq164dFxcnIllZWStWrDCwqDJYV4lq1aq1bNky3drPZ555Zt26dWoaFR0dbcFxS9vJm2++qX6hdx9D7Sbft956y9PTU2+U/Pz8xYsX66WHFnzfLNKV8Usz+QNrQQSIAAB9ThYjkiTCqjpmV7LbOx4K6SEAoBi//PKLiFSqVGn48OGFnx05cqSvr6/2Ml0vvfRS4TxLW15XUFBgYNC9e/eKSOPGjTt31v+zxt3dfdmyZfPmzevSpYuBHn7++WcR6dKlS9u2bfWeUhSlcLWXl5fXH3/8ceXKlcjIyMK96Z5NYVr/3333nXr2y4QJEwr336lTJ7WsrPDbaOa4pV1XiSZMmODh4aHXWK9evb59+4rIgQMH1O+sRcYtbSctW7Z87rnnRGTLli267dpNvkWWrLZr165xY/2/BVjwfbNIV8YvzeQPrAWxhRkAULTibo/oiHlc4Q3agEXYc3QopU8PiQ4BwHWopYINGjTw8fEp/Kyvr2+9evX+/e9/p6Sk6D1Vv379wte7uRlVnHThwgURad68eZHP9uvXz/DLHzx4kJaWJiIvvPBCkRe0b9/ecA8FBQXXr1+/ePHimTNndu/evXPnTjP7V1dUs2bNoKCgIl/SqFGjCxcunDp1ysCsrL0uY7Ru3brI9hdffHH9+vVZWVlpaWk1atSw+LhGdvLmm2/OnTs3MTHxxo0b2mls3LhRROrXr184dRURA1vpjR/67t276v5uXQEBAYU/NSa/FUYuzeQPrAURIAIASqCXvhEjAmL30aGQHgIADFLziNq1axd3Qe3atYvMI6pXr27aiLm5uZcvXxaRZ5991rQetPuji8uG9LZFayUnJ3/22Wc//fTT+fPnC+dB5vSvvuTatWuKohiYue6xuRYZV2XkuoxR3E+CdkopKSnaeMsi45aqk379+s2dO7egoGDbtm2jRo0SkQcPHuzevVuKOj5FZeDHzPihx40bt379er3GTZs29enTx4RVFMnIpZn8gbUgAkQAgFEKx4iOmCEKB63AbPYfHQrpIQDAOAZiL/V2eOo+SiNfYlhOTk5ubq6IeHl5mdaD9oXFzcHb27tcuXKPHz/WbVywYMHUqVPVU4w9PT1btGhRr1690NDQdu3abdiwQT26xOT+b968aczM8/Pzc3Nziztd2trrMkZxQ2v3NWtHt8i4pe0kLCwsNDT03LlzmzdvVlO2bdu2PXnyRFGUgQMHFjmEt7e3RYa24CqKVKqlmfCBtSACRABAKejGiI5biqiiIBGl5RDRoZQyPSQ6BADXVLdu3StXrly6dKm4Cy5evCgieifDmqNcuXLPPPPM9evX1TpEE9SpU0dRlIKCguLKrG7fvq2Xsu3bt089u7ZJkyZz587t2rWrbnypd3KFCf2HhIQcOXLkxRdfPHTokGmLMm3cUq3LGJcuXapZs2bhdm11pLp13SLjmtbJm2++OWvWrH379t2/f79ixYrqIcUdO3YsrjzTIkOvW7euuGNJLPgtMGZpZf+BLYxDVAAApaYbGjro+SpanLICI5EeAgCciXrU75kzZ4osWcrKyjp//rwUc8dDk6m9FXdDwNmzZ7du3frPf/5zcS/39vZWd9H++uuvRV5w/PhxvZZVq1aJiI+Pzw8//PDnP/9Zr/hRrYg0p//Q0FARSU1NLe70mLy8vLy8PPWE5eJYe13GOHbsWJHthw8fFhFPT081zLLIuKZ1oh5Y/PTp0++++057SHFx+5ctO7S1uzJmaTb5wOohQAQAmEIvdyNGhBOz83OWdZEeAgCM9OKLL4pIRkZGfHx84WeXL1+emZkpIkUeT2HmoEeOHClcr5efn79ixYqjR4+WK1fOQA8dOnQQkb1796rBlp4FCxbotVy9elVE6tSpExgYqPdUQUHB0aNHzey/ZcuWInLz5s1t27YVvv7OnTv+/v7u7u4zZswofk2mjFvadZUoJiamcOaVmpqq1t+1bdtWPSfHIuOa1kmTJk3U4783b968bdu27Ozs8uXL/9d//ZcxI5o5tLW7MmZpNvnA6iFABACYrnCMaMPJmE9dDkkidDlKdCilSQ9PHutMeggALm7QoEFq9dzMmTP1QqvExMRZs2aJSP369Utb4WXY+++/X6lSJREZN27cjRs3dJ+aPXu2urX5T3/6k4EeoqKiNBqNiAwZMiQ1NVX3qQULFvzwww9616t1WykpKbdu3dJtf/LkSWRkpFrZp97DzrT+e/bsqZ5fPGzYsIMHD+o+lZOTM2zYsAcPHiiKMnToUAOLKoN1lejixYuRkZG6L7l58+aAAQOePn0qIh999JEFxzW5E7VS7/vvv1+9erWI9OnTx9fX1/g1Wmr+Fu9KjFiaTT6weggQAQDm0g3dHL0UUUWMCHGowkMpZXpo1ZkAAByCu7v7vHnzROT27dsdOnSIjIxcu3bt2rVrx48fHx4enp6eLiILFiwo7twP0wQEBEyfPl1Ejh8/3rJly+nTp2/ZsiUhIaFPnz5qjV67du0MZ22hoaFDhgwRkTNnzrRp02bChAlr165dvHjxq6++OnnyZC8vr4YNG+pe36NHDxF58uRJp06d1q9ff+LEiQMHDixZsqRx48axsbHly5cXkXPnzu3evfvBgwcm9K8oyuLFixVFuXv3bteuXSMiIj777LOdO3fGxMSEhYVt375dRKZOnfrcc88Zfmesva4S+fj4fPbZZy+//PL8+fM3bNgwadKkli1bJiYmqmOFh4dbcFyTO+nXr5+IPHz4cM+ePSIyePBgY5ZmpffNst+CEpdmkw+s/hys1zUAwKWEhTd2gjOadXHKistyoNxQ2LYMADBV7969//73v3/wwQdPnjxZunTp0qVLtU8FBATEx8f36tXL4oP+9a9/9fLyeu+9927cuPHxxx/rPvX8888nJCSohXgGLF269ObNmzt27EhPT1+8eLG23dvbe/Xq1d9+++2ZM2e0jb179x4+fHh8fHxycnL//v217W5ubpMmTWrVqtWbb76Zn5/frVu33r17qwdflKp/EXnxxRf37t0bERFx7dq11atXqxVk2lHGjRunt0xbrcuwb7/9tn///omJiWpoqDVw4MDPP//csuOa3EmDBg2aNm168uRJEQkKCurYsWOJ67LU0Fbtysil2eQDq4sKRACAxThfKaJQjeh6SA8BAK5jwoQJp06dGjt2bP369cuXL1++fPnQ0NDx48efOHGid+/eVhp03Lhxv/7668CBA2vVquXl5VW7du1u3brFxsYePXq0du3aJb7c29t7+/btX3/9dY8ePapVq+bp6VmzZs3BgwcfPXq0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qG5jfHnvgRQWFoYQotXTtaxduzZ6sW7duk2bNvXq1SuRt9OApCeT+NLp5B4dkCpRhtgKy5mlhwAAkG8EiOSFjRs3du/evW57/AyQvn37hhCee+65733veyGEQYMGzZw588wzz6yZDP7+979v0qB9+/b94IMP3nvvvQZmFR+6prVr195xxx0hhDZt2uzevXvixIlPP/10k4ZO4WQSlNpHByStpTNE6SEAAOQheyCSF1avXl1v+0svvRS96NOnTwgh2nOwffv2zz777NixY2vVFVZWVjZp0KjPDRs27Nmzp+7Vffv2Rcci9+vXr1b75Zdfvm/fvmHDhs2ZMyeE8MwzzyxatKhJQ6dqMolL7aMDkpOW01QAAICcJ0AkL/zsZz+rm2Ft2bJl4cKFIYTBgwd37NgxhLB58+YQQq9evepu/FddXR1PGxN0yimnhBC++OKLefPm1b36y1/+ctu2bSGEk08+uWb7zJkzX3nllcLCwvvvv3/SpEkjRowIIVx//fUff/xxk0ZPyWQSl9pHBzRHy22GqPwQAADykwCRvLBp06bJkyfXzBC3b98+fvz4aMu/22+/PWqMFvBu3Lhx69atNb9879691157bZSCRXv8JeKSSy459thjQwh33HFHWVlZzUsvv/zyzTffHELo2bPnxIkT4+1r1qyZMWNGCGHatGmDBw+OxWLz5s1r27btjh07pkyZ0qS3XCswTWIyTZLaRwckreWKEKWHAACQtwSI5IUOHTosWLCgpKTkzjvvXLJkybRp04YOHfrCCy+EEEpKSsaOHRvdNmbMmBBCRUXF6aef/utf/3rt2rUrVqyYM2fOcccdd88990RVilu3bl22bNnOnTsbHbSwsPCuu+4KIezYseO00077p3/6p0WLFj300ENXX331yJEjo4rCWbNmxVf7xhcv9+vX76abbooaBw0aNG3atBDC0qVLn3zyyUTebHQcyq5du5YuXbpu3bqoNrCpk2mq1D46oJlSXoQoPQQAgHzmEBXywmOPPTZ+/PhVq1atWrWqZvt5550XrWKOnH322ZMnT7733nvXr19/8cUXx9tjsdjUqVNHjx59zjnnhBDOP//80aNHP/PMM42OO3bs2J///Off/e53Kyoq5s+fP3/+/Pilzp07z5s378ILL4y3zJgx49VXX43FYgsWLKgZ5N14441Llix56623Jk+ePGrUqM6dOzc86AknnBC9iDq/8847owiySZNpqpQ/OiBp0XHM6Z4FAACQO1QgkhdKSkrWrVs3derUY445pqioqGvXriUlJffff/8jjzxy8MEH17xz7ty5y5cvP/PMM3v06NG+ffsePXpcfvnlq1evnj179je/+c2pU6d27dq1qKioZ8+eCQ49ZcqU119//Zprrjn22GOLi4sPOuigvn37Tpo0ac2aNTUDuzVr1sycOTOE8J3vfGfkyJE1eygqKoo2Lty8eXMUBTbsrLPOmjVrVs+ePdu1a3fEEUcceuihTZ1MclL+6IDmSGGGqPwQAADynApE8kW3bt1mz549e/bsRu8cM2ZMtCC3rro97Nu3r9EO+/btG52n3IAhQ4ZUVFQc6Oqpp55aXV1dq3HEiBF1GyPTp0+fPn160pOJfPHFFwe61L1793qHbtKjA1pOCosQpYcAAIAKRADIQSnJEKWHAABAECACQA6zGSIAANB8AkQAyE1DSgc158uVHwIAABEBIgDksuSKEKWHAABAnENUyGXdu3cvLS0NIRQUFKR7LgBpkNxOiNJDAACgJgEiuWzcuHHjxvlBF8h3a1a83szlzAAAQD6zhBkAcllTo0PlhwAAQC0CRADIcYkvZJYeAgAAdQkQASAvNJohSg8BAIB6CRABIPfZAxEAAEiaABEA8kUDRYjKDwEAgAMRIAJAXmigCFF6CAAANKAw3RPIR59//nl1dXVKutq/f3/0Ys+ePeXl5c3vMCWdQJ6orKxK7UemqirFHZJp9u3bV1lZmcYJVFZWrn52zcAR/Wo2jjhkeeW+A35J2fZvhuCPZRP4IOe26urqFP4WV1ZVpaQfyAdffvnlZ599lpKuop+hUtVbCCEWi3Xp0iVVvQFkJgFiGrRr1y5VAWJlZeW+fftCCIWFhQUFBc3vMCWdQJ6IxWIp+chEP45GHbZpozA8Z1VWVrZp0ya9v8VfHzngP/74Rq0/t7EGp+TvhQTV/CB7aDmssrIyhd+rY7FYSvqBfFBQUNCuXbuUdFVRURFCSFVvwWcZyA8CxDQ46KCDUtVVeXl5FCC2a9euqKio+R2m8O9RyHkFBW1S8pGpqqqKcoc2bVLTIZmpsrKyoKCgbdu26Z1GQUHB+j+9FV/OfGKXx0M4YNr10ufj/JFM0P79+32Q80FVVVUKf4sL/EcjSFjbtm2Li4tT0lX07TpVvQHkCf9qAYA8UnMnRFsfAgAAiRAgAkB+GVI6aM2K16WHAABAggSIAJCPPn5vW7qnAAAAZAcBIgDkne+Me6uBq8oPAQCAmgSIAJBf4ouX6y1ClB4CAAC1CBABII/E08PDex1W96r0EAAAqEuACAD5y06IAABAowSIAJAvap28XKsIUfkhAABQLwEiAOSFWulhXFSEKD0EAAAORIAIALnvQOlhVIQoPQQAABogQASAHHeg9DByeK/D1qx4vdUmAwAAZB0BIgDktaj8UIYIAAAciAARAHJZw+WHUXo4pHRQa00HAADIPgJEAMhZiaSHcYoQAQCAegkQASA3NZwe1qIIEQAAOBABIgDko3pPXlaECAAA1CVABIAc1KTFyxFFiAAAQL0EiACQa5JID+MUIQIAALUIEAEgpzRp68NaFCECAAB1CRABII80XH4YQhhSOkgRIgAAUJMAEQByR3MWL9ckQwQAAOIEiACQI1KVHlrIDAAA1CRABIBckKr0ME4RIgAAEBEgAgC1KUIEAADiBIgAkPVSXn4YUYQIAAAEASIAZLsWSg8VIQIAABEBIgBksRZKD+MUIQIAAAJEAMhWDaeHzacIEQAACAJEAMhVzS8/DCEMKR2kCBEAAPKcABEAslJLL14GAACICBABIPu0ZnqoCBEAAPKcABEAskxLb31YLxkiAADkLQEiAOSUlli87DQVAADIZwJEAMgmadz6UBEiAADkJwEiAGSNNKaHihABACBvCRABIDukZevDWhQhAgBAHhIgAkAWaDQ9bNHyw4giRAAAyE8CRADIeq2QHsYpQgQAgHwjQASATJfGrQ9rUYQIAAB5SIAIABktc9LDyJDSQYoQAQAgrwgQASBzZcLBKfWSIQIAQP4QIAJAtmr98sOIhcwAAJBXBIgAkKEybfFyLYoQAQAgTwgQASATZXh6qAgRAADyhwARADJOxm59WIsiRCCvXHnllbFYLBaLff/730/3XACgVQkQASCzNJoepr38MKIIEcgrTz311AMPPBBCmDVr1qxZs6LGDz74oKysbOXKlWmdGgC0OAEiAGSTDEkP4xQhAvng008/vfLKK9u0aXPvvfdOnz493r5w4cKSkpKzzjorjXMDgFYgQASADJLhWx/WoggRyBOTJk3avn37gw8+OGnSpHTPBQDSQIAIAJkiu9LDyJDSQYoQgdxWXV394x//+MMPP7z44ovTPRcASA8BIgBkhGw5OAUgQbt27aqqqmrRIfbv3//xxx+36BAhhFgs1rNnz8MPP7ylB4rbt2/f7t27q6urW21EAGiYABEA0i9bDk6plyJEIIQwd+7cWCw2YMCAEMLixYsHDBjQqVOnwsLCQw89tLS0dMGCBQcKE59//vlJkyadeuqpX/va1zp16jRgwIAxY8YsW7as7v1t27aNxWJPPfVUCOGJJ5444YQTioqKHn744Zr3bNmyZerUqQMHDuzYsWPHjh379+8/efLk11//u+9R5eXlffv2jcViffr0KS8vrzXKo48+Gh21PGfOnHhjWVlZ1Lh69eqoZdKkSbFY7NZbbw0hfP7559HVu+66q6mTiXTq1CkWiz3xxBO7d+++6qqrDjnkkI4dOxYVFQ0cOPCyyy57++23m/noAKCZCtM9AQCgEZmcHsatWfG6LRGBEMKMGTNuuumm+C+3b9/+/PPPP//88w888MBTTz311a9+NX6psrJywoQJv/rVr2p++RtvvPHGG2/87ne/Ky0tffrpp9u2bVt3iPnz51911VV1C/SWL18+YcKE7du3x1vefPPNN998c/78+bfffvv3v//9qLFDhw4PPPBAaWnpO++8c+utt9ZM/f7617/+8z//cwhh5MiR11xzTfJPIeHJ1FReXj5q1Kh4RllRUbF+/fr169f/n//zf/7v//2/p512WvzOpB8dACRHBSIApFk2bn1Yi+gQiGzatOnmm28OIQwdOvSHP/zhQw89dN1113Xv3j2EsGrVqgsuuKDmzbNnz44isN69e8+YMWPp0qW/+c1vZs2a1b9//xDCihUrZs6cWXeIP//5z1dfffVhhx02Y8aMJUuWnH/++VH78uXLzznnnO3btxcWFk6YMGH+/PkLFy6cOHFi+/btq6qqfvCDH9SM20aOHDl58uQQwt133/3KK6/E22+44YYtW7YUFxf/4he/iMViDbzTuXPnVlZW/uu//msIoXPnzpWVlZWVlTfccEMSk4m78cYbV69e3a9fv7lz565cufJ3v/td9MT27dt3ySWXVFZWNvPRAUDSVCACQDrl0taHihCBaEXwhAkT5s2bF1XAXXLJJdOnTz/33HP/9Kc/Pffcc88+++zo0aOjm++9994QQp8+fV5++eUuXbrEO7nmmmtOOOGEt9566w9/+MMtt9xSa4gZM2YMHz788ccf79q1a7yxqqpq2rRpIYSuXbs+9thjo0aNitonTJjwv/7X/xo7duy2bdv+9V//9X/8j//Rrl276NKdd965fPnyTZs2XXHFFS+99FJhYeELL7ywYMGC6NLRRx/d8Dtt06ZN/P9jsVhBQUFzJhN59913S0pKnnrqqYMPPjhqOeuss7797W8/9NBDW7duXbdu3eDBg5vz6AAgaSoQASBtsnrrw1pEh0CkR48e8fQwcthhhz388MNRWBZPtSoqKiorK4888sjJkyfXjMBCCB07djz99NNDCO+++27d/isrK++5556a6WEIYfHixevWrQsh3HjjjfHALnLSSSfddtttIYSNGzcuXLiw5ihRXPjKK6/89Kc/3bt378SJE6urq0eNGnX11Vc35wkkMZlImzZt5s6dG08PIxMnToxexHdCTPrRAUDSBIgAkB65lB7GOU0FuPbaa+vuvnfUUUddeumlIYQXX3zxyy+/DCG0a9fu/fff/+CDD6677rq6nXzyyScH6v+kk04aMmRIrcaysrIQQqdOna666qq6XzJhwoRo78XotrgzzjjjiiuuCCHceuutEydO3LBhQ3Fx8cKFCxtevNyo5CYTQjjxxBPjNYZxPXv2jF7E93xM+tEBQNIEiACQibIxPVSECIQQhg0bVm/78OHDQwjV1dUbN26se7W6unrLli1lZWUPPPDARRddtGzZsgP1X+/i4qg6r1+/fsXFxXWvtm/ffuDAgSGEd955p9alu++++4gjjigvL3/wwQdDCD/60Y8aXbzcqKQnE+1gWEu0SroBiT86AEiaPRABIA1y4OCUA7ETIuS53r1719seD+beeeedAQMGRK/Xr19/3333/fGPf9ywYUO0f2KjevToUbcxyuwONHQIoVevXn/84x/rZnadO3eeO3fuueeeG0IYNmzYpEmTEplDw5KeTLdu3RIfJYlHBwBJEyACQGvLpYNTahlSOsgqZqBe8XXN8bTrJz/5yfTp06uqqqKrxx9/fN++ffv37z98+PAnn3zyvvvuq7efoqKiuo3x5b0HUlhYGEKIVk/Xsnbt2ujFunXrNm3a1KtXr0TeTgOSnkziS6eTe3QAkDQBIgC0qpzc+rCmKENUhAh5a+PGjd27d6/bHj8DpG/fviGE55577nvf+14IYdCgQTNnzjzzzDNrJoO///3vmzRo3759P/jgg/fee6+BWcWHrmnt2rV33HFHCKFNmza7d++eOHHi008/3aShUziZBKX20QFAIuyBCACtJ+fTwzh1iJC3Vq9eXW/7Sy+9FL3o06dPCCHac7B9+/bPPvvs2LFja9UVVlZWNmnQqM8NGzbs2bOn7tV9+/ZFxyL369evVvvll1++b9++YcOGzZkzJ4TwzDPPLFq0qElDp2oyiUvtowOARAgQAaCVnPKVJxu+IWfSQ+WHkM9+9rOf1c2wtmzZsnDhwhDC4MGDO3bsGELYvHlzCKFXr151N/6rrq6Op40JOuWUU0IIX3zxxbx58+pe/eUvf7lt27YQwsknn1yzfebMma+88kphYeH9998/adKkESNGhBCuv/76jz/+uEmjp2QyiUvtowOARAgQASAj5Ex6GKcIEfLTpk2bJk+eXDND3L59+/jx46Mt/26//faoMVrAu3Hjxq1bt9b88r1791577bVRChbt8ZeISy655Nhjjw0h3HHHHWVlZTUvvfzyyzfffHMIoWfPnhMnToy3r1mzZsaMGSGEadOmDR48OBaLzZs3r23btjt27JgyZUqT3nKtwDSJyTRJah8dACRCgAgArWHEoU+lewqtShEi5K0OHTosWLCgpKTkzjvvXLJkybRp04YOHfrCCy+EEEpKSsaOHRvdNmbMmBBCRUXF6aef/utf/3rt2rUrVqyYM2fOcccdd88990RVilu3bl22bNnOnTsbHbSwsPCuu+4KIezYseO00077p3/6p0WLFj300ENXX331yJEjo4rCWbNmxVf7xhcv9+vX76abbooaBw0aNG3atBDC0qVLn3yykZrx+LghhF27di1dunTdunVRbWBTJ9NUqX10AJAIh6gAQIs7scvj+/Y1dEPulR9GnKYCeeixxx4bP378qlWrVq1aVbP9vPPOi1YxR84+++zJkyffe++969evv/jii+PtsVhs6tSpo0ePPuecc0II559//ujRo5955plGxx07duzPf/7z7373uxUVFfPnz58/f378UufOnefNm3fhhRfGW2bMmPHqq6/GYrEFCxbUDPJuvPHGJUuWvPXWW5MnTx41alTnzp0bHvSEE06IXkSd33nnnVEE2aTJNFXKHx0ANEoFIgC0rPw5OKUW0SHkp5KSknXr1k2dOvWYY44pKirq2rVrSUnJ/fff/8gjjxx88ME175w7d+7y5cvPPPPMHj16tG/fvkePHpdffvnq1atnz579zW9+c+rUqV27di0qKurZs2eCQ0+ZMuX111+/5pprjj322OLi4oMOOqhv376TJk1as2ZNzcBuzZo1M2fODCF85zvfGTlyZM0eioqKoo0LN2/eHEWBDTvrrLNmzZrVs2fPdu3aHXHEEYceemhTJ5OclD86AGiYCkQAaEF5mx7GKUKEPNStW7fZs2fPnj270TvHjBkTLcitq24P+xqu5Q4hhNC3b9/oPOUGDBkypKKi4kBXTz311Orq6lqNI0aMqNsYmT59+vTp05OeTOSLL7440KXu3bvXO3STHh0ANJMKRABoKdJD0SEAAOQAASIA0LIcxwwAAFlNgAgALUL5YUQRIgAAZDsBIgCknvSwpiGlgxQhAgBA9nKICgCkmPSwXk5TgdzWvXv30tLSEEJBQUG65wIApJgAEQBSSXpYL0WIkPPGjRs3blw+fn8DgHxgCTMApEyj6WGekyECAEA2EiACQOvJz/LDiPXLAACQpQSIAJAajZYfvrhjbOvMJJMpQgQAgKwjQASAFGg0PSz7ZEzrzCSTKUIEAIBsJEAEgOZycEqTKEIEAIDsIkAEgGaRHjaJIkQAAMg6AkQASJ5jl5MwpHSQIkQAAMgiAkQASFIi6aHywwORIQIAQLYQIAJAS5EeHoiFzAAAkEUEiACQDFsfNp8iRAAAyAoCRABoMulh8ylCBACAbCFABICmkR6mkCJEAADIfAJEAGgCxy6nkCJEAADICgJEAEiUY5dbgiJEAADIcAJEAEiI9LAlKEIEAIDMJ0AEgMZJD1uUIkQAAMhkAkQAaIT0sEUpQgQAgAwnQASAhkgPW8GQ0kGKEAEAIGMJEAGgWaSHqSJDBACAzCRABIADSqT8kJSwkBkAADKWABEA6mfxcutThAgAABlIgAgA9ZAetj5FiAAAkJkEiABQm/QwjRQhAgBAphEgAsDfkR6mkSJEAADIQAJEAPgv0sNMoAgRAAAyigARAP5GepgJFCECAECmESACQAjSw0wypHSQIkQAAMgcAkQASCg9pJXJEAEAIEMIEAHIdwmmh8oPW5OFzAAAkDkEiADkNelhJlOECAAAmUCACED+kh5mMkWIAACQIQSIAOQp6WFWUIQIAABpJ0AEIB9JD7OCIkQAAMgEAkQA8o70MLsoQgQAgPQSIAKQX6SH2UURIgAApJ0AEYA8Ij3MRkNKBylCBACANBIgApAvpIcAAABJECACkBekh1lNESIAAKSRADFJH3744YcffpjuWQCQEOlhbpAhAgBAWhSmewIp89577z3++OOvvfba559//tWvfrVHjx7nnXfegAEDat6zZMmSxYsX1/vl9913X/fu3aPX5eXlzz///HvvvXfIIYecdNJJRx11VK2bt23bNmXKlG9/+9tHHnlkS7wXAFJIepgbFCECAEC65EiA+O///u933313VVVVCOGwww7bsWPHRx999PLLL1944YX/83/+z/htH330UaNdbdq06fbbb9+2bVv0y8WLF3/nO985++yza96zePHirl27jhkzJqVvAoDUkx7mmDUrXncuMwAAtLJcCBD/+te/zp49u6qq6h/+4R+uuOKKr3zlK1VVVb/97W9/8YtfLFmy5Ljjjhs8eHB0ZxQg3n333XWLCtu3bx9C2L9//09+8pMvvvjihhtuGDp06NatW++9994FCxYce+yxRx99dHTne++9t2LFiqlTp7Zt27YV3yUATSY9zDGKEAEAIC1yYQ/EZ555pqKiYsCAAddff/1XvvKVEEJBQcG4ceO+9a1vVVdXL1++PH5nFCAeddRRRXXEYrEQwvvvv79p06YLLrigpKSkQ4cORx999A033FBVVfXiiy/GO1m0aFGPHj1OPfXUVn+jACTqxC6PSw9zlQwRAABaWS4EiG+//XYIobS0tKCgoGb78OHD41dDCBUVFTt27OjSpUtRUdGBuvriAyCYMwAAIABJREFUiy9CCFEKGenSpUtBQcHnn38e/fK1115bvXr1ZZddFgWOAGSgBKNDspH1ywAA0PpyIUCsrKw85JBD6p5nEi0xjjZGDCF8/PHH1dXV3bp1a6CrY445pn379r/97W/37NkTtTzyyCNVVVWDBv3tx5VFixYNGjToG9/4RorfAwApknh6+NLn45QfZilFiAAA0JpyYQ/Em266qd72VatWhRCOOeaY6JfR+uUuXbosW7ZsxYoVH3/88SGHHNK7d+/zzjsvvr/hQQcddMUVV9x7770TJ04cMGDARx99tGnTpsGDB48aNSqEUFZW9uabb/74xz9ujXcFQNM1KT1s0ZnQcuyECAAArSwXAsR6rVmzZtmyZSGEc889N2qJAsSVK1euXLmysLDw4IMP/vDDDz/88MM//elPEyZMGDt2bHTbf/tv/+2QQw555JFHXnvtta9+9asXXXTRBRdcEIvFqqqqfvWrXw0fPrx///7NnNtnn322f//+ZnYSqa6ujl7s3r179+7dze8wXnoJNKqysjK1H5nKysrKysoUdphvRhz61L59Cd1Z9smYENLw7W7fvn37EpwiDep7Yu8/P/PqwBH90j2RelRVVfnLNLel8Ht1ZWVVSvqBfFBeXv7pp5+mpKvoZ6hU9RZCiMViNXfBAshJORgg7t27d8mSJY8++uj+/fsvvvjir3/961F7FCB27NhxypQp3/jGNwoLC3fv3v3www8/8cQTCxcuHDhwYJ8+faI7v/GNb9RdpPz0009v3br1QNWOTbJ///548JcqKe8QILuMOPSpBO8s+2RMi86EVrOu7M3MzBABSLnq6urU/sjjByiAJsm1ALGsrOyBBx7Yvn17UVHRFVdc8Y//+I/xS6NHjx46dGiPHj0OOeSQqKW4uPiKK6747LPPXnjhhaVLl/7gBz84ULd79+59+OGHzzjjjO7du4cQ9uzZ8+CDD/7lL3/ZvXt3//79L7vssp49eyY+yYKCglT9dRXPItu0aZOSc10cDgNNEUvVRyb6IPsAJmfEIcsTv7ls+zfT9Zirq6v9FqfQoJL+68rezKhHGv/LPaNmRWql+IPsTwokrE2bNrXOzExatBqsTZuUnQfg2z6QD3InQNy5c+d9991XVlYWQigpKbn88ssPO+ywmjf07t27d+/edb/wH//xH1944YV33323gc6feOKJPXv2jB8/PoSwd+/ef/mXf9m8eXOfPn0OP/zwNWvWXHfddXfeeWe/fokWQXTp0iXRd9WY8vLyaOXyQQcd1MDp0onr0KFD8zuBPFFYWJCSj0xVVdXevXtDCAUFBe3atWt+h3nlxC6Ph9A2wZtf+nxcGr/J7dmzp7CwMDrgi5QoLCx8c9W7GXIu8/79+7/88ssQQkFBQfv27dM9HVpKeXl5Cr9XF6YoDYF8UFRU1LVr15R0tXPnzhDCwQcfnJLeAPJEjgSI27ZtmzZt2qefftqjR49rrrnm2GOPTfxrDz/88BDCjh07DvSflHfu3Pnoo4+OHTs22tji0Ucf3bx589VXXx2VN77//vvf+973/u3f/u2nP/1pit4NAAlJ/MiU4NSUXOQ0FQAAaB0pK9tOoz179txyyy2ffvrp6NGjf/azn9WbHu7Zs+e3v/3tU089VXft8Pbt20MIPXr0OFDl+dKlSwsKCs4777zol//xH/9x+OGHxxdH9+jR47TTTnvnnXfKy8tT9pYAaIz0kIgMEQAAWlouVCA+++yzmzdv/sY3vjFlypQD3dOhQ4elS5f+9a9/7dat29ChQ2teeu6550IIBzpbedu2bb/73e8uu+yygw46KN5YK2qMts9I1cHKADSsSdFhkB7mNEWIAADQCnKhAvHpp58OIYwbN27/AYQQYrHYmDFjQgizZ89es2ZN9IVffvnl4sWLn3766U6dOkX7G9b1q1/96itf+crZZ58dbznuuOM++uijZ555Jvrl5s2b//CHP/Tu3bu4uLhF3yYAQXpIfWSIAADQorK+ArGqqurDDz8MIdx000313vC1r31t3rx5IYQLLrigvLz8scceu/nmmzt16tShQ4dPPvmkurq6U6dO119/fb0Hm2zcuPH555+/9tpra+55/9//+39/4YUX5syZ8/TTT3fs2PG1117bv3//pEmTWub9AfBfpIfUpQgRAABaWtYHiJ988kmCa4cLCgomTJhw3HHHLV++/O233965c2ffvn379et34YUXdu7cud4vWbRoUY8ePUpLS2s2tm/f/u67737wwQdXr169ZcuWr3/965dddlmvXr2a/VYAOKCmRodBephPogwxQ45jBgCA3JP1AWK3bt2efPLJxO8fNmzYsGHDErz51ltvrbf9oIMOuuqqqxIfFIDmkB6SCBkiAAC0kKwPEAHIYaJDEmQhMwAAtJxcOEQFgJwkPaSpZIgAANASBIgAZJwTuzwuPaSprF8GAIAWIkAEILMkER0G6SH/SREiAACknAARgEyRXOFhkB7ynxQhAgBASxAgApARkosOg/SQv+c0FQAASDmnMAOQZqJDUm7NitdVIwIAQKqoQAQgbZJesxykhxyY6BAAAFJLgAhAGjQnOgzSQxJgITMAAKSKABGA1tbM6FB6SKMUIQIAQAoJEAFoPQoPaU2KEAEAICUEiAC0hmZGh0F6SBMpQgQAgFRxCjMALauZuWEQHdIMjmMGAIDmU4EIQEtpftVhkB7SDKJDAABICRWIAKRe83PDIDokFYaUDlKECAAAzaQCEYBUSknVYZAeklJOUwEAgOZQgQhACqQkNIyIDkmtqAgx3bMAAIAspgIRgGZJVclhRHpIC5EhAgBA0lQgApCMFIaGEdEh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ZzRnIOWHAABkFAEiAOCM5kykCBEAgAwhQAQAQrCiOcNYyAwAQOYQIAIA/8WK5sxhITMAABlCgAgA1GZFc+ZQhAgAQNoJEAGAeljRnAksZAYAIBMIEAGAA7KiOe1kiAAApJ0AEQBohBXNAACQzwSIAEDjrGhOI0WIAACklwARAEiUFc3pIkMEACCNBIiQ16688spYLBaLxb7//e+ney5A1rCiOS2iDBEAAFqfABHy11NPPfXAAw+EEGbNmjVr1qyo8YMPPigrK1u5cmVapwZkOiua00URIgAArU+ACHnq008/vfLKK9u0aXPvvfdOnz493r5w4cKSkpKzzjorjXMDsoUVza3MQmYAANJCgAh5atKkSdu3b3/wwQcnTZqU7rkA2c2K5tYkQwQAoPUJECEfVVdX//jHP/7www8vvvjidM8FyAVWNAMAQA4TIJJldu3aVVVV1aQv2b9//8cff5yu0ZsqhbNtQCwW69mz5+GHH97SA8Xt27dv9+7d1dXVrTYi0PqsaG4dihABAGhlAkQy2ty5c2Ox2IABA0IIixcvHjBgQKdOnQoLCw899NDS0tIFCxbUjfPatm0bi8WeeuqpEMITTzxxwgknFBUVPfzwwzXv2bJly9SpUwcOHNixY8eOHTv2799/8uTJr79e+yexJEaPPP/885MmTTr11FO/9rWvderUacCAAWPGjFm2bFnLzba8vLxv376xWKxPnz7l5eW1Rnn00Uejo5bnzJkTbywrK4saV69eHbVMmjQpFovdeuutIYTPP/88unrXXXcl8ehCCJ06dYrFYk888cTu3buvuuqqQw45pGPHjkVFRQMHDrzsssvefvvtZj46IGNZ0dwKZIgAALQmASLZYcaMGZdccskbb7wR/XL79u3PP//8xIkTR4wY8emnn9b7JfPnzz/33HNfeeWVffv21Wxfvnz5kCFD7rnnnvXr1+/evXv37t1vvvnmfffdN2TIkPhJxEmPXllZeemll5aWlv7bv/3bihUrPvroo127dr3xxhu/+93vzj///NGjR9eaTKpm26FDhwceeCAWi73zzjtRAhj317/+9Z//+Z9DCCNHjrzmmmvqHT1BSTy68vLyUaNGzZs3b+fOnSGEioqK9evXP/jggwMHDvzDH/5Q886kHx2QgaxobgUyRAAAWk1huicAjdu0adPNN98cQhg6dOi3vvWt3r17/+Uvf1m6dOnmzZtXrVp1wQUX1IqiQgh//vOf77jjjsMOO2zKlCl9+vQZMWJE1L58+fJzzjknhFBYWHjppZeecsophYWFK1euXLRo0d69e3/wgx8cddRRl1xySdKjz549+1e/+lUIoXfv3ldeeWVUFfj222//8pe/3LBhw4oVK2bOnHnLLbe0xGxHjhw5efLkuXPn3n333RdddNHxxx8ftd9www1btmwpLi7+xS9+EYvFGnjOc+fO/d//+3//8Ic//OEPf9i5c+coG23Tpk3Sjy6EcOONN7777rv9+vWbOnXq0KFDd+zY8Ytf/OI3v/nNvn37Lrnkkvfff7+wsLA5jw7IZFGGeKCsMGpvOGcEAAAyQcyWZFmtvLx89+7dIYRocWjzO7ztttui+rVf//rX48ePb36HzTR37tx40dyECRPmzZvXtm3b6Jfbtm0799xz//SnP4UQnnnmmdGjR0ftbdu2raysbNu27SmnnPL444937do13ltVVdXgwYPXrVvXtWvXxx57bNSoUfFLq1atGjt27LZt23r37v3GG2+0a9cuudGPPvrojRs39unT5+WXX+7SpUu8/127dp1wwglvvfXWyJEjn3/++Xh7CmcbjXLcccdt2rTp+OOPf+mllwoLC1944YXS0tLq6uo5c+bUKj8sKysrKSkJIfz5z38eOnRovD36M9ClS5fPPvusOZPp1KnTrl27QgglJSVPPfXUwQcfHP+Sb3/72w899FAIYc2aNYMHD07u0aXRyy+/fOKJJ4YQLh0/bNH8S5vfYVVV1d69e0MIhYWF8QdI7tmzZ0/btm3j30bySqP1hjkQI+7fv//LL78MIRQUFLRv377Vxo0qEKNqRFpBeXl5QUFBqr5XT7jqV4sWvxRCWLly5UknnZSSPiHHLFmy5KKLLgoh3HLLLbXW2SQtWhlT81+nADTKEmayQ48ePWrmdyGEww477OGHH47+BV+3MK2ysvKee+6pmceFEBYvXrxu3boQwo033lgzAgshnHTSSbfddlsIYePGjQsXLkxu9IqKisrKyiOPPHLy5Mk1I7AQQseOHU8//fQQwrvvvlv33aVqth07dlywYEEI4ZVXXvnpT3+6d+/eiRMnVldXjxo16uqrr647buKSfnRt2rSZO3durX+fTZw4MXoR3wkx6UcHZAUrmluOhcwAALQCASLZ4dprr61btnPUUUddeumlIYQXX3wxqvuIO+mkk4YMGVLr/rKyshBCp06drrrqqrpDTJgw4atf/Wr8tiRGb9eu3fvvv//BBx9cd911dfv/5JNPDvTuUjjbM84444orrggh3HrrrRMnTtywYUNxcfHChQsbXrzcqKQf3YknnhivMYzr2bNn9CJeAZ30owOyiDOaW4jyQwAAWpoAkewwbNiwetuHDx8eQqiurt64cWPN9qOPPrruzVG9W79+/YqLi+tebd++/cCBA0MI77zzTjNHj1RXV2/ZsqWsrOyBBx646KKLli1bVm8nKZ/t3XfffcQRR5SXlz/44IMhhB/96Ef19t8kSU+mf//+de+P76t4IIk/OiDrOKO5hShCBACg5QgQyQ69e/eutz0ejdWKrnr06FH35igFO1BXIYRevXrV7aqpo69fv37KlCnHH398cXFx9+7dS0pKrrzyyiVLlhxo0JTPtnPnznPnzo1eDxs2bNKkSQ0MnaCkJ9OtW7fER0ni0QHZyIrmlLOQGQCAFuUUZrJbfGVxeXl5zfZ6j5Rp9Mig6ETgWquhmzT6T37yk+nTp1dVVUVXjz/++L59+/bv33/48OFPPvnkfffdV28/KZ/t2rVroxfr1q3btGlTlO41R9KTSXzpdHKPDshezmhOrSGlg9aseH3NitetaAYAIOUEiGSHjRs3du/evW57/BSOvn37NtpJ3759P/jgg/fee6+BUertKsHRn3vuue9973shhEGDBs2cOfPMM8+smQz+/ve/b3SGKZnt2rVr77jjjhBCmzZtdu/ePXHixKeffrpJQ6dwMglK7aMDssjJRx7VQL2hGDEJMkQAAFLOEmayw+rVq+ttf+mll6IXffr0abST6J4NGzbs2bOn7tV9+/ZFBw3369cvudGjPQfbt2//7LPPjh07tlZdYWVlZaMzbP5s9+3bd/nll+/bt2/YsGFz5swJITzzzDOLFi1q0tCpmkziUvvogOxiRXOqyA0BAGghAkSyw89+9rO6KdKWLVsWLlwYQhg8eHDHjh0b7eSUU04JIXzxxRfz5s2re/WXv/zltm3bQggnn3xycqNv3rw5hNCrV6+6G/9VV1fH08YEJTfbmTNnvvLKK4WFhffff/+kSZNGjBgRQrj++us//vjjJo2ekskkLrWPDshGzmhOCZshAgDQEgSIZIdNmzZNnjy5Zoq3ffv28ePHR5vu3X777Yl0cskllxx77LEhhDvuuKOsrKzmpZdffvnmm28OIfTs2XPixInJjR4t4N24cePWrVtrfvnevXuvvfbaKAWL9vhrodmuWbNmxowZIYRp06YNHjw4FovNmzevbdu2O3bsmDJlSoLjRmoFpkk/ugSl9tEB2csZzc0nQwQAIOXsgUh26NChw4IFC9auXTtu3LjevXv/5S9/efjhh99///0QQklJydixYxPppLCw8K677vrWt761Y8eO00477fLLLx8+fHibNm1Wrly5cOHCKA2cNWtW3SNNEhx9zJgx9957b0VFxemnn37TTTcdd9xxO3bseO211+6555633367Y8eOu3bt2rp167Jly84444yDDz44tbONL17u16/fTTfdFDUOGjRo2rRpd9xxx9KlSy+++OJEHlR0HMquXbuWLl163HHHde7cuXv37kk/ugSl9tEBWa3hw1WiS3ZFbJgDVQAASC0BItnhscceGz9+/KpVq1atWlWz/bzzzovWESdo7NixP//5z7/73e9WVFTMnz9//vz58UudO3eeN2/ehRdemPToZ5999uTJk++9997169dffPHF8fZYLDZ16tTRo0efc845IYTzzz9/9OjRzzzzTGpnO2PGjFdffTUWiy1YsKBmkHfjjTcuWbLkrbfemjx58qhRozp37tzwoCeccEL0Iur8zjvvnDZtWlMn01Qpf3RAtnNGczPJEAEASCFLmMkOJSUl69atmzp16jHHHFNUVNS1a9eSkpL777//kUceaWo92pQpU15//fVrrrnm2GOPLS4uPuigg/r27Ttp0qQ1a9YcKAJLfPS5c+cuX778zDPP7NGjR/v27Xv06HH55ZevXr169uzZ3/zmN6dOndq1a9eioqKePXumdrZr1qyZOXNQ1sSwAAAgAElEQVRmCOE73/nOyJEja/ZQVFQUbVy4efPmKAps2FlnnTVr1qyePXu2a9fuiCOOOPTQQ5vz6BKX8kcH5AArmgEAIBPEqqur0z0HkldeXr579+4QQseOHZNePVrTbbfdduutt4YQfv3rX48fP775HTbT3Llzr7nmmhDCrl27iouL82p0MtbLL7984oknhhAuHT9s0fxLm99hVVXV3r17QwiFhYXt2rVrfodkpj179rRt27Zt27bpnkhWajgozIRSxP3790f7ORQUFLRv3z7d0/mbaCdERYgpVF5e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" alt="Fluxo de tonicidade no Grupo Dissimilar de Alta Frequência" width="864" />
<p class="caption">
Figura B.2: Fluxo de tonicidade no Grupo Dissimilar de Alta Frequência
</p>
</div>
<p><br></p>
<div class="figure"><span id="fig:fluxo-3"></span>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABsAAAASACAIAAADOHB9sAAAACXBIWXMAAB2HAAAdhwGP5fFlAAAgAElEQVR4nOzdeZRU5YHw4be6egG6EVAy7izKomB04p7ogEs0ERLOJO7RiAQlggTUHNHEJZiomLiMygcuKAlbYojLmKBzoomihoTREAUEohEQZFFUQKD37fvjzlR6Gi40dDVVXf08x+Opvvf2W2/Z1u3uX7+3KlFfXx8AAAAAAHYkL9MTAAAAAACyl4AIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGLlZ3oCNEttbW11dXUIoaCgIJlMZno6tIj6+vrKysrCwsK8PMU/N9XV1VVVVYUQkslkQUFBpqdDS6moqHCuzmHRuTqEkJeXV1hYmOnp0FIqKyvz8vKcq3NYRUVFCCGRSBQVFWV6LrSU6Ocu52qA3aJHtG5VVVXbtm3btm1blBHJSXV1ddu2baupqcn0RGgpNTU10RM5+nGWXOVLnNuic/W2bdui+kCuKisr80TObdETuaysLNMToQVVVFQ4VwPsLgERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQNxDa9asWbNmTaZnAQAAAAAtKz/TE9gNL7300sMPP/zggw8ecMAB2++tqKiYOXPm/Pnzt2zZcvjhh//rv/7reeedl0wm9+Cw8vLyV1555f333+/atetJJ5106KGHNhpkw4YNY8aMueyyyw455JD0PkYAAAAAyCqtKSC++OKLFRUVO9z1ySef/OQnP1m5cmUIoVOnTkuWLFmyZMnChQt/8IMfdOzYcbcOW7Vq1U9+8pMNGzZEH86aNevKK68cNGhQw7ubNWtWly5dBg8e3BIPEwAAAACyR+u4hLmsrGzq1KlLliyJO+A//uM/Vq5c2b9//6lTp86YMePhhx8+9NBD33777ccff3y3Dqurq7vnnnu2bt06bty4X//61/fff//hhx8+ZcqUFStWpAZ5//33586de8kllxQUFLTQ4wUAAACALJHtAfEPf/jDuHHjhg4d+p//+Z9xx/z9739fvHhxSUnJD3/4w65du4YQDjrooFtvvTWZTL788ssff/xx0w9bvXr1qlWrzj///FNPPbV9+/aHHXbYuHHjamtr//KXv6Tubtq0ad26dTv99NNb9pEDAAAAQBbI9oD4/vvvr1u3rqioaJ999kkkEjs85s9//nMI4fjjj294tfL+++9/5JFH1tfXz58/v+mHbd26NYSw7777pg7o3LlzMpncvHlz9OHixYsXLFgwdOjQuMkAAAAAQC7J9oB4xRVXzPxfDcNfQ8uXLw8hHHvssY22R1uivU087PDDDy8qKvrd735XVlYW7X3yySdra2v79+8ffTht2rT+/fsff/zx6XhwAAAAAJDtWtObqMRZt25dCCG6KrmhaMvatWubfliHDh2GDx8+efLkESNGHHnkkR9++OGqVauOPvrogQMHhhDmzZv37rvv3n333S37eAAAAAAga+RCQCwtLQ0hbL8+saSkJISQWkvYxMO++tWvdu3a9cknn1y8ePF+++130UUXnX/++YlEora2dubMmV/60pf69u3bzAlv2bKlvr6+mYNEamtroxvl5eWVlZXNH3DTpk033HBD6k2oyRLR/zAunM8qJSUlt99+e48ePZo/VF1dXXSjsrKypqam+QOStSoqKqqqqjI9C1pE6jt7TU3NZ599ltnJ0HJqa2vTeK5etWrVTTfdtG3btrSMRlqknst+7soq//Iv/3LXXXc1fKWp5oiewmk8VycSiX322SddowFkp1wIiNXV1SGE9u3bN9reoUOHEEIqqzXxsBDC8ccfv/1Fyi+88ML69etvvvnmtEw4XQExpba2NhUTm2P69OmzZ89u/jjQFnTt2jW9S5Lr6upSMZGclK5zNdnMEznnpfFL/MADD8yZMyctQ0HOO/LII0ePHp3GAaNfD9NCbgbaglwIiB07dty8eXN5eXmj7dGiwtSSwyYetkOVlZVPPPHEWWeddfDBB0efMn369L/97W+lpaV9+/YdOnRo9+7d0/VwMitapwk0xbI33n3q7ucyPQsAWqtlr7+b6SlAq5G6YgyAjMiFgLjvvvtu3rx5+6s/oi1dunTZrcN26Nlnny0rK7v44otDCJWVld///vfXrl3bq1ev/ffff+HChddee+1dd93Vp0+fpk+4iUfuUnl5efSttLi4uF27ds0fMLVCc8qUKeeee27zB4Tc8+abb5555pkhhPxk/vaLmvdAbW1tdFlrfn5+QUFB8wckO5WXlxcUFOTn58J3XrZXX19fUVERQkgmk4WFhZmeDi2loqIimUym61ydTCajGy+++OJxxx2XljEhxzzzzDPDhw8PIbRv336//fZLy5hbt24Nu1pBAkAjufBrTOfOnUMIGzdubLR906ZNIYTUt5kmHra9LVu2PP3000OGDInC39NPP7127dqrr776K1/5Sghh9erV119//cMPP3zfffc1ccJpXOKeGiqRSKRl2NQgxcXFO4+q0Gb988fNRHqezg0HcQlMzvMlzlUNX5zEVznnpe1L/L/DdOzY0c9dsEPFxcXRjXT9vpPiXA2wW/IyPYE06NatWwjhrbfearR94cKFIYSePXvu1mHbmz17djKZTC3He/vtt/fff/+oHkbDnnHGGcuXL9/+4mgAAAAAaO1yISCeeOKJIYS//vWvDd8IZcuWLYsXLy4sLBw4cOBuHdbIhg0bnn/++QsuuCB6r5VIo79W5eXlhQbvowoAAAAAOSMXAuJRRx3Vt2/fTZs2Pfjgg9G7W1ZWVt51113V1dUDBgxILXpv4mGNzJw5c9999x00aFDDu/vwww9ffPHF6MO1a9e+9NJLPXv2jBsBAAAAAFqvXHgNxBDCddddN27cuNdee23BggXdunVbsWJFVVXVQQcdNGzYsD04LGXlypWvvPLKNddc0/Clsr/5zW+++uqrEydOfOGFF0pKShYvXlxXVzdy5MiWfYQAAAAAkAm5sAIxhHDggQc+8MADZ599dvv27d97773OnTv/+7//+3333dforbWaeFjKtGnTunXrdtpppzXcWFRUdO+99w4aNGjz5s3vvvvu5z//+fvuu69v374t9+gAAAAAIFNa0wrEmTNn7mTvvvvuO3r06F0O0sTDIuPHj9/h9g4dOlx11VVNHAQAAAAAWq8cWYEIAAAAALQEAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABi5Wd6Am1RZWVlfX19Woaqrq5udKOZampq0jIOtAX1dfVpecrU1dX9z4D16RmQrFVXV+dLnKtS39k9kXNeGr/E9XXp+YEQ2oKampqKioq0DBX96JWu0SLt2rVL42gAWUhAzIBt27alKyCmVFZWVlZWNn+cqqqq5g8CbURtXW16nzK1tbW1tbVpHJBs40vcFtTV1flmmtvS+ERO/QEJ2KWqqqpt27alccA0jpZIJAREIOcJiBmw3377pWuo8vLy0tLSEEJJSUlavml16NCh+YNAG5Gfn5+Wp0xtbW30B4D8/PzCwsLmD0h2KisrKygoKCgoyPREaBF1dXXRYpZkMllUVJTp6dBSysvLk8lkus7VyfxkWsaBtqBDhw5du3ZNy1BbtmwJIeyzzz5pGQ2gjfAaiAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiCUgAgAAAACxBEQAAAAAIJaACAAAAADEEhABAAAAgFgCIgAAAAAQS0AEAAAAAGIJiAAAAABALAERMuyKK65IJBKJROIHP/hBpucCAAAA0Fh+picAbdpzzz33+OOPhxAmTJhw4403Rhs/+OCD1atXJ5PJk08+OaOzAwAAALACETLn008/veKKK/Ly8iZPnpyqhyGEqVOnnnrqqeecc04G5wYAAAAQsQIRMmbkyJGffPLJ9OnTL7nkkkzPBQAAAGDHrECEzKivr7/77rvXrFmjHgIAAADZzApEyIxEItG9e/e9eY/V1dVVVVUdOnRIJBJ7834BAACAVs0KRNi1devWjR07tl+/fiUlJSUlJX379h01atSSJUsaHlNeXt67d+9EItGrV6/y8vJGIzz99NPRWy1PnDgxtXHevHnRxgULFkRbRo4cmUgkxo8fH0LYvHlztPenP/3p7k4m0rFjx0Qi8eyzz5aWll511VVdu3YtKSlp165dv379hg4d+t577+3wwb7yyisjR448/fTTDzzwwI4dOx555JGDBw9+6qmnamtrd/s/HAAAAND6CYiwC3PmzDnmmGMefPDBZcuWlZaWlpaWvvvuuw899NAxxxwzYcKE1GHt27d//PHHE4nE8uXLowKY8tlnn33ve98LIQwYMGD06NF7YTINlZeXDxw48JFHHtmyZUsIoaqqatmyZdOnT+/Xr99LL73U8Miamppvf/vbp5122sMPPzx37twPP/xw27Ztf//7359//vnzzjvvy1/+cnV1dXMmDwAAALRGAiLszJw5c77+9a9/8skn+fn5w4YNe/TRR6dOnTpixIiioqLa2tof/vCHM2fOTB08YMCAUaNGhRDuvffeN998M7V93Lhx69atKy4u/vnPf77zy4cnTZpUU1Nz6623hhA6depUU1NTU1Mzbty4PZhMyk033bRgwYI+ffpMmjRp/vz5zz///Pnnnx9CqK6uvvTSS2tqalJH3n///dEIPXv2vOOOO2bPnv2b3/xmwoQJffv2DSHMnTv3zjvvbMZ/SwAAAKBV8hqIEKu2tvaGG24IIXTp0uWZZ54ZOHBgtH3YsGHf+c53hgwZsmHDhltvvfWCCy4oLCyMdt11111z5sxZtWrV8OHDX3/99fz8/FdffXXKlCnRrsMOO2zn95iXl5f6dyKRSCaTzZlMZMWKFaeeeupzzz23zz77RFvOOeecyy67bMaMGevXr1+6dOnRRx8dbZ88eXIIoVevXm+88Ubnzp1TI4wePfrYY4/9xz/+8dJLL/3oRz/ak/+UAAAAQKtlBSLEmjVr1tKlS0MIN910UyrYRU466aTbbrsthLBy5cqpU6emtpeUlES58M0337zvvvsqKytHjBhRX18/cODAq6++ei9PJpKXlzdp0qRUPYyMGDEiupF6JcSqqqqamppDDjlk1KhRDeth9KDOPPPMEMKKFSua8xAAAACA1khAhFjz5s0LIXTs2PGqq67afu+wYcP222+/1GEpZ5111vDhw0MI48ePHzFixDvvvFNcXDx16tRmvvfxnk0mhHDiiSem1himpN4Aur6+PrpRWFi4evXqDz744Nprr91+/I8//rg5kwcAAABaLwERYkWr8/r06VNcXLz93qKion79+oUQli9f3mjXvffee9BBB5WXl0+fPj2E8LOf/WyXFy+33GSiVzBsJLpKeifq6+vXrVs3b968xx9//KKLLnrqqaf2cN4AAABAK+c1ECFW1Ox69uwZd0CPHj1ee+217Ztdp06dJk2a9I1vfCOEcMIJJ4wcOTKDkznggAOafi/Lli176KGHXnvttXfeeae8vHzPpgoAAADkEisQIVbq8t44+fn5IYSKiortdy1atCi6sXTp0lWrVmVwMk2/dPqee+75/Oc/P3HixLfeequmpuYLX/jCBRdccMstt/zXf/1XWhooAEBmXXHFFYlEIpFI/OAHP8j0XACgNbECEWL17t37gw8+eP/99+MOWLlyZXRYo+2LFi26/fbbQwh5eXmlpaUjRox44YUXMjWZJnr55Zevv/76EEL//v3vvPPOs88+u127dqm9v//97/dsWACALPHcc889/vjjIYQJEybceOON0cYPPvhg9erVyWTy5JNPzujsACCrWYEIsXr16hVCeOedd8rKyrbfW11dHb0tcp8+fRptv/zyy6urq0844YSJEyeGEF588cVp06ZlZDJNF71cY1FR0R/+8IchQ4Y0rIchhJqamj0bFgAgG3z66adXXHFFXl7e5MmTU/UwhDB16tRTTz31nHPOyeDcACD7CYgQ64tf/GIIYevWrY888sj2e3/xi19s2LAhhNDo79V33nnnm2++mZ+f/9hjj40cOfKUU04JIVx33XUfffTR3p9M061duzaE0KNHj+1fM7G+vv7111/fs2EBALLByJEjP/nkk+nTp3thFgDYAwIixLr00kuPOOKIEMLtt98+b968hrveeOONW265JYTQvXv3ESNGpLYvXLjwjjvuCCHccMMNRx99dCKReOSRRwoKCjZu3DhmzJjduvdGi/72YDK7Jbr2eeXKlevXr2+4vbKy8pprrokCYm1t7Z4NDgCQQfX19XffffeaNWsuueSSTM8FAFolARFi5efn//SnPw0hbNy48Ywzzvjud787bdq0GTNmXH311QMGDIhWFE6YMCF1tW/q4uU+ffrcfPPN0cb+/fvfcMMNIYTZs2f/9re/beL9hhC2bds2e/bspUuXRmsDd3cyu2vw4MEhhKqqqjPPPPOXv/zlokWL5s6dO3HixKOOOurBBx8sKSkJIaxfv/6pp57asmXLnt0FAEBGJBKJ7t2777///nvtHqurq0tLS3f5JngA0FoIiLAzQ4YMeeCBBwoKCqqqqh599NHLL7/8sssumzx5ckVFRadOnZ544omLL744dfAdd9zx1ltvJRKJKVOmNAx5N910U7S+b9SoUZ999tku7/TYY4+Nblx44YX9+/efOXPmHkxmdw0aNGjUqFEhhGXLll1yySXHHHPM6aefPmbMmOXLl48dO/ZXv/pVdNh555137rnn7vG9AADs3Lp168aOHduvX7+SkpKSkpK+ffuOGjVqyZIlDY8pLy/v3bt3IpHo1atXeXl5oxGefvrp6K2Wo1ejjsybNy/auGDBgmjLyJEjE4nE+PHjQwibN2+O9kZ/r92tyUQ6duyYSCSeffbZ0tLSq666qmvXriUlJe3atevXr9/QoUPfe++9HT7YV155ZeTIkaeffvqBBx7YsWPHI488cvDgwU899ZTLPgDINgIi7MKYMWOWLFkyevToI444ori4uEOHDr179x45cuTChQsvvPDC1GELFy688847QwhXXnnlgAEDGo7Qrl276IUL165dG61G3LlzzjlnwoQJ3bt3LywsPOiggz73uc/t7mT2zKRJk+bMmXP22Wd369atqKioW7dul19++YIFC+6///6vfe1rY8eO7dKlS7t27bp3797MOwIA2KE5c+Ycc8wxDz744LJly0pLS0tLS999992HHnromGOOmTBhQuqw9u3bP/7444lEYvny5VEBTPnss8++973vhRAGDBgwevTovTCZhsrLywcOHPjII49EV2xUVVUtW7Zs+vTp/fr1e+mllxoeWVNT8+1vf/u00057+OGH586d++GHH27btu3vf//7888/f9555335y1+urq5uzuQBIL0S1tW3auXl5aWlpSGE6C+czR/wtttui34I++Uvf9mc5WyQw954440TTzwxhHDKMQO++41m/WYSqa2traysDCHk5+cXFhY2f0CyU1lZWUFBQUFBQaYnQouoq6urqKgIISSTyaKiokxPh5ZSXl6eTCbTda5+9D8n/emtV0II8+fPP+mkk9IyZqs2Z86cr3/96yGE/Pz8b3/721/84hfz8/Pnz58/bdq06BvljBkzLr300tTxo0ePnjRpUjKZfOONN77whS9EG7/73e8++uijxcXFixYtOuyww1IHz5s379RTTw0h/PWvfz3uuONCCHV1dfX19T/+8Y9//OMfd+rU6dNPPw0h5OXlJRKJPZhMx44dt23bdthhh61YsaJPnz5jx4497rjjNm7c+POf//w3v/lNCOHAAw9cvXp19Eo1IYR77rnn+uuvDyH07NnziiuuiBZUvvfee7/4xS/eeeedEML48eN/9KMftdx/7dbi17/+9UUXXRRC+NGPftQoFu+xKO/us88+aRkNoI3Iz/QEAACAtq62tja6UKNLly7PPPPMwIEDo+3Dhg37zne+M2TIkA0bNtx6660XXHBBKuDeddddc+bMWbVq1fDhw19//fX8/PxXX311ypQp0a6G9XCH8vLyUv9OJBLJZLI5k4msWLHi1FNPfe6551Jx6pxzzrnssstmzJixfv36pUuXHn300dH2yZMnhxB69er1xhtvdO7cOTXC6NGjjz322H/84x8vvfSSgAhA9nAJMwAAkGGzZs1aunRpCOGmm25KBbvISSeddNttt4UQVq5cOXXq1NT2kpKSKBe++eab9913X2Vl5YgRI+rr6wcOHHj11Vfv5clE8vLyJk2a1Ghp24gRI6IbqVdCrKqqqqmpOeSQQ0aNGtWwHkYP6swzzwwhrFixojkPAQDSS0AEAAAybN68eSGEjh07XnXVVdvvHTZs2H777Zc6LOWss84aPnx4CGH8+PEjRox45513iouLp06dGl2GvJcnE0I48cQTU2sMU1KvH5168ajCwsLVq1d/8MEH11577fbjf/zxx82ZPAC0BAERAADIsGh1Xp8+fYqLi7ffW1RU1K9fvxDC8uXLG+269957DzrooPLy8unTp4cQfvazn+3y4uWWm0zfvn23Pz66Snon6uvr161bN2/evMcff/yiiy566qmn9nDeANBivAYiAACQYVGz69mzZ9wBPXr0eO2117Zvdp06dZo0adI3vvGNEMIJJ5wwcuTIDE7mgAMOaPq9LFu27KGHHnrttdfeeeed8vLyPZsqAOwdAiIAAJBhqct740TvXxy93XkjixYtim4sXbp01apVPXr0yNRkmn7p9D333HPjjTfW1taGEAoKCr7whS/07t27b9++X/rSl377298+9NBDuz9rAGhBAiIAAJBhvXv3/uCDD95///24A1auXBkd1mj7okWLbr/99hBCXl5eaWnpiBEjXnjhhUxNpolefvnl66+/PoTQv3//O++88+yzz27Xrl1q7+9///s9GxYAWo7XQAQAADKsV69eIYR33nmnrKxs+73V1dXR2yL36dOn0fbLL7+8urr6hBNOmDhxYgjhxRdfnDZtWkYm03TRyzUWFRX94Q9/GDJkSMN6GEKoqanZs2EBoOUIiAAAQIZ98YtfDCFs3br1kUce2X7vL37xiw0bNoQQTj755Ibb77zzzjfffDM/P/+xxx4bOXLkKaecErB+cy8AACAASURBVEK47rrrPvroo70/maZbu3ZtCKFHjx7bv2ZifX3966+/vmfDAkDLERABAIAMu/TSS4844ogQwu233z5v3ryGu954441bbrklhNC9e/cRI0akti9cuPCOO+4IIdxwww1HH310IpF45JFHCgoKNm7cOGbMmN2690aL/vZgMrsluvZ55cqV69evb7i9srLymmuuiQJi9PKIAJAlBEQAACDD8vPzf/rTn4YQNm7ceMYZZ3z3u9+dNm3ajBkzrr766gEDBkQrCidMmJC62jd18XKfPn1uvvnmaGP//v1vuOGGEMLs2bN/+9vfNvF+Qwjbtm2bPXv20qVLo7WBuzuZ3TV48OAQQlVV1ZlnnvnLX/5y0aJFc+fOnThx4lFHHfXggw+WlJSEENavX//UU09t2bJlz+4CANJLQAQAADJvyJAhDzzwQEFBQVVV1aOPPnr55ZdfdtllkydPrqio6NSp0xNPPHHxxRenDr7jjjveeuutRCIxZcqUhiHvpptuitb3jRo16rPPPtvlnR577LHRjQsvvLB///4zZ87cg8nsrkGDBo0aNSqEsGzZsksuueSYY445/fTTx4wZs3z58rFjx/7qV7+KDjvvvPPOPffcPb4XAEgjAREAAMgKY8aMWbJkyejRo4844oji4uIOHTr07t175MiRCxcuvPDCC1OHLVy48M477wwhXHnllQMGDGg4Qrt27aIXLly7dm20GnHnzjnnnAkTJnTv3r2wsPCggw763Oc+t7uT2TOTJk2aM2fO2Wef3a1bt6Kiom7dul1++eULFiy4//77v/a1r40dO7ZLly7t2rXr3r17M+8IANIiP9MTAAAA+B+9e/eO3k95J4455piqqqq4vaeffnp9fX2jjaeccsr2GyM33njjjTfeuMeTiWzdujVu18EHH7zDux48eHB0LfP27r///vvvv78p9wsAe4cViAAAAABALAERAAAAAIglIAIAAAAAsQREAAAAACCWgAgAAAAAxBIQAQAAAIBYAiIAAAAAEEtABAAAAABiCYgAAAAAQCwBEQAAAACIJSACAAAAALEERAAAAAAgloAIAAAAAMQSEAEAAACAWAIiAAAAABBLQAQAAAAAYgmIAAAAAEAsAREAAAAAiJWf6QkAtHrf/tH5zfn0qqqqLVu2hBDat29fXFycpkmRdT755JPi4uL27dtneiK0iNra2k2bNoUQCgsL99lnn0xPh5ayadOmwsLCZp6rH5j/5+hG1esdwlvpmBYAQAsTEAGaa8Ztv9ndT2lmcwQgs1IREACgLRAQATKgYXOsra2trKwMIeTn5xcWFjY6UmoE2Dua0gTLy8uTyeT252oAgNwmIAJktV0ub1QYAXbOakEAgGYSEAFat50XRnkRyHn6IABASxMQAXLZTvKitgi0FhIhAEBmCYgAbZS2CGQboRAAIDsJiHtozZo1IYRDDjkk0xMBSL8dtkVVEUgXoRAAoHXJhYB46aWXbtmyZScH3Hfffb169Qoh/PrXv541a9YOj3nooYcOPvjg6HZ5efkrr7zy/vvvd+3a9aSTTjr00EMbHbxhw4YxY8ZcdtllAiLQdmxfFSVFYJe0QgCAHJALAXGX8vP/52F++OGHuzx41apVP/nJTzZs2BB9OGvWrCuvvHLQoEENj5k1a1aXLl0GDx6c9qkCtCKSItCIXAgAkJNyISA+9thjO9y+dOnS8ePHn3DCCT169Ii2RAHx3nvv3X5RYVFRUQihrq7unnvu2bp167hx44477rj169dPnjx5ypQpRxxxxGGHHRYd+f7778+dO3fs2LEFBQUt9IgAWilJEdoaxRAAoC3IhYDYrl277TdWV1c/9thjJSUlV199dWpjFBAPPfTQHX5KCGH16tWrVq267LLLTj311BDCYYcdNm7cuCuuuOIvf/lLKiBOmzatW7dup59+evofCUDOaZQU9URo1eRCAIC2KRcC4g7Nnj17zZo111577b777httqaqq2rhxY+fOnePqYQhh69atIYTUp4QQOnfunEwmN2/eHH24ePHiBQsW3HrrrYlEoiWnD5CbGvZEMRFaBdEQAIDcDIirVq168sknjz322IbrBD/66KP6+voDDjhgJ594+OGHFxUV/e53vzv55JM7dOgQQnjyySdra2v79+8fHTBt2rT+/fsff/zxLTp/gLbA4kTIToohAACN5GZAfPTRR+vq6oYOHdpwY3T9cufOnZ966qm5c+d+9NFHXbt27dmz57nnnpu6PLlDhw7Dhw+fPHnyiBEjjjzyyA8//HDVqlVHH330wIEDQwjz5s17991377777r3/iAByXqonKomw94mGAADsRA4GxLfeemvx4sX/9m//1rNnz4bbo4A4f/78+fPn5+fn77PPPmvWrFmzZs2f//znYcOGDRkyJDrsq1/9ateuXZ988snFixfvt99+F1100fnnn59IJGpra2fOnPmlL32pb9++zZxheXl5M0dIqa6uTt2or69P44DALtXV1aXlKZN68qZrwNZu6s2/TN2++KZvZHAmaefrm8Pq6uqiG7W1tWn8Rt+iJv319UxPoVVK47m6ri4NP7xBG1FTU5Ous2t0xk7vubp9+/ZpHA0gC+VgQJw+fXpeXt7FF1/caHsUEEtKSsaMGXP88cfn5+eXlpY+8cQTzz777NSpU/v169erV6/oyOOPP377i5RfeOGF9evX33zzzc2fYVlZWVpiX0OVlZWVlZXNH8cvt9B0ae99dXV1qQZBZPr42anb514/OIMzSYuqqqqqqqpMz4KWVVtbW1pamulZ7MyURW9legqtW319fbrO1c750HRVVVXpPbvW1NSka6hEIiEgAjkv1wLi/Pnz33vvvVNOOeWQQw5ptOvLX/7ycccd161bt65du0ZbiouLhw8fvmnTpldffXX27Nk//OEP44atrKx84oknzjrrrIMPPjiEUFZWNn369L/97W+lpaV9+/YdOnRo9+7dW+5BARBCeOru56IbOVASYS8TDQEAaI5cC4jPP/98COHMM8/cflfPnj0bXdQc+cpXvvLqq6+uWLFiJ8M+++yzZWVl0arGysrK73//+2vXru3Vq9f++++/cOHCa6+99q677urTp08TJ9mxY8d0rUCsqqqKFh62a9euoKCg+QMWFhY2fxBoI5J5ybQ8Zerq6qK/gSeTyWQy2fwBc97vHngxuvGtm7+Z2Znslq1btxYVFTnN5qq6urpoaUx+fn72rEP5f2/8d3TD/3jpUl1dnZeXl65zdV4yLy3jQFtQVFTUsWPHtAwVXbycxnN1IpFI11AAWSunAuKGDRsWLlzYpUuXY489tumftf/++4cQNm7cWF9fv8NT/5YtW55++ukhQ4bsu+++IYSnn3567dq1V1999Ve+8pUQwurVq6+//vqHH374vvvua+I9pvGH+Lq6uigg5ufnFxUVNX/A/Pyc+l8CWlQiL5GWp0xtbW0UEBOJ9AzYdsy+67ep29n/1itbt25N17maLJS6cjkvLy/jX+XUO6I4paRddXV1Gs/VeaIDNFkymUzX2TX6BSrj52qA1iWnfqz84x//WF9fP3DgwLy8xn/OLSsr++Mf/5iXlzdo0KBGlfCTTz4JIXTr1i3uD0ezZ89OJpPnnntu9OHbb7+9//77R/Uw+sQzzjjj+eefLy8vz54VBwBtjTdxpo3zNsoAALScnAqIf/rTn0IIJ5100va72rdvP3v27M8+++yAAw447rjjGu56+eWXQwhx7628YcOG559/fujQoR06dEhtbJQao17pZbABskFUEmVE2gjdEACAvSB3Xnjl008//eCDD5LJZO/evbffm0gkBg8eHEK4//77Fy5cGG2sqKiYNWvWCy+80LFjx+3ftTkyc+bMfffdd9CgQaktRx111Icffvjii//zClxr16596aWXevbsWVxcnOaHBMCemnHbb6J/Mj0RaBEPzP9z9E+mJwIAQJuQOysQoyx4+OGHx73C4Pnnn19eXv7MM8/ccsstHTt2bN++/ccff1xfX9+xY8frrruuc+fO23/KypUrX3nllWuuuabh+5N885vffPXVVydOnPjCCy+UlJQsXry4rq5u5MiRLfS4AGgOlzaTSxRDAAAyItcCYr9+/eIOSCaTw4YNO+qoo+bMmfPee+9t2bKld+/effr0ufDCCzt16rTDT5k2bVq3bt1OO+20hhuLioruvffe6dOnL1iwYN26dZ///OeHDh3ao0ePdD4YANJNSaT10g0BAMis3AmI11577bXXXrvLw0444YQTTjihiWOOHz9+h9s7dOhw1VVXNX1uAGQPL5JIKyIdAgCQDXInIAJA01mQSDbTDQEAyCoCIgBtmgWJZA/dEACA7CQgAoAFiWSSbggAQJYTEAHgnyxIZG+SDgEAaBUERABoTEakRemGAAC0LgIiAOyY65pJO+kQAIDWSEAEgF2wIJFm0g0BAGjVBEQAaBIZkd2lGwIAkBsERADYDTIiTSEdAgCQSwREANhtXh6RHZqy6K1kMllUVJTpiQAAQDoJiACw5yxIJPLgf/+loqIi07MAAIAWISACQHPJiG2Zq5UBAMh5AiIApIeM2KbohgAAtB0CIgCk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MaIZ2Ul0KNacHhIaAkAZ2LlzZ58+fUTExcUlODj4tddeUxTl2LFja9asyc7Onjhxoq+vr3qBtmnTpiUmJqp1Ty1atLh3797KlSt37NiRlZU1aNCgxMTE4gddu3atGqjVqFFj6NChrVu3fvjw4bZt23788ceLFy++9dZbZ86ccXIqLqkYO3bsqlWrRMTLy2vgwIFt27a9efPm7t27jx49OmjQoILLb7/66is14vHz83v//ffr16+fn59/6dKl1atXX7p06ccff1yyZMmkSZMM7v/OnTudO3d+8OCBiAwYMKBz586VKlU6efLkypUrHz58OH36dEVRpk6dWvzLUgb3VYwrQQbYtQAAIABJREFUV6589tlnItKqVavevXvXqVPn1KlTmzdvvnXr1pEjR4KCgrTL94wyrv6dtGnTpk6dOteuXfv+++8///xznX5++OGHzMxMESl4RtA///nPzz///MUXX5wwYUL9+vXbt29v9NetlF2V9NYMe8MaEQEiAMDM7DZDFGLEMmc/0aFYZ3pIbggAZSY3N3fKlCkiUqVKlZ07d2oqB4OCgoYOHdqrV6/79+/PmDHjnXfe0SmhSkxMDAwM3Llzp6enp9rSs2fPvn37fvfdd1evXk1MTKxXr15Rg2ZmZn766aci0qhRo7179/r4+KjtI0aMmD59+oIFCy5evLhhw4ahQ4cW1cPZs2dXr14tIv7+/rt27apfv77aPmXKlIkTJy5durTgU5YvXy4iDRs2PH78uGbOIjJ27NiAgIBr164dPnxYk/IY0P/cuXMfPHjg5OS0devW3r17q439+/cfN25c9+7dL168+Nlnnw0cOLD4ykpT31fxMjIyRGTEiBFff/21mt4OHjz4k08+6dWr16lTp77//vvjx4+3adPGiOOWqJP+/fsvXLjw7Nmzly9fbtCggXY/3377rYh4e3v/6U9/0hli3rx5gYGB27Ztq1ixosFDG/EuCqX/rRn8hjUi9kAEAJhfQGBjTZRmh2ma5vZhIuouh6SHFoudDQGg7MXExFy4cEFEZs+erbPuuF27djNmzBCRc+fO6SzPFBFHR8eIiAjtuERE3n//ffWLf//738UMGhkZqa7zXbp0qSY9VH322WdeXl4icvDgwWJ6CA0NVbeWW7t2rSZlExEHB4fFixe//PLLOtdnZWXl5eXVqlVr3LhxOnOuUKFCYGCgiGhXTZa0/2vXrq1YsUJEPvzwQ016qKpTp05kZKSIZGRkREVFFXNTZXBfz+Xj47N8+XLt2s8XX3xx48aNahoVGhpqxHFL2kn//v3VL3T2MdQs8n3vvfdcXFx0RsnLy1u8eLFOemjE180oXel/awa/YY2IABEAYCns8HRmbcSIpmBvuaGING35D2tJD8kNAcCMjh49KiKVKlUaMWJEwUdHjRrl4eGhuUzb66+/XjDP0pTXFX8o84EDB0SkcePGXbrofvg7OTktX748LCysa9euxfTw66+/ikjXrl3btm2r85CiKAWrvVxdXf/4448bN26EhIQU7E37bArD+t+zZ4969svEiRML9t+5c2e1rKzgy1jKcUt6X881ceJEZ2dnncYGDRr069dPRA4fPqz+mzXKuCXtpGXLli+99JKIfP/999rtmkW+hZastmvXrnFj3f+0NuLrZpSu9L81g9+wRsQSZgCABbHn5cwqFjUbi73lhiorig7NPQUAsHdqqWDDhg3d3d0LPurh4dGgQYN//etfV65c0XnIz8+v4PUODnoVJ12+fFlEmjdvXuijAwYMKP7pjx49SklJEZFXX3210As6dOhQfA/5+fnJyclXr149f/78vn37du/eXcr+1TuqWbNmrVq1Cn3Kyy+/fPny5TNnzhQzK1Pflz5at25daPtrr722adOmjIyMlJSUF154wejj6tlJ//79FyxYEBsbe+vWLc00tmzZIiJ+fn4FU1cRKWYpvf5D379/X13frc3b27vgu8bgl0LPWzP4DWtEBIgAAMtChijEiKVgn7mhyvLTQ3JDALAcah5Rp06doi6oU6dOoXlEjRo1DBsxJyfn+vXrIlK7dm3DetCsjy4qG9JZFq1x9uzZr7/++pdffrl06VLBPKg0/atPuXnzpqIoxcxc+9hco4yr0vO+9FHU3wTNlK5cuaKJt4wybok6GTBgwIIFC/Lz83fu3Dl69GgRefTo0b59+6Sw41NUxfw103/o8ePHb9q0Sadx69atffv2NeAuCqXnrRn8hjUiAkQAgMUhQ1QRI5aIPUeHYvHpIdEhAFimYmIvdTs8dR2lnk8pXnZ2dk5Ojoi4uroa1oPmiUXNwc3NrVy5ck+fPtVuXLhw4fTp09VTjF1cXFq0aNGgQQN/f/927dpt3rxZPbrE4P5TU1P1mXleXl5OTk5Rp0ub+r70UdTQmnXNmtGNMm5JOwkICPD397948eL27dvVlG3nzp2ZmZmKogwePLjQIdzc3IwytBHvolAlujUD3rBGRIAIALBEZIgaxIjPZefRoVhwekhuCAAWq379+jdu3Lh27VpRF1y9elVEdE6GLY1y5cq9+OKLycnJah2iAerVq6coSn5+flFlVnfu3NFJ2Q4ePKieXdukSZMFCxZ069ZNO77UObnCgP7r1q174sSJ11577dixY4bdlGHjlui+9HHt2rWaNWsWbNdUR6pL140yrmGd9O/ff+7cuQcPHnz48GHFihXVQ4o7depUVHmmUYbeuHFjUceSGPFfgT63VvZv2II4RAUAYKHs/EwVHRyxUig7PCOlIMtMDzkdBQAsnHrU7/nz5wstWcrIyLh06ZIUseOhwdTeitoQcN68ea1bt/7Tn/5U1NPd3NzUVbS//fZboRfExcXptKxZs0ZE3N3df/rppz/96U86xY9qRWRp+vf39xeRxMTEok6Pyc3Nzc3NVU9YLoqp70sfp06dKrT9+PHjIuLi4qKGWUYZ17BO1AOLnz17tmfPHs0hxUWtXzbu0KbuSp9bM8sbVgcBIgDAcmlSMzJEFTGiSs0NiQ4t8MBlDlYGAGvx2muviUhaWlp0dHTBR1euXJmeni4ihR5PUcpBT5w4UbBeLy8vLyoq6uTJk+XKlSumh44dO4rIgQMH1GBLx8KFC3VakpKSRKRevXrVq1fXeSg/P//kyZOl7L9ly5YikpqaunPnzoLX371718vLy8nJadasWUXfkyHjlvS+nis8PLxg5pWYmKjW37Vt21Y9J8co4xrWSZMmTdTjv7dv375z586srKzy5cv/z//8jz4jlnJoU3elz62Z5Q2rgwARAGDpyBB12HOMSG6oYZnRoblnAQDQ15AhQ9TquTlz5uiEVrGxsXPnzhURPz+/klZ4Fe/jjz+uVKmSiIwfP/7WrVvaD82bN09d2vzmm28W08Ps2bMdHR1FJDg4ODExUfuhhQsX/vTTTzrXq3VbV65cuX37tnZ7ZmZmSEiIWtmn7mFnWP+9evVSzy8ePnz4kSNHtB/Kzs4ePnz4o0ePFEUZNmxYMTdVBvf1XFevXg0JCdF+Smpq6qBBg549eyYin332mRHHNbgTtVLvxx9/XLdunYj07dvXw8ND/3s01vyN3pXocWtmecPqIEAEAFgBMsSC7C1GJDrUZlHpIdEhAFgjJyensLAwEblz507Hjh1DQkI2bNiwYcOGCRMmBAYG3rt3T0QWLlxY1LkfhvH29p45c6aIxMXFtWzZcubMmd9//31MTEzfvn3VGr127doVn7X5+/sHBweLyPnz59u0aTNx4sQNGzYsXrz4rbfemjJliqura6NGjbSv79mzp4hkZmZ27tx506ZNCQkJhw8fXrJkSePGjSMiIsqXLy8iFy9e3Ldv36NHjwzoX1GUxYsXK4py//79bt26BQUFff3117t37w4PDw8ICPjhhx9EZPr06S+99FLxr4yp7+u53N3dv/766/bt23/xxRebN2+ePHlyy5YtY2Nj1bECAwONOK7BnQwYMEBEHj9+vH//fhEZOnSoPrdmotfNuP8KnntrZnnD6s7BdF0DAGBE6rEqnKmiw+ajVULDgiwnPSQ3BACr1qdPn7/97W+ffPJJZmbmsmXLli1bpnnI29s7Ojq6d+/eRh/0L3/5i6ur60cffXTr1q3PP/9c+6FXXnklJiZGLcQrxrJly1JTU3ft2nXv3r3Fixdr2t3c3NatW/fdd9+dP39e09inT58RI0ZER0efPXt24MCBmnYHB4fJkye3atWqf//+eXl53bt379Onj3rwRYn6F5HXXnvtwIEDQUFBN2/eXLdunVpBphll/PjxOrdprvsq3nfffTdw4MDY2Fg1NNQYPHjwihUrjDuuwZ00bNiwadOmp0+fFpFatWp16tTpufdlrKFN2pWet2aWN6w2KhABAFbD5sMyg9lkNSIlh4WykPSQqkMAsA0TJ048c+bMuHHj/Pz8ypcvX758eX9//wkTJiQkJPTp08dEg44fP/63334bPHiwj4+Pq6trnTp1unfvHhERcfLkyTp16jz36W5ubj/88MO3337bs2fPatWqubi41KxZc+jQoSdPnuzXr1/B61etWrV9+/auXbvWrl1bHW7EiBFxcXFffPFF3759R48eXalSJXd3d82JtyXtX0S6dOly+vTpyZMnN23atEKFCp6eni1atAgODk5ISFiyZImeL4up76t4b7zxxtmzZ0NCQurVq+fq6urt7d2xY8dvvvnmm2++0dmV0ijjGtyJWqknIkOGDFG3ZSwpI75uxv1XoM+tmeUNq6EUdVQQrEJGRsaTJ09ExMPDw83NrfQdzpkzJzQ0VEQ2bNigHaID0Dhx4kSbNm1EpHWP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Y8eOmowyOzv7/Pnz58+f37hx4969ezt37qy50uCXDoD+1NNUrChJJD0EAAAAbAAViLB9169fnzlzpoi0bNnys88+++abbyZNmlSzZk0R+e233/r166d9cXh4uBqB1a1bd968eVu2bPn2228XLFjg7+8vIocPH54/f37BIU6ePDl+/Phq1arNmzdv8+bN7777rtq+a9eud9555+7du05OTsOGDVu5cuXq1atHjRrl6uqam5s7ffp07bitQ4cO48aNE5FFixb961//0rRPnjw5OTm5fPnyf//73xVFKeZOIyIicnJyZs2aJSIVK1bMycnJycmZPHmyAZPRmDFjxqlTp/z8/CIiImJjY/fs2aO+Ys+ePRs8eHBOTk4pXzoABrCWhcykhwAAAIBtoAIRtk9dETxs2LAVK1aoFXCDBw+eOnXqn//852PHjh06dOinn37q2rWrenFkZKSI1K9f/8SJE5UqVdJ0MmHChBYtWly+fPngwYOzZ8/WGWLevHmvv/76999/7+XlpWnMzc2dMmWKiHh5eW3fvr1jx45q+7Bhw4YPH96rV6/bt2/PmjWrf//+Li4u6kNhYWG7du26fv36iBEjjh8/7uTk9PPPP0dFRakP1atXr/g7dXBw0PxTURRHR8fSTEaVmJjYvn373bt3V6hQQW3p0aPH0KFDv/nmm1u3bp07d65Zs2aleekAlJRahGjuWZgH6SEAALATQ4YMiYmJeeuttzZu3Ojl5ZWfn79u3ToXF5eBAweae2qwU1Qgwi74+Pho0kNVtWrVNm3apIZlmlQrOzs7JyenVq1a48aN047ARMTDw6NLly4ikpiYWLD/nJycJUuWaKeHIrJ+/fpz586JyIwZMzSBnapt27Zz5swRkatXr65evVp7FDUu/Ne//vXVV19lZWWNGjUqPz+/Y8eO48ePL80rYMBkVA4ODhEREZr0UDVq1Cj1C81OiAa/dAAMY/kZoinKDwEAAOzBokWLYmJipk6dumfPHvXXzLy8vODgYHXJGmAWBIiwCxMnTiy4+17t2rWHDBkiIv/85z8zMzNFxMXF5Y8//rhx48akSZMKdnLnzp2i+m/btm1AQIBO49GjR0XE09NzzJgxBZ8ybNgwde9F9TKNbt26jRgxQkRCQ0NHjRp18eLF8uXLr169uvjFy89l2GREpE2bNpoaQw1fX1/1C82ejwa/dAAM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unX+/PmdO3dWEzTR70zIEk0mJCTkzp07s2bNqlatWnR09OHDh5/bf2mG00dp7h12ggpE2IsaNWqEh4eHh4c/98q3335bXZBbUMEenj179twOGzRooH4cFyMgICA7O7uoRzt16pSfn6/T2K5du4KNqqlTp06dOtXgyaiKOWmrZs2ahQ5dopcOgNGVZREi6SEAADCWVatWffrpp+rGR6qFCxeKyBtvvKFu0FSUTp06rVu3Ljw8PCoqSrt98eLFIhIYGFiiUe7cuSMiOkejXLlyRd0V6rn0nMyOHTs2bdrUokWLWbNm+fn5DR48ePTo/8fevcdZVdeL//9sZpgBGURKRUNBjIuAyVcRNeTIlGipRfhVT/pFUw7GcdBA+5ZY3rBE9JQdLz/wAEJ5PUJ5De0ctUQLQ4kMDfCOqIAXQENgBOby+2Od726a6549+76fzz96DGv2rPWZLYPx8v1Z619ffPHF8vLyRK7S3sslqIPfO8XABCIAFIJceJpKR6iHAFC0Nm/e/NWvfjW6bd+OHTuuvfbaW265JTR43GVLpk+fXlZWNn/+/Ouuuy4ayNi6dev48eP//Oc/9+3b91//9V/bdZXBgweHEBr2uCeffPKEE06Ihic++uijji/m448/rqqqKikpmTt3bklJyfjx448//vhXX301epZmm7Zt27Zjx44kvvc2dfB7pxgIiABQODLzNJV0jB8CAEXr9NNPX7p0aZ8+fQ488MAePXpceeWVIYSrr7762GOPbf0L+/XrN3v27PLy8ssvv3zPPfccOHDgZz7zmXvvvbdXr1533nlno5m+Nq8yffr0EMK0adMGDRp0/PHH9+3b94QTTujXr9+IESNCCCeeeOLdd9/dwcVccsklGzdu/M53vjN8+PDoq6IvueGGG1avXt3KyUtKSnr27FlTU3PEEUecfPLJ7f3e29TB751iICACQIHIzBCizcsAQGpdfPHFixcvHjduXF1d3T777PONb3xj8eLFUdJq08SJE5ctWzZ+/Pj+/ftv3Ljx8MMPnzx58sqVKxvdWT6Rq3zjG994/PHHKysrN2/evHr16kMPPfT2229//PHHb7jhhiOPPPKdd95pcz9v64v5r//6r1/84hcHHHBAw8nKgQMH/uAHP9i1a9ekSZNaukVV5Lbbbuvbt+/atWvfeOON9n7vber4907Bi7X+G5QcV11dvX37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9hLSzhAiAAAUJAERANIuTTuXQ46NH4YQhlUONYQIAAAFRkAEgPQqnnoYpyECAEAhERABII2KsB7ayAwAAAVGQASAdCnCehhnCBEAAAqGgAgAaVHM9dAQIgAAFBIBEQBSr5jrYZwhRAAAKAwCIgCkmHoYDCECAEABERABIJXUw7hhlUMNIQIAQAEQEAEgZdJXDwEAALJFQASA1EhrPcy78cOIIUSgkJx//vmxWCwWi/3gBz/I9loAIKMERABIAfWwFRoiUAAeffTR+fPnhxBmzpw5c+bM6OA777yzdOnSZcuWZXVpAJB2AiIAdJR62ApPUwEKwObNm88///xOnTrNnj37sssuix9fsGDBqFGjTjrppCyuDQAyQEAEgA5RDxNhCBHIa1VVVZs2bbrzzjurqqqyvRYAyAIBEQCSpx4mwhAikNfq6+t/8pOfvPvuu+PHj8/2WgAgOwREAEiSetguhhCh2Gzbtq22tjatl6irq3v//ffTeokQQiwW69u3b69evdJ9objdu3dv3769vr4+Y1cEgNYJiACQcwqvHhpChII3a9asWCw2ePDgEMI999wzePDg7t27l5aW7rPPPpWVlfPmzWspJj799NNVVVVf+tKX9t9//+7duw8ePPiUU065//77m76+c+fOsVjs0UcfDSE8/PDDRxxxRJcuXe67776Gr9mwYcPUqVOHDBlSUVFRUVExaNCgyZMnr1r1D/8Bo7q6esCAAbFYrH///tXV1Y2u8sADD0SPWr711lvjB5cuXRodXLFiRXSkqqoqFotNnz49hPDxxx9Hn73hhhvau5hI9+7dY7HYww8/vH379gsuuGDvvfeuqKjo0qXLkCFDzj333Ndff72Dbx0AdFBpthcAAPnH7GEShlUOXblklZIIBW/GjBlXXHFF/JebNm16+umnn3766fnz5z/66KOf/exn45+qqamZMGHC3Xff3fDLX3755Zdffvmxxx6rrKx8/PHHO3fu3PQSc+fOveCCC5oO6C1evHjChAmbNm2KH3n11VdfffXVuXPn/vjHP/7BD34QHezatev8+fMrKyvfeOON6dOnN6x+f/vb377zne+EEI477riLLroo+Xch4cU0VF1dPXr06Hij3LVr15o1a9asWfOf//mf//Vf//XlL385/sqk3zoASI4JRABon7TWQ4C8tm7duiuvvDKEMHz48B/96Ed33XXXJZdc0rt37xDCc889d8YZZzR88U033RQlsH79+s2YMWPRokW//OUvZ86cOWjQoBDCkiVLrrvuuqaX+NOf/nThhRfuu+++M2bMWLhw4emnnx4dX7x48de//vVNmzaVlpZOmDBh7ty5CxYsmDRpUnl5eW1t7Q9/+MOGue24446bPHlyCOHGG2984YUX4scvvfTSDRs2dOvW7ec//3ksFmvlO501a1ZNTc1VV10VQujRo0dNTU1NTc2ll16axGLiLr/88hUrVgwcOHDWrFnLli177LHHonds9+7dZ599dk1NTQffOgBImglEAGiHdNfDQh0/jBhChIIX7QieMGHCnDlzogm4s88++7LLLjv11FOfffbZp5566sknnxwzZkz04tmzZ4cQ+vfvv3z58r322it+kosuuuiII4547bXXfve731199dWNLjFjxoyRI0c+9NBDPXv2jB+sra2dNm1aCKFnz54PPvjg6NGjo+MTJkz4l3/5l7Fjx37wwQdXXXXVP//zP5eVlUWfuv766xcvXrxu3bqJEyc+//zzpaWlzzzzzLx586JPHXzwwa1/p506dYr/bywWKykp6chiIm+++eaoUaMeffTRPffcMzpy0kknfetb37rrrrs2bty4evXqww47rCNvHQAkzQQiACRKPUwJT1OBwtanT594PYzsu+++9913XxTL4lVr165dNTU1BxxwwOTJkxsmsBBCRUXF8ccfH0J48803m56/pqbmlltuaVgPQwj33HPP6tWrQwiXX355PNhFjj766GuuuSaEsHbt2gULFjS8SpQLX3jhhZ/97Gc7d+6cNGlSfX396NGjL7zwwo68A0ksJtKpU6dZs2bF62Fk0qRJ0QfxOyEm/dYBQNIERABIiHqYEsYPoeBdfPHFTe++d+CBB55zzjkhhD/+8Y+ffvppCKGsrOztt99+5513LrnkkqYn+fDDD1s6/9FHHz1s2LBGB5cuXRpC6N69+wUXXND0SyZMmBDdezF6WdwJJ5wwceLEEML06dMnTZr0yiuvdOvWbcGCBa1vXm5TcosJIRx11FHxGcO4vn37Rh/E7/mY9FsHAEkTEAGgbephahlChAI2YsSIZo+PHDkyhFBfX7927dqmn62vr9+wYcPSpUvnz59/5pln3n///S2dv9nNxdF03sCBA7t169b0s+Xl5UOGDAkhvPHGG40+deONN37uc5+rrq6+8847Qwj/9m//1ubm5TYlvZjoDoaNRLukW5H4WwcASXMPRABog3qYWtGdELO9CiBd+vXr1+zxeJh74403Bg8eHH28Zs2a22677fe///0rr7wS3T+xTX369Gl6MGp2LV06hHDQQQf9/ve/b9rsevToMWvWrFNPPTWEMGLEiKqqqkTW0LqkF7PffvslfpUk3joASJqACACtUQ/TxNNUoNjE9zXHa9dPf/rTyy67rLa2Nvrs4YcfPmDAgEGDBo0cOfKRRx657bbbmj1Ply5dmh6Mb+9tSWlpaQgh2j3dyIsvvhh9sHr16nXr1h100EGJfDutSHoxiW+dTu6tA4CkCYgA0CL1ME0MIUIBW7t2be/evZsejz8DZMCAASGEp5566vvf/34IYejQodddd92JJ57YsAz+93//d7suOmDAgHfeeeett95qZVXxSzf04osvXnvttSGETp06bd++fdKkSY8//ni7Lp3CxSQotW8dACTCPRABoHnqYVppiFCoVqxY0ezx559/Pvqgf//+IYTonoPl5eVPPvnk2LFjG80V1tTUtOui0TlfeeWVHTt2NP3s7t27o8ciDxw4sNHx8847b/fu3SNGjLj11ltDCE888cQdd9zRrkunajGJS+1bBwCJEBABoBnqYWZoiFB4/v3f/71pw9qwYcOCBQtCCIcddlhFRUUIYf369SGEgw46qOmN/+rr6+O1MUFf/OIXQwiffPLJnDlzmn72F7/4xQcffBBCOOaYYxoev+6661544YXS0tLbb7+9qqrq2GOPDSF897vfff/999t19ZQsJnGpfesAIBECIgA0ph5mhnsgQkFat27d5MmTGzbETZs2nXXWWdEt/3784x9HB6MNvGvXrt24cWPDL9+5c+fFF18cVbDoHn+JOPvssw855JAQwrXXXrt06dKGn1q+fPmVV14ZQujbt++kSZPix1euXDljxowQwrRp0w477LBYLDZnzpzOnTtv2bJlypQp7fqWGwXTJBbTLql96wAgEQIiAPwD9TDDDCFCgenateu8efNGjRp1/fXXL1y4cNq0acOHD3/mmWdCCKNGjRo7dmz0slNOOSWEsGvXruOPP/7ee+998cUXlyxZcuuttx566KG33HJLNKW4cePG+++/f+vWrW1etLS09IYbbgghbNmy5ctf/vK//uu/3nHHHXfdddeFF1543HHHRROFM2fOjO/2jW9eHjhw4BVXXBEdHDp06LRp00IIixYteuSRRxL5ZqPHoWzbtm3RokWrV6+OZgPbu5j2Su1bBwCJ8BAVAPg79TDD3AkRCs+DDz541llnPffcc88991zD46eddlq0izly8sknT548efbs2WvWrBk/fnz8eCwWmzp16pgxY77+9a+HEE4//fQxY8Y88cQTbV537NixN9988/e+971du3bNnTt37ty58U/16NFjzpw53/zmN+NHZsyY8Ze//CUWi82bN69hyLv88ssXLlz42muvTZ48efTo0T169Gj9okcccUT0QXTy66+/PkqQ7VpMe6X8rQOANplABID/ke56SEs0RCgko0aNWr169dSpUz//+c936dKlZ8+eo0aNuv3223/1q1/tueeeDV85a9asxYsXn3jiiX369CkvL+/Tp8955523YsWKm2666Wtf+9rUqVN79uzZpUuXvn37JnjpKVOmrFq16qKLLjrkkEO6deu2xx57DBgwoKqqauXKlQ2D3cqVK6+77roQwre//e3jjjuu4Rm6dOkS3bhw/fr1UQps3UknnTRz5sy+ffuWlZV97nOf22effdq7mOSk/K0DgNaZQASAEDJSD/+4ZWznzum+SP4xhAiFZ7/99rvppptuuummNl95yimnRBtym2p6ht27d7d5wgEDBkTPU27FsGHDdu3a1dJnv/SlL9XX1zc6eOyxxzY9GLnssssuu+yypBcT+eSTT1r6VO/evZu9dLveOgDoIBOIAJCJerj0w+b/mkfQEAEAILcJiAAUuwzUQ7c+BAAA8peACEDxOmqvh9TDHGEIEQAAcpaACECRyswjU9TDdtEQAQAgB3mICgDFSD3MQYYQIa/17t27srIyhFBSUpLttQAAKSYgAlB01MNctnLJqmGVQ7O9CqDdxo0bN26cP/cAoDDZwgxAcVEPc5l0CAAAOUhABKCIqId5wUZmAADIKQIiAEUhMw9cDuphhxlCBACAXCMgAlD4MpMOg3qYIp6mAgAAOUVABKDAqYd5SkMEAIAcISACUMjUwzxlIzMAAOQOARGAwpSxmx4G9TBtDCECAEAuEBABKEAZS4dBPUwbQ4gAAJAjBEQACo16WEgMIQIAQNYJiAAUFPWwkBhCBACAXCAgAlAgMnnTw6AeZsqwyqGGEAEAILsERAAKQSbTYVAPAQCAYiIgApD31MPCZggRAACyS0AEII9leNtyUA+zR0MEAIBsERAByFcZTodBPcweT1MBAIAsEhAByD+ZHzwM6mEOMIQIAABZISACkGcynw6DepgDDCECAEC2CIgA5I2sDB4G9TCXGEIEAIDMExAByA9ZSYdBPcwlhhABACArBEQAcl22Bg+Deph7hlUONYQIAAAZJiACkLuymA6DepjDNEQAAMgkARGAHJXFdBjUwxxmIzMAAGSYgAhAzsnu4GFQD/OBIUQAAMgYARGAHJL1dBjUw3xgCBEAADJJQAQgV2Q9HQb1MK8YQgQAgMwQEAHIvlwYPAzqYV4xhAgAABkjIAKQTTmSDoN6mIeGVQ41hAgAABlQmu0FAFCkcqQbBukwz61csso0IgAApJWACEBG5U43jKiHec0QIgAAZIAtzABkSO7sVo5TDwuDhggAAGklIAKQdjmYDoN6WCjsXwYAgHQTEAFIo9xMh0E9LDiGEAEAIH3cAxGA1MvNaBinHhYYd0IEAIC0EhABSCXpkKyIGqLtzAAAkA62MAOQGjm7WzlOPSx45hABACAdTCAC0CE5Hg3j1MOCZyMzAACkiYAIQDLypRtG1MPiYSMzAACknIAIQDvkVzeMqIfFwxAiAACkg4AIQNvysRsG6bBYGUIEAIDUEhABaFGedsOIelicDCECAEDKCYgA/IO8joZx6mExixqiIUQAAEgVARGAEAqlG0bUQ4KNzAAAkDoCIkDxKqRoGJEOidjIDAAAKSQgAhSXwouGceohjRhCBACAlBAQAQpfAUfDOPWQRgwhAgBAqgiISXr33XdDCAcccEC2FwLQvGKIhhHpkFYYQgQAgI4rnID41ltvPfTQQy+99NLHH3/82c9+tk+fPqeddtrgwYMbvmbhwoX33HNPs19+22239e7dO/q4urr66aeffuutt/bee++jjz76wAMPbPTiDz74YMqUKd/61rcERCB3FE8xbEg9pBWGEAEAICUKJCD+4Q9/uPHGG2tra0MI++6775YtW957773ly5d/85vf/D//5//EX/bee++1eap169b9+Mc//uCDD6Jf3nPPPd/+9rdPPvnkhq+55557evbsecopp6T0mwBon+IshnHSIYmIGqIhRAAA6IhCCIh/+9vfbrrpptra2n/6p3+aOHHiZz7zmdra2l//+tc///nPFy5ceOihhx522GHRK6OAeOONNzYdKiwvLw8h1NXV/fSnP/3kk08uvfTS4cOHb9y4cfbs2fPmzTvkkEMOPvjg6JVvvfXWkiVLpk6d2rlz5wx+l0BemnrMyDZfs2vXrq1bt4YQunbt2q1bt1ZeWb/t1n880PiPspYse/edBF+ZL9RD2kVDBACAjiiEgPjEE0/s2rVr8ODB3/3ud0tKSkIIJSUl48aN27Jly0MPPbR48eJGAfHAAw/s0qVLs6d6++23161b961vfWvUqFEhhIMPPvjSSy89//zz//jHP8YD4h133NGnT58vfelLmfjegDx387Jn23xN1RFHNnu8SS5M3jEHJJoaUyhN1VI6pL1sZAYAgA4qhID4+uuvhxAqKyujehg3cuTIhx56KPpsCGHXrl1btmzZa6+9WqqHIYRPPvkkhPCZz3wmfmSvvfYqKSn5+OOPo1++9NJLK1asuOqqq2KxWMq/EaA4/X/Ln9u5c+ex+zzaqVOnRn+ORbKS/zouVctuGCLVQ5JmCBEAAJJWCAGxpqZm7733bvo8k2iLcXRjxBDC+++/X19fv99++7Vyqs9//vPl5eW//vWvjznmmD322COE8Ktf/aq2tnbo0P/5K8cdd9wxdOjQI49sflwIIEENb19YX1dX8//+pGpW66N8eZoXExd9g7GK74QQvpjwVyUy+0nxMIQIAAAdUQgB8Yorrmj2+HPPPRdC+PznPx/9Mtq/vNdee91///1Llix5//3399577379+p122mnx7cl77LHHxIkTdlX+2QAAIABJREFUZ8+ePWnSpMGDB7/33nvr1q077LDDRo8eHUJYunTpq6+++pOf/CQT31W2Pffcc6WlhfDbA1LujTfeiD6or69P5PXpftRJS3mxkMJiVA/bJZG7T8apjUXCECIAACSnYAvRypUr77///hDCqaeeGh2JAuKyZcuWLVtWWlq65557vvvuu+++++6zzz47YcKEsWPHRi/76le/uvfee//qV7966aWXPvvZz5555plnnHFGLBarra29++67R44cOWjQoA6u7aOPPqqrq+vgSSLxfrF9+/bt27d3/IQrV66MPrj55ptvvvnmjp8QCtjGN97csWNH/JfH7vNosy/bvTvRE9bV1aXqD4cQwu/Xvtns8eG9WhvEzjWflpwfQgg7N6f1KmcPSOgP9rkrX+jghXbv3r078d8QpNSAo/qtXvpqw5/ZNKmtrc3AVciimpqampqaFJ2qtfFzoKHq6urNm1Pz/weiv0Ol6mwhhFgs1vAuWAAFqQAD4s6dOxcuXPjAAw/U1dWNHz/+C1/4QnQ8CogVFRVTpkw58sgjS0tLt2/fft999z388MMLFiwYMmRI//79o1ceeeSRTTcpP/744xs3bmxp2rFd6urqEhxcSlyqTvjpp5+m5DxQDHqUfDLl0BUNDuy34v33sraahDW7yBysitWdJoYQQqr/tOyIbx/2v9p8zbwX/5KBlZCcIccOXL301SHHDsz2QgBot/r6+tT+HSrlfyMDKGyFFhCXLl06f/78TZs2denSZeLEiV/5ylfinxozZszw4cP79Omz9957R0e6des2ceLEjz766Jlnnlm0aNEPf/jDlk67c+fO++6774QTTujdu3cIYceOHXfeeeef//zn7du3Dxo06Nxzz+3bt2/iiywpKUnVv67iLbJTp04pea7LF77whd/85jchhP79+8ffKKChbdu2/fWvfw0hHDpkv0Y/d0fut3+CJ1nx3saGv4z+RMjis5n+3GxVTPjbSa2dpd8OITTzNJl8cMHhw1v6VG1tbfRn9Zy//DmTS6KhWCy25tnX0tQQ4/9y96S1AlZfX5/Kf75+p0DCWnrWXBKiDR+dOnVKydmCP/aB4lA4AXHr1q233Xbb0qVLQwijRo0677zz9t1334Yv6NevX79+/Zp+4Ve+8pVnnnnmzTeb3+sXefjhh3fs2HHWWWeFEHbu3Pl//+//Xb9+ff/+/Xv16rVy5cpLLrnk+uuvHzgw0b+N7LXXXol+V22prq6Odi7vsccerTxdOnHRo2NCCD/60Y+i7xdoZPny5UcddVQIoby8c9euXZM7yah+B8c/rq2t3blzZwihtLS0rKwsOtj6g1MyY+XmTQ1/mZmbKsYqvrNHBi6TDZs2beratWvXrl0v+9Lxrb/SPRnTZ/iYYSuXrEr6J7cVdXV10RR/SUlJeXl5ys9Pjqiuri4pKYn/Wd1BpSmqIVAMunTp0rNnz5ScauvWrSGEPffcMyVnAygSBRIQP/jgg2nTpm3evLlPnz4XXXTRIYcckvjX9urVK4SwZcuWlv6T8tatWx944IGxY8dGN7Z44IEH1q9ff+GFF0bjjW+//fb3v//9//iP//jZz36Wou8GoI1al5W82PSiqU2KSTwppVC1+QQYhbGDPE0FAADapRAC4o4dO66++urNmzePGTOmqqqqc+fOzb7mt7/9badOnU4++eRGlXDTpk0hhD59+rQ0eb5o0aKSkpLTTjst+uVf//rXXr16xTdH9+nT58tf/vJjjz1WXV2djokGgKZaKXeZbIuNrpV0T5QO20th7IhhlUNXLlmV7VUAAEA+KYSA+OSTT65fv/7II4+cMmVKS6/p2rXrokWL/va3v+23337Dh//DDaqeeuqpEEJLz1b+4IMPHnvssXPPPTe+tzc0uclFdPuMFD47FSBpLVW8DITFhpdIMCZKh2nSemGUF4MhRAAAaI9CCIiPP/54CGHcuHEtJbzopvWnnHLKvffee9NNN33ve98bNmxYCOHTTz+9//77H3/88e7du7d0v7+77777M5/5zMknnxw/cuihh/7nf/7nE088ccIJJ4QQ1q9f/7vf/a5fv37dunVL/fcGkCIZDottDidKh1lkgNEQIgAAtEveB8Ta2tp33303hHDFFVc0+4L9999/zpw5IYQzzjijurr6wQcfvPLKK7t37961a9cPP/ywvr6+e/fu3/3ud5t9sMnatWuffvrpiy++uOG26P/9v//3M888c+uttz7++OMVFRUvvfRSXV1dVVVVer4/gPRqmvbSkRTj5zzmgAOlw9xXDAOMUUM0hAgAAInI+4D44YcfJrh3uKSkZMKECYceeujixYtff/31rVu3DhgwYODAgd/85jd79OjR7Jfccccdffr0qaysbHiwvLz8xhtvvPPOO1esWLFhw4YvfOEL55577kEHHdThbwUgJ6QvKT7/8bjnPw4h/E9+anMOjtxUSAOMGiIAACQi7wPifvvt98gjjyT++hEjRowYMSLBF0+fPr3Z43vssccFF1yQ+EUB8lrHk+LzH49rerBhZhITC0m+DDDayAwAAAnK+4AIQOY1Soot9cRmu2Gz4lFJSSx4uZYXDSECAECbBEQAOqppT0w8HTaiJBa5DO+PNoQIAACJEBABSJnoASlfPCR88f8dSTr3KIk0K+UDjJ6mAgAAbRIQAUiBlp6t3DD3JBcTlUQSl/QAo4YIAACtEBABSF5L3bBZHYyJSiId1/xvnmNG3nXNL885ZmTIpWe8AABA7hAQAWi3dnXDZnUkJiqJpMNd1/zynKvPyPBNGAEAIC8IiAAkquPdsFnxZJNcSZQR6bhzrj7jrmt+mcgrW/r9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2dHccYYQAQDIGAERAMgOD1dJmo3MAABkkoAIAGSNUcSkaYgAAGSMgAgAZJlRxOS4GSIAAJkhIEJRO//882OxWCwW+8EPfpDttQBFzShi0gwhAgCQbgIiFK9HH310/vz5IYSZM2fOnDkzOvjOO+8sXbp02bJlWV0aUKSMIraXjcwAAGSAgAhFavPmzeeff36nTp1mz5592WWXxY8vWLBg1KhRJ510UhbXBhQzo4jtpSECAJBuAiIUqaqqqk2bNt15551VVVXZXgtAY21mxEwuJvdpiAAApJWACMWovr7+Jz/5ybvvvjt+/PhsrwWgRUYRAQAgFwiI5Jlt27bV1ta260vq6uref//9bF29vVK42lbEYrG+ffv26tUr3ReK27179/bt2+vr6zN2RaAw2NGcIEOIAACkj4BITps1a1YsFhs8eHAI4Z577hk8eHD37t1LS0v32WefysrKefPmNc15nTt3jsVijz76aAjh4YcfPuKII7p06XLfffc1fM2GDRumTp06ZMiQioqKioqKQYMGTZ48edWqxn/pSuLqkaeffrqqqupLX/rS/vvv371798GDB59yyin3339/+lZbXV09YMCAWCzWv3//6urqRld54IEHokct33rrrfGDS5cujQ6uWLEiOlJVVRWLxaZPnx5C+Pjjj6PP3nDDDUm8dSGE7t27x2Kxhx9+ePv27RdccMHee+9dUVHRpUuXIUOGnHvuua+//noH3zqgqHi4SiI0RAAA0kRAJD/MmDHj7LPPfvnll6Nfbtq06emnn540adKxxx67efPmZr9k7ty5p5566gsvvLB79+6GxxcvXjxs2LBbbrllzZo127dv3759+6uvvnrbbbcNGzYs/iTipK9eU1NzzjnnVFZW/sd//MeSJUvee++9bdu2vfzyy4899tjpp58+ZsyYRotJ1Wq7du06f/78WCz2xhtvRAUw7m9/+9t3vvOdEMJxxx130UUXNXv1BCXx1lVXV48ePXrOnDlbt24NIezatWvNmjV33nnnkCFDfve73zV8ZdJvHVAkjCImQkMEACAdBETywLp166688soQwvDhw3/0ox/dddddl1xySe/evUMIzz333BlnnNH0S/70pz9deOGF++6774wZMxYuXHj66adHxxcvXvz1r39906ZNpaWlEyZMmDt37oIFCyZNmlReXl5bW/vDH/7w7rvv7sjVb7rppugM/fr1mzFjxqJFi375y1/OnDlz0KBBIYQlS5Zcd911aVrtcccdN3ny5BDCjTfe+MILL8SPX3rppRs2bOjWrdvPf/7zWCzWyvs8a9asmpqaq666KoTQo0ePmpqampqaSy+9NOm3LoRw+eWXr1ixYuDAgbNmzVq2bNljjz0WvWO7d+8+++yza2pqOvjWAcXGKGKbNEQAAFKuNNsLgLZFe3InTJgwZ86czp07hxDOPvvsyy677NRTT3322WefeuqpJ598csyYMQ2/ZMaMGSNHjnzooYd69uwZP1hbWztt2rQQQs+ePR988MHRo0dHxydMmPAv//IvY8eO/eCDD6666qp//ud/LisrS+7qs2fPDiH0799/+fLle+21V/wkF1100RFHHPHaa6/97ne/u/rqqxt9g6la7fXXX7948eJ169ZNnDjx+eefLy0tfeaZZ+bNmxd96uCDD279fe7UqVP8f2OxWElJSQffuhDCm2++OWrUqEcffXTPPfeMjpx00knf+ta37rrrro0bN65evfqwww7ryFsHFKGoIbbUCqPjrXdGAACgXQTELEjhoyTiA1w7d+5sOMyVtF27dnX8JOnQp0+feL+L7Lvvvvfdd1///v137dp19dVXNwqINTU1t9xyS8MeF0K45557Vq9eHUK4/PLL4wkscvTRR19zzTVVVVVr165dsGDBBRdckMTVd+3aVVNTc8ABB0yePLlhAgshVFRUHH/88a+99tqbb77Z9LtL1WorKirmzZt34oknvvDCCz/72c+mTp06adKk+vr60aNHX3jhhS28tQlJ+q3r1KnTrFmz4vUwMmnSpLvuuiuE8Prrr0cBMem3Lrtqa+tS8iNTV1cX/yBnfwZJidraWo8SSpUj9u21fOOGlj67dN1bI/b/XCbXE/8nmws/yINHDvjr71/+829fPPSfDsnuSgpPfX19Cv8R19bWpeQ8UAx27dq1bdu2lJyqpqYmFoul6mwhhFgs1q1bt1SdDSA3CYhZUFNTk6q/QDbsDik5Z/yEuebiiy9u2O8iBx544DnnnDN//vw//vGPn376aZcuXeKfOvroo4cNG9bo9UuXLg0hdO/evVHkikyYMOGKK67YvHnz0qVLG70gwauXlZW9/fbbLX0LH374YUufSuFqTzjhhIkTJ86fP3/69OmrVq165ZVXunXrtmDBgtY3L7cp6bfuqKOOis8YxvXt2zf6IP6bNum3LtvqU/IjE38for+XdvyE5Cz/iFNreK/9Qgh/em9js599fsP6EMKR++2fmcXk2g/ykGMHrvrDKy89s2boqEHZXkuhSek/Yv9FARJVV1eXkoGJ8P/+xE7V2UIIHfx/2gB5QUDMgh49eqTqVNXV1du3bw8hdO3atWE+S1pKTpIOI0aMaPb4yJEj58+fX19fv3bt2uhxyZFmt+tGT/4dOHBgs/+FsLy8fMiQIb///e/feOONDl49Ul9fv3HjxrVr17788stPPPHE/fff39J3l9rV3njjjb/5zW82bNhw5513hhD+7d/+rc3Ny21KejHRHQwbiXZJtyLxty67SkpKUvIjU1tbu3PnzuiEjfaAU0h27NhRWlra9L9G0EGjDuoXWt7R/JdNH4aM7Giuq6v79NNPQwglJSXl5eXpvlwiho8ZtnLJqleWvRHdFZGUqK6uTuGf1Q3vFgK0rkuXLo32qSQterhfoy0yALTOQ1TID/369Wv2eDyNNUpXffr0afriqIK1dKoQwkEHHdT0VO29+po1a6ZMmXL44Yd369atd+/eo0aNOv/88xcuXNjSRVO+2h49esyaNSv6eMSIEVVVVa1cOkFJL2a//fZL/CpJvHUAEQ9XaZYHqgAAkBImEMlv8Vme6FEncc3OhbW5y7u0tDSEEI2QJHf1n/70p5dddlltbW302cMPP3zAgAGDBg0aOXLkI488cttttzV7npSv9sUXX4w+WL169bp166K61xFJLybxDR3JvXUAcR6u0qxhlUNXLlm1cskqc4gAACRNQCQ/rF27tnfv3k2PR5NxIYQBAwa0eZIBAwa88847b731VitXafZUCV79qaee+v73vx9CGDp06HXXXXfiiSc2LIP//d//3eYKU7LaF1988dprrw0hdOrUafv27ZMmTXr88cfbdekULiZBqX3rgGJ2zAEHtjJvuOzdd4qwIQIAQAfZwkx+WLFiRbPHn3/++eiD/v37t3mS6DWvvPLKjh07mn529+7d0YOGBw4cmNzVo3sOlpeXP/nkk2PHjm00V9je+zQnt9rdu3efd955u3fvHjFixK233hpCeOKJJ+644452XTpVi0lcat86oMgdc8CBrVTCZe++U2w7mm1kBgCggwRE8sO///u/N61IGzZsWLBgQQjhsMMOq6ioaPMkX/ziF0MIn3zyyZw5c5p+9he/+MUHH3wQQjjmmGOSu/r69etDCAcddFDTG//V19fHa2OCklvtdddd98ILL5SWlt5+++1VVVXHHntsCOG73/3u+++/366rp2QxiUvtWwcQErgrYlFlRA0RAICOEBDJD+vWrZs8eXLDirdp06azzjoruunej3/840ROcvbZZx9yyCEhhGuvvXbp0qUNP7V8+fIrr7wyhNC3b99JkyYld/VoA+/atWs3btzY8Mt37tx58cUXRxUsusdfmla7cuXKGTNmhBCmTZt22GGHxWKxOXPmdO7cecuWLVOmTEnwupFGwTTpty5BqX3rACKtjyKGInu4ioYIAEDS3AOR/NC1a9d58+a9+OKL48aN69ev35///Of77rvv7bffDiGMGjVq7NixiZyktLT0hhtu+MY3vrFly5Yvf/nL55133siRIzt16rRs2bIFCxZENXDmzJlNH2mS4NVPOeWU2bNn79q16/jjj7/iiisOPfTQLVu2vPTSS7fccsvrr79eUVGxbdu2jRs33n///SeccMKee+6Z2tXGNy8PHDjwiiuuiA4OHTp02rRp11577aJFi8aPH5/IGxU9DmXbtm2LFi069NBDe/To0bt376TfugSl9q0DaMjDVeI8UAUAgOQIiOSHBx988Kyzznruueeee+65hsdPO+20aB9xgsaOHXvzzTd/73vf27Vr19y5c+fOnRv/VI8ePebMmfPNb34z6auffPLJkydPnj179po1a8aPHx8/HovFpk6dOmbMmK9//eshhNNPP33MmDFPPPFEalc7Y8aMv/zlL7FYbN68eQ1D3uWXX75w4cLXXntt8uTJo0eP7tGjR+sXPeKII6IPopNff/3106ZNa+9i2ivlbx1AIx6uEtEQAQBIgi3M5IdRo0atXr166tSpn//857t06dKzZ89Ro0bdfvvtv/rVr9o7jzZlypRVq1ZddNFFhxxySLdu3fbYY48BAwZUVVWtXLmypQSW+NVnzZq1ePHiE088sU+fPuXl5X369DnvvPNWrFhx0003fe1rX5s6dWrPnj27dOnSt2/f1K525cqV1113XQjh29/+9nHHHdfwDF26dIluXLh+/fooBbbupJNOmjlzZt++fcvKyj73uc/ts88+HXnrEpfytw6gEQ9XidjLDABAe8Xq6+uzvQaSV11dvX379hBCRUVF0rtHG7rmmmumT58e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" alt="Fluxo de tonicidade no Grupo Similar de Baixa Frequência" width="864" />
<p class="caption">
Figura B.3: Fluxo de tonicidade no Grupo Similar de Baixa Frequência
</p>
</div>
<p><br></p>
<div class="figure"><span id="fig:fluxo-4"></span>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABsAAAASACAIAAADOHB9sAAAACXBIWXMAAB2HAAAdhwGP5fFlAAAgAElEQVR4nOzdeZzU9X348c/swXIsAkqq8eBQDgWjjUc0asE7USJNokbz04gEpYIE1FbQaAxGBY1HUQseKAkIiUHRmqBtIFXUklAtUURAkUOQwyACci17zu+PSafbZb+wx+zOsc/nI48+hu98+cxn3M7Cvnh/Z2LxeDwAAAAAANQmL90bAAAAAAAyl4AIAAAAAEQSEAEAAACASAIiAAAAABBJQAQAAAAAIgmIAAAAAEAkAREAAAAAiCQgAgAAAACRBEQAAAAAIJKACAAAAABEEhABAAAAgEgCIgAAAAAQSUAEAAAAACIVpHsDNEplZWV5eXkIobCwMD8/P93boUnE4/HS0tJWrVrl5Sn+uamqqqqsrCyEkJ+fX1hYmO7t0FT27Nnje3UOS3yvDiHk5eW1atUq3duhqZSWlubl5flencP27NkTQojFYkVFReneC00l8fcu36sB6kWPyG5lZWU7d+7cuXNnIiOSk6qqqnbu3FlRUZHujdBUKioqEi/kxF9nyVW+xLkt8b16586difpArtq9e7cXcm5LvJB3796d7o3QhPbs2eN7NUB9CYgAAAAAQCQBEQAAAACIJCACAAAAAJEERAAAAAAgkoAIAAAAAEQSEAEAAACASAIiAAAAABBJQAQAAAAAIgmIAAAAAEAkAREAAAAAiCQgAgAAAACRBEQAAAAAIJKACAAAAABEEhABAAAAgEgCIgAAAAAQSUAEAAAAACIJiAAAAABAJAERAAAAAIgkIAIAAAAAkQREAAAAACCSgAgAAAAARBIQAQAAAIBIAiIAAAAAEElABAAAAAAiCYgAAAAAQCQBEQAAAACIJCACAAAAAJEERAAAAAAgkoAIAAAAAEQSEAEAAACASAIiAAAAABBJQAQAAAAAIgmIAAAAAEAkAREAAAAAiCQgAgAAAACRBEQAAAAAIJKACAAAAABEEhABAAAAgEgCYgOtW7du3bp16d4FAAAAADStgnRvoB5effXVxx9//JFHHjnkkEP2vnfPnj3Tp09fsGDB9u3bjzrqqL/927+95JJL8vPzG3BaSUnJ66+//vHHH3fu3PmUU0454ogjaiyyadOmkSNHXnXVVYcffnhqnyMAAAAAZJRsCohz587ds2dPrXdt3rz5rrvuWr16dQihQ4cOS5YsWbJkyaJFi2699db27dvX67Q1a9bcddddmzZtSvxyxowZ11577YUXXlj94WbMmNGpU6cBAwY0xdMEAAAAgMyRHZcw7969e8qUKUuWLIk64Z//+Z9Xr17dt2/fKVOmPPPMM48//vgRRxzx/vvvP/300/U6raqq6oEHHtixY8fo0aN/85vfTJgw4aijjpo8efKqVauSi3z88cfz5s274oorCgsLm+j5AgAAAECGyPSA+Ic//GH06NGDBg3613/916hzPvjgg8WLFxcXF//4xz/u3LlzCOHQQw+944478vPzX3vttc8++6zup61du3bNmjWXXnrpGWec0aZNmyOPPHL06NGVlZV/+tOfkg83derULl26nHXWWU37zAEAAAAgA2R6QPz44483bNhQVFR0wAEHxGKxWs/54x//GEI46aSTql+tfPDBBx9zzDHxeHzBggV1P23Hjh0hhAMPPDB5QseOHfPz87dt25b45eLFixcuXDho0KCozQAAAABALsn0gHjNNddM/x/Vw191K1euDCGccMIJNY4njiTureNpRx11VFFR0e9+97vdu3cn7n3++ecrKyv79u2b+OXUqVP79u170kknpeLJAQAAAECmy6YPUYmyYcOGEELiquTqEkfWr19f99Patm07ZMiQSZMmDR069Jhjjvn000/XrFlz3HHH9e/fP4Qwf/785cuX33///U37fAAAAAAgY+RCQNy1a1cIYe/5xOLi4hBCcpawjqd985vf7Ny58/PPP7948eKDDjro8ssvv/TSS2OxWGVl5fTp00877bTevXs3csPbt2+Px+ONXCShsrIycaOkpKS0tLTxC27dunXMmDHJD6EmQyT+H8aF8xmluLj47rvv7tatW+OXqqqqStwoLS2tqKho/IJkrD179pSVlaV7FzSJ5J/sFRUVX3zxRXo3Q9OprKxM4ffqNWvW3HbbbTt37kzJaqRE8rXs710Z5W/+5m/uvffe6u801RiJl3AKv1fHYrEDDjggVasBZKZcCIjl5eUhhDZt2tQ43rZt2xBCMqvV8bQQwkknnbT3Rcpz5szZuHHj7bffnpINpyogJlVWViZjYmNMmzZt5syZjV8HWoLOnTundiS5qqoqGRPJSan6Xk0m80LOeSn8Ej/88MOzZ89OyVKQ84455pgRI0akcMHEj4cpITcDLUEuBMT27dtv27atpKSkxvHEUGFy5LCOp9WqtLT02WefPe+88w477LDEb5k2bdqf//znXbt29e7de9CgQV27dk3V00mvxJwmUBfL3l4+6/6X070LALLVsreWp3sLkDWSV4wBkBa5EBAPPPDAbdu27X31R+JIp06d6nVarV566aXdu3d///vfDyGUlpb+4z/+4/r163v06HHwwQcvWrToxhtvvPfee3v16lX3DdfxzP0qKSlJ/FHarl271q1bN37B5ITm5MmTL7744sYvCLnnnXfeOeecc0IIBfkFew81N0BlZWXistaCgoLCwsLGL0hmKikpKSwsLCjIhT952Vs8Ht+zZ08IIT8/v1WrVuneDk1lz549+fn5qfpenZ+fn7gxd+7cE088MSVrQo558cUXhwwZEkJo06bNQQcdlJI1d+zYEfY3QQJADbnwY0zHjh1DCFu2bKlxfOvWrSGE5B8zdTxtb9u3b3/hhRcGDhyYCH8vvPDC+vXrr7/++m984xshhLVr1958882PP/74Qw89VMcNp3DEPblULBZLybLJRdq1a7fvqAot1v/+dTOWmpdz9UVcApPzfIlzVfU3J/FVznkp+xL/zzLt27f39y6oVbt27RI3UvXzTpLv1QD1kpfuDaRAly5dQgjvvvtujeOLFi0KIXTv3r1ep+1t5syZ+fn5yXG8999//+CDD07Uw8SyZ5999sqVK/e+OBoAAAAAsl0uBMSvfe1rIYT//u//rv5BKNu3b1+8eHGrVq369+9fr9Nq2LRp0yuvvPK9730v8VkrCTX+tSovLy9U+xxVAAAAAMgZuRAQjz322N69e2/duvWRRx5JfLplaWnpvffeW15e3q9fv+TQex1Pq2H69OkHHnjghRdeWP3hPv3007lz5yZ+uX79+ldffbV79+5RKwAAAABA9sqF90AMIdx0002jR49+8803Fy5c2KVLl1WrVpWVlR166KGDBw9uwGlJq1evfv3112+44Ybqb5X93e9+94033nj00UfnzJlTXFy8ePHiqqqqYcOGNe0zBAAAAIB0yIUJxBDCl7/85Ycffvj8889v06bNihUrOnbs+O1vf/uhhx6q8dFadTwtaerUqV26dDnzzDOrHywqKnrwwQcvvPDCbdu2LV++/Ctf+cpDDz3Uu3fvpnt2AAAAAJAu2TSBOH369H3ce+CBB44Y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R0lJSY0VXnjhhcRHLT/66KPJg/Pnz08cXLhwYeLIsGHDYrHY2LFjQwjbtm1L3HvffffVdzMJ7du3j8ViL7300q5du6677rrOnTsXFxe3bt26T58+gwYNWrFiRa1P9vXXXx82bNhZZ5315S9/uX379sccc8yAAQNmzZpVWVlZ7/9wAAAAQPYTEGE/Zs+effzxxz/yyCPLli3btWvXrl27li9f/thjjx1//PHjx49PntamTZunn346FoutXLkyUQCTvvjiix/96EchhH79+o0YMaIZNlNdSUlJ//79n3jiie3bt4cQysrKli1bNm3atD59+rz66qvVz6yoqPjBD35w5plnPv744/Pmzfv000937tz5wQcfvPLKK5dccsm5555bXl7emM0DAAAA2UhAhH2ZPXv2RRddtHnz5oKCgsGDBz/55JNTpkwZOnRoUVFRZWXlj3/84+nTpydP7tev3/Dhw0MIDz744DvvvJM8Pnr06A0bNrRr1+4Xv/jFvi8fnjhxYkVFxR133BFC6NChQ0VFRUVFxejRoxuwmaTbbrtt4cKFvXr1mjhx4oIFC1555ZVLL700hFBeXn7llVdWVFQkz5wwYUJihe7du99zzz0zZ8587rnnxo8f37t37xDCvHnzxo0b14j/lgAAAEBW8h6IEKmysnLMmDEhhE6dOr344ov9+/dPHB88ePAPf/jDgQMHbtq06Y477vje977XqlWrxF333nvv7Nmz16xZM2TIkLfeequgoOCNN96YPHly4q4jjzxy34+Yl5eX/L+xWCw/P78xm0lYtWrVGWec8fLLLx9wwAGJIxdccMFVV131zDPPbNy4cenSpccdd1zi+KRJk0IIPXr0ePvttzt27JhcYcSIESeccMJHH3306quv/vSnP23If0oAAAAga5lAhEgzZsxYunRpCOG2225LBruEU0455c477wwhrF69esqUKcnjxcXFiVz4zjvvPPTQQ6WlpUOHDo3H4/3797/++uubeTMJeXl5EydOTNbDhKFDhyZuJN8JsaysrKKi4vDDDx8+fHj1eph4Uuecc04IYdWqVY15CgAAAEA2EhAh0vz580MI7du3v+666/a+d/DgwQcddFDytKTzzjtvyJAhIYSxY8cOHTr0ww8/bNeu3ZQpUxr52ccN20wI4Wtf+1pyxjAp+QHQ8Xg8caNVq1Zr16795JNPbrzxxr3X/+yzzxqzeQAAACB7CYgQKTGd16tXr3bt2u19b1FRUZ8+fUIIK1eurHHXgw8+eOihh5aUlEybNi2E8POf/3y/Fy833WYS72BYQ+Iq6X2Ix+MbNmyYP3/+008/ffnll8+aNauB+wYAAACynPdAhEiJZte9e/eoE7p16/bmm2/u3ew6dOgwceLE73znOyGEk08+ediwYWnczCGHHFL3R1m2bNljjz325ptvfvjhhyUlJQ3bKgAAAJBLBESIlLy8N0pBQUEIYc+ePXvf9d577yVuLF26dM2aNd26dUvXZup+6fQDDzxwyy23VFZWhhAKCwu/+tWv9uzZs3fv3qeddtpvf/vbxx57rP67BgAAALKegAiRevbs+cknn3z88cdRJ6xevTpxWo3j77333t133x1CyMvL27Vr19ChQ+fMmZOuzdTRa6+9dvPNN4cQ+vbtO27cuPPPP79169bJe3//+983bFkAAAAg23kPRIjUo0ePEMKHH364e/fuve8tLy9PfCxyr169ahy/+uqry8vLTz755EcffTSEMHfu3KlTp6ZlM3WXeLvGoqKiP/zhDwMHDqxeD0MIFRUVDVsWAAAAyHYCIkT6+te/HkLYsWPHE088sfe9v/zlLzdt2hRCOPXUU6sfHzdu3DvvvFNQUPDUU08NGzbs9NNPDyHcdNNNf/nLX5p/M3W3fv36EEK3bt32fs/EeDz+1ltvNWxZAAAAINsJiBDpyiuvPProo0MId9999/z586vf9fbbb//kJz8JIXTt2nXo0KHJ44sWLbrnnntCCGPGjDnuuONisdgTTzxRWFi4ZcuWkSNH1uvRawz9NWAz9ZK49nn16tUbN26sfry0tPSGG25IBMTE2yMCAAAALYqACJEKCgruu+++EMKWLVvOPvvsf/iHf5g6deozzzxz/fXX9+vXLzFROH78+OTVvsmLl3v16nX77bcnDvbt23fMmDEhhJkzZ/72t7+t4+OGEHbu3Dlz5sylS5cmZgPru5n6GjBgQAihrKzsnHPO+dWvfvXee+/Nmzfv0UcfPfbYYx955JHi4uIQwsaNG2fNmrV9+/aGPQQAAACQjQRE2JeBAwc+/PDDhYWFZWVlTz755NVXX33VVVdNmjRpz549HTp0ePbZZ7///e8nT77nnnvefffdWCw2efLk6iHvtttuS8z3DR8+/Isvvtjvg55wwgmJG5dddlnfvn2nT5/egM3U14UXXjh8+PAQwrJly6644orjjz/+rLPOGjly5MqVK0eNGvXrX/86cdoll1xy8cUXN/hRAAAAgKwjIMJ+jBw5csmSJSNGjDj66KPbtWvXtm3bnj17Dhs2bNGiRZdddlnytEWLFo0bNy6EcO211/br16/6Cq1bt068ceH69esT04j7dsEFF4wfP75r166tWrU69NBDv/SlL9V3Mw0zceLE2bNnn3/++V26dCkqKurSpcvVV1+9cOHCCRMmfOtb3xo1alSnTp1at27dtWvXRj4QAAAAkEUK0r0ByAI9e/ZMfJ7yPhx//PFlZWVR95511lnxeLzGwdNPP33vgwm33HLLLbfc0uDNJOzYsSPqrsMOO6zWhx4wYEDiWua9TZgwYcKECXV5XAAAACCXmEAEAAAAACIJiAAAQItwzTXXxGKxWCx26623pnsvAJBNXMIMAADkvpdffvnpp58OIYwfPz75XjGffPLJ2rVr8/PzTz311LTuDgAymglEAAAgx33++efXXHNNXl7epEmTqr/T9JQpU84444wLLrggjXsDgMxnAhEAAMhxw4YN27x587Rp06644op07wUAso8JRAAAIJfF4/H7779/3bp16iEANIwJRAAAIJfFYrGuXbs25yOWl5eXlZW1bds2Fos15+MCQBMxgQgAAGSKDRs2jBo1qk+fPsXFxcXFxb179x4+fPiSJUuqn1NSUtKzZ89YLNajR4+SkpIaK7zwwguJj1p+9NFHkwfnz5+fOLhw4cLEkWHDhsVisbFjx4YQtm3blrj3vvvuq+9mEtq3bx+LxV566aVdu3Zdd911nTt3Li4ubt26dZ8+fQYNGrRixYpan+zrr78+bNiws84668tf/nL79u2POeaYAQMGzJo1q7Kyst7/4QCgKZlABGhaP/jppfs+oaysbPv27SGENm3atGvXrlk2RRps3ry5Xbt2bdq0SfdGaBKVlZVbt24NIbRq1eqAAw5I93ZoKlu3bm3VqtU+vlc/vOCPdV+t7K224d1UbCuHzJ49e/DgwZs3b04eWb58+fLly5988sm77rrr1ltvTRxs06bN008/feaZZ65cuXLs2LHVq98XX3zxox/9KITQr1+/ESNGNMNmqispKenfv3+yUZaVlS1btmzZsmW//vWv//3f//3ss89OnllRUTF48ODp06dX/+0ffPDBBx988Morr5x55plz5swpLCxszP4BIIUERICm9cydz+37hMrKym+NPLd5NgNAfVVvgiUlJfn5+a1atUrjfnLY7NmzL7roohBCQUHBD37wg69//esFBQULFiyYOnVqaWnpj3/84yOOOOLKK69MnNyvX7/hw4dPnDjxwQcfvPzyy7/61a8mjo8ePXrDhg3t2rX7xS9+se/LhydOnPgv//IvP/vZz372s5916NDh888/DyHk5eU1YDNJt91226pVq3r16jVq1KgTTzxxy5Ytv/jFL5577rny8vIrr7xy7dq1BQV//flrwoQJiXrYvXv3a665JjFQuWLFil/+8pcffvjhvHnzxo0b99Of/jRV/20BoJEERID0m3X/yyGEgoKCWn8o3e8MIwANU6+BQZpUZWXlmDFjQgidOnV68cUX+/fvnzg+ePDgH/7whwMHDty0adMdd9zxve99L/ln5b333jt79uw1a9YMGTLkrbfeKigoeOONNyZPnpy468gjj9z3IyZaYeL/xmKx/Pz8xmwmYdWqVWecccbLL7+cnES+4IILrrrqqmeeeWbjxo1Lly497rjjEscnTZoUQujRo8fbb7/dsWPH5AojRow44YQTPvroo1dffVVABCBzCIgAmW4fM4zaIsA+6INZZMaMGUuXLg0h3Hbbbclgl3DKKafceeedw4YNW7169ZQpU6677rrE8eLi4smTJ59//vnvvPPOQw89NGrUqKFDh8bj8f79+19//fXNvJmEvLy8iRMn1ngfg6FDhz7zzDMhhBUrViQCYllZWUVFxeGHHz58+PDq9TDxpM4555yPPvpo1apVjXkKAJBaAiJAFtMWAVTC3DB//vwQQvv27WskuYTBgwfffvvtn3/++fz586ufcN555w0ZMuTpp58eO3bskiVLPvzww3bt2k2ZMqWRn33csM2EEL72ta8lZwyTkh8AHY/HEzdatWq1du3aqEf/7LPPGrN5AGgKAiJAbqq1LaqKQPYSCnNb4nOKe/XqVetn1BQVFfXp0+fNN99cuXJljbsefPDBf/u3f9uwYcO0adNCCD//+c/3e/Fy022md+/ee5+ffF/FKPF4fOPGjatXr/7ggw/mzp07a9ashm4cAJqKgAjQgqiKQOYTClumRLPr3r171AndunWrtdl16NBh4sSJ3/nOd0IIJ5988rBhw9K4mUMOOaTuj7Js2bLHHnvszTff/PDDD0tKShq2VQBoHgIiQEu3d1WUFIHmoRWSlLy8N0ri84v37Nmz913vvfde4sbSpUvXrFnTrVu3dG2m7pdOP/DAA7fccktlZWUIobCw8Ktf/WrPnj179+592mmn/fa3v33sscfqv2sAaEICIgA1SYpAU5AL2YeePXt+8sknH3/8cdQJq1evTpxW4/h777139yMOgckAACAASURBVN13hxDy8vJ27do1dOjQOXPmpGszdfTaa6/dfPPNIYS+ffuOGzfu/PPPb926dfLe3//+9w1bFgCajoAIwP7VSIp6IlAXiiF116NHj1dfffXDDz/cvXt327Zta9xbXl6e+FjkXr161Th+9dVXl5eXn3zyyVdfffX1118/d+7cqVOnDho0qPk3U3eJt2ssKir6wx/+sPdVzxUVFQ1bFgCajoAIQL3picDe5EIa4+tf//qTTz65Y8eOJ5544sYbb6xx7y9/+ctNmzaFEE499dTqx8eNG/fOO+8UFBQ89dRTX/nKV371q1/Nnz//pptu+uY3v3nwwQc382bqbv369SGEbt267V0P4/H4W2+91bBlAaDp7OcTwQBgv56587nk/9K9F6BZPbzgj8n/pXsvZLcrr7zy6KOPDiHcfffd8+fPr37X22+//ZOf/CSE0LVr16FDhyaPL1q06J577gkhjBkz5rjjjovFYk888URhYeGWLVtGjhxZr0evMfTXgM3US+La59WrV2/cuLH68dLS0htuuCEREBNvjwgAGcIEIgCpZDgRcptQSBMpKCi47777/v7v/37Lli1nn3321Vdffdppp+Xl5S1YsGDKlCmJjysZP3588r0Ckxcv9+rV6/bbb08c7Nu375gxY+6+++6ZM2deccUVAwcOrMvjhhB27tw5c+bMY489tkOHDocddlh9N1NfAwYMmDRpUllZ2TnnnHP77bcfe+yxW7ZsWbx48SOPPLJixYri4uKdO3du3Lhx1qxZ55133gEHHNCwRwGAFBIQAWhC1XuimAhZSjSkeQwcOPDhhx/+p3/6p7KysieffPLJJ59M3tWhQ4cnnnjisssuSx6555573n333VgsNnny5Ooh77bbbvvNb37z0UcfDR8+vH///h06dNj3g55wwgmJG4nF77333jFjxtR3M/V14YUXDh8+fNKkScuWLbviiiuSx2Ox2KhRo84999yLLroohHDJJZece+65c+fObfADAUCquIQZgGbiMmfIIq5NJi1Gjhy5ZMmSESNGHH300e3atWvbtm3Pnj2HDRu2aNGi6sFu0aJF48aNCyFce+21/fr1q75C69atn3jiiRDC+vXrEylw3y644ILx48d37dq1VatWhx566Je+9KX6bqZhJk6cOHv27PPPP79Lly5FRUVdunS5+uqrFy5cOGHChG9961ujRo3q1KlT69atu3bt2sgHAoCUMIEIQHMzlggZSy4k7Xr27Pnoo4/u+5zjjz++rKws6t6zzjorHo/XOHj66afvfTDhlltuueWWWxq8mYQdO3ZE3XXYYYfV+tADBgwYMGBArb9lwoQJEyZMqMvjAkDzEBABSKdkTFQSIV1EQwAA9k1ABCAjKInQzHRDAADqSEAEILMoidCkdEMAAOpLQAQgQymJkEK6IQAADSYgApDplERoMN0QAIDGExAByBpKItSRbggAQAoJiABkn0RJlBGhBt0QAICmICACkK0MJEKSdAgAQNMREAHIegYSabF0QwAAmoGACECOMJBIy6EbAgDQnAREAHKNgURymHQIAEDzExAByE0yIrlENwQAII0ERABymYxItpMOAQBIOwERgNwnI5KNpEMAADKEgAhASyEjkhV0QwAAMo2A2EDr1q0LIRx++OHp3ggA9SMjkrGkQwAAMlMuBMQrr7xy+/bt+zjhoYce6tGjRwjhN7/5zYwZM2o957HHHjvssMMSt0tKSl5//fWPP/64c+fOp5xyyhFHHFHj5E2bNo0cOfKqq64SEAGylIxIRpEOAQDIZLkQEPeroOCvT/PTTz/d78lr1qy56667Nm3alPjljBkzrr322gsvvLD6OTNmzOjUqdOAAQNSvlUAmpOMSHrphgAAZIVcCIhPPfVUrceXLl06duzYk08+uVu3bokjiYD44IMP7j1UWFRUFEKoqqp64IEHduzYMXr06BNPPHHjxo2TJk2aPHny0UcffeSRRybO/Pjjj+fNmzdq1KjCwsImekYANCcZkeYnHQIAkEVyISC2bt1674Pl5eVPPfVUcXHx9ddfnzyYCIhHHHFErb8lhLB27do1a9ZcddVVZ5xxRgjhyCOPHD169DXXXPOnP/0pGRCnTp3apUuXs846K/XPBID0kRFpHtIhAABZJxcCYq1mzpy5bt26G2+88cADD0wcKSsr27JlS8eO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P3/MmDEjRoxo9BBpHy4VzXnvFAgPUQGA/JbFmKgeNoknRKeu+sNYPI8FIPZuu+22bdu2Vd/yk5/8JITw5S9/ObrDe32OP/74EELtSYVf/vKXIYQaVa7Ro3z44YchhBqPRnnzzTfXrVuXyrtI8WQeeOCBu++++4gjjpg6derPf/7zEMJ3vvOdNG412KT33qhmvncKgYAIAPkn68uWg3qYUQ20RXkx1OqJqiJAzGzevPmrX/1qdNu+HTt2XHfddTfffHMI4dprr234G6dNm9auXbv58+fPmDEjWtG1devWc889969//WvPnj2/853vNOko/fr1CyHMmzcv+S2PPfbYSSedFK2++uijj5p/Mh9//HFZWVlRUdHcuXOLiorOPffcE0888bXXXps+fXoqF2rbtm07duxI4703qpnvnUJgCTMA5L3WvxOietiaGm6IBbsy2sJngNg488wz77nnnh49enTv3v3999+vqKhIJBJXX331scce2/A39urVa/bs2RMnTrziiit+/OMf9+jR46233qqsrNx///3vuOOOGjcVafQo06ZNGz169JQpU+bPn9+9e/c33njjnXfeOeGEE/bZZ58VK1acfPLJU6dOHTNmTHNO5tJLL92wYcMll1wyePDg6Ltmz549cODAG2644eyzz+7fv399Oy8qKuratetHH310xBFHHHLIIQ8//HCT3nujmvneKQQCIgDkpRp3QmzNhpjFekhtqYwoFkhkrG8sUVgEyHGXXHLJ+eeff9tttz377LP77rvvUUcdNX78+FNPPTWV7x03btyRRx7505/+9Pnnn1+7du0Xv/jFo446aurUqdWfvpLiUb7xjW888sgjM2bMePHFF7du3RqtMj7//POfeuqpyy677G9/+1uj63kbPpn/+q//+s1vftO9e/fqk5V9+/b94Q9/OG3atPHjxz/99NOJRKK+nd96661TpkxZs2ZN8n70qb/3RjX/vRN7ifoewkBeKC8v3759ewihtLS0pKSk+Tu85pprpk2bFkL43e9+d8455zR/h9l1//33RzeA+M///M+MXB8IIaxYseKoo44KIQw55avnTr2q+TusrKyMbnpSXFzcrl275u+Q3LRjx462bdu2bds2g/uscffD1gmI2a2HOTt+mHwKc1FRUVP/zj+nFEhqjKQRFsvLy4uKijL1e/Xc+2f98fknQwjLly8/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l176p7+rKC8v79OnTyKR6N27d3l5eY2j3HvvvdGjlm+55ZbkxmXLlkUbV65cGW0pKytLJBLTpk0LIXz88cfRV2+44YamnkykU6dOiUTigQce2L59+0UXXbTPPvuUlpaWlJT079//vPPOe+ONN5p56QCgmYqzfQIA0ErUw9y0aulLkiLEyfTp06+88srkp5s2bXryySeffPLJ+fPnP/TQQ5/97GeTX6qoqBg7duxvf/vb6t/+yiuvvPLKKw8//PCIESMeeeSRtm3b1j7E3LlzL7rootoDekuWLBk7duymTZuSW1577bXXXntt7ty511577Q9/+MNoY4cOHebPnz9ixIg333xz2rRp1avf3//+9+9+97shhOOOO27ixInpX4WUT6a68vLy4cOHJxvlrl27Xn755Zdffvk//uM//uu//uuEE05IvjLtSwcA6TGBCED85eYDlwu5HiqGEFdr16696qqrQgiDBw/+8Y9/fOedd1566aXdunULITzzzDNnnXVW9RffdNNNUQLr1avX9OnTFy1a9Pvf/37mzJmHHnpoCGHp0qUzZsyofYi//OUvF1988X777Td9+vSFCxeeeeaZ0fYlS5Z8/etf37RpU3Fx8dixY+fOnbtgwYLx48e3b9++srLyRz/6UfXcdtxxx02YMCGEcOONNz733HPJ7Zdddtn69es7duz461//OpFINPBOZ82aVVFRMXXq1BBC586dKyoqKioqLrvssjROJumKK65YuXJl3759Z82atXz58ocffji6Yrt37x4zZkxFRUUzLx0ApM0EIgAxl4PpMBR2PazNECLERrQieOzYsXPmzIkm4MaMGXP55Zeffvrpf/rTn5544onHHnts5MiR0Ytnz54dQujdu/eKFSu6dOmS3MnEiROPOOKI119//fHHH7/66qtrHGL69OlDhw69//77u3btmtxYWVk5ZcqUEELXrl3vu+++4cOHR9vHjh37b//2b6NGjfrggw+mTp36L//yL+3atYu+dP311y9ZsmTt2rXjxo179tlni4uLn3rqqXnz5kVfOuSQQxp+p23atEn+M5FIFBUVNedkIm+99dawYcMeeuihvffeO9pyyimnfPvb377zzjs3bNiwevXqgQMHNufSAUDaTCACEGfqYc5SDCGuevTokayHkf322+/uu++OYlmyau3atauioqJ79+4TJkyonsBCCKWlpSeeeGII4a233qq9/4qKiptvvrl6PQwh3HXXXatXrw4hXHHFFclgFzn66KOvueaaEMKaNWsWLFhQ/ShRLnzuued+/vOf79y5c/z48VVVVcOHD7/44oubcwXSOJlImzZtZs2alayHkfHjx0cfJO+EmPalA4C0CYgAxFNuLlsO6mE9PI4ZYuOSSy6pffe9gw466Fvf+lYI4c9//vOnn34aQmjXrt0777zz7rvvXnrppbV38uGHH9a3/6OPPnrQoEE1Ni5btiyE0KlTp4suuqj2t4wdOza692L0sqSTTjpp3LhxIYRp06aNHz/+1Vdf7dix44IFCxpevNyo9E4mhHDUUUclZwyTevbsGX2QvOdj2pcOANImIAIQQ7mZDoN6+M8MIUIsDRkypM7tQ4cODSFUVVWtWbOm9lerqqrWr1+/bNmy+fPnn3322YsXL65v/3UuLo6m8/r27duxY8faX23fvn3//v1DCG+++WaNL914442f+9znysvL77jjjhDCT37yk0YXLzcq7ZOJ7mBYQ7RKugGpXzoASJt7IAIQNzlbD/+8ZZRHYjbAnRAhHnr16lXn9mSYe/PNN/v16xd9/PLLL996661PP/30q6++Gt0/sVE9evSovTFqdvUdOoRw8MEHP/3007WbXefOnWfNmnX66aeHEIYMGVJWVpbKOTQs7ZM54IADUj9KGpcOANImIAIQKzlbD5d9eJp6WNugEQMsXoYCkVzXnKxdP/vZzy6//PLKysroq1/84hf79Olz6KGHDh069MEHH7z11lvr3E9JSUntjcnlvfUpLi4OIUSrp2t44YUXog9Wr169du3agw8+OJW304C0Tyb1pdPpXToASJuACEBM5Gw6DP9Yubwj22eRo6o3REOIEANr1qzp1q1b7e3JZ4D06dMnhPDEE0/84Ac/CCEMGDBgxowZJ598cvUy+N///d9NOmifPn3efffdt99+u4GzSh66uhdeeOG6664LIbRp02b79u3jx49/5JFHmnToDJ5MijJ76QAgFe6BCEAc5Hw9JFUGEiHfrVy5ss7tzz77bPRB7969QwjRPQfbt2//2GOPjRo1qsZcYUVFRZMOGu3z1Vdf3bGjjr+t2b17d/RY5L59+9bYfv755+/evXvIkCG33HJLCOHRRx+9/fbbm3ToTJ1M6jJ76QAgFQIiAPktZ5+2HFEPU2HqEOLkF7/4Re2GtX79+gULFoQQBg4cWFpaGkJYt25dCOHggw+ufeO/qqqqZG1M0Ze+9KUQwieffDJnzpzaX/3Nb37zwQcfhBCOOeaY6ttnzJjx3HPPFRcX33bbbWVlZccee2wI4Xvf+97GjRubdPSMnEzqMnvpACAVAiIAeSyX0yFpM4QIeW3t2rUTJkyo3hA3bdp0zjnnRLf8u/baa6ON0QLeNWvWbNiwofq379y585JLLokqWHSPv1SMGTPmsMMOCyFcd911y5Ytq/6lFStWXHXVVSGEnj17jh8/Prl91apV06dPDyFMmTJl4MCBiURizpw5bdu23bJly6RJk5r0lmsE0zROpkkye+kAIBUCIgD5KvfrofHD1BlChNjo0KHDvHnzhg0bdv311y9cuHDKlCmDBw9+6qmnQgjDhg0bNWpU9LLTTjsthLBr164TTzzxd7/73QsvvLB06dJbbrnl8MMPv/nmm6MpxQ0bNixevHjr1q2NHrS4uPiGG24IIWzZsuWEE074zne+c/vtt995550XX3zxcccdF00Uzpw5M7naN7l4uW/fvldeeWW0ccCAAVOmTAkhLFq06MEHH0zlzUaPQ9m2bduiRYtWr14dzQY29WSaKrOXDgBS4SEqAOSf3E+HQT1sHk9Tgfx13333nXPOOc8888wzzzxTffsZZ5wRrWKOnHrqqRMmTJg9e/bLL7987rnnJrcnEonJkyePHDny61//egjhzDPPHDly5KOPPtrocUeNGvXLX/7y+9///q5du+bOnTt37tzklzp37jxnzpxvfvObyS3Tp09//vnnE4nEvHnzqoe8K664YuHCha+//vqECROGDx/euXPnhg96xBFHRB9EO7/++uujBNmkk2mqjF86AGiUCUQA8ox6GFeKIcTDsGHDVq9ePXny5M9//vMlJSVdu3YdNmzYbbfdds899+y9997VXzlr1qwlS5acfPLJPXr0aN++fY8ePc4///yVK1fedNNNX/va1yZPnty1a9eSkpKePXumeOhJkya99NJLEydOPOywwzp27LjXXnv16dOnrKxs1apV1YPdqlWrZsyYEUK48MILjzvuuOp7KCkpiW5cuG7duigFNuyUU06ZOXNmz54927Vr97nPfW7fffdt6smkJ+OXDgAaZgIRgLyRF+kwqIcZYggR8tcBBxxw00033XTTTY2+8rTTTosW5NZWew+7d+9udId9+vSJnqfcgEGDBu3atau+rx5//PFVVVU1Nh577LG1N0Yuv/zyyy+/PO2TiXzyySf1falbt251HrpJlw4AmskEIgD5QT0sBIohAADkIAERgFx3VJf71cPC5HHMAACQCwREAHJXHqXDoB5miCFEAADINQIiALkov9JhUA9bjCFEAADIOg9RASDn5Fc6DOphpg0aMUA3hLzTrVu3ESNGhBCKioqyfS4AQIYJiADkkLxLh0E9bHkexwx5YfTo0aNH+/0QAOLJEmYAckLerVmOqIctRDEEAIDcISACkGV5mg6DetiKrGgGAIAsEhAByJr8TYdBPWx5NYYQNUQAAMgWARGALMjrdBjUw9ZiITMAAOQCARGAVpXv6TCoh9ljCBEAALJCQASglcQgHQb1sNUZQgQAgKwTEAFocfFIh0E9zAGGEAEAoPUVZ/sEAIiteETDJPUwWwaNGKAbAgBAFplABCDzYjNymKQe5g4xEQAAWpkJRAAyJmbRMCId5gJDiAAAkEUmEAHIgPiNHEbUw9wkJgIAQGsygQhA+mIZDZPUw5xiCBEAALJFQASgyeLdDSPqYY5btfSlQSMGZPssAACgIAiIAKSqELphRD3MTYYQAQAgKwREABpRON0woh7mC0OIAADQOgREAOpQaNEwST3McYYQAQCg9QmIAPyvgu2GEfUw7xhCBACAViAgAhS6Ao+GSephvqgxhKghAgBASxMQAQqUblideggAAFAfARGgUCiG9VEPxQmZkAAAIABJREFU844hRAAAaE0CIkCciYYNkw7zl6epAABAqxEQ0/Tee++FELp3757tEwGoSTRMkXoYJ4YQAQCg5cQnIL799tv333//iy+++PHHH3/2s5/t0aPHGWec0a9fv+qvWbhw4V133VXnt996663dunWLPi4vL3/yySfffvvtffbZ5+ijjz7ooINqvPiDDz6YNGnSt7/9bQERyAWKYRrUwxgwhAgAAK0jJgHxj3/844033lhZWRlC2G+//bZs2fL++++vWLHim9/85r/+678mX/b+++83uqu1a9dee+21H3zwQfTpXXfddeGFF5566qnVX3PXXXd17dr1tNNOy+ibAEiJXNh86mEsGUIEAIAWEoeA+Pe///2mm26qrKz88pe/PG7cuM985jOVlZV/+MMffv3rXy9cuPDwww8fOHBg9MooIN544421hwrbt28fQtizZ8/PfvazTz755LLLLhs8ePCGDRtmz549b968ww477JBDDole+fbbby9dunTy5Mlt27ZtxXcJFC7FMLPUwzgxhAgAAK0gDgHx0Ucf3bVrV79+/b73ve8VFRWFEIqKikaPHr1ly5b7779/yZIlNQLiQQcdVFJSUueu3nnnnbVr1377298eNmxYCOGQQw657LLLLrjggj//+c/JgHj77bf36NHj+OOPb433BhQeubDlSIexZwgRAABaQhwC4htvvBFCGDFiRFQPk4YOHXr//fdHXw0h7Nq1a8uWLV26dKmvHoYQPvnkkxDCZz7zmeSWLl26FBUVffzxx9GnL7744sqVK6dOnZpIJDL+RoACdFSX+6v27KmorAwhtGnTpsbvY2SQehhXhhABAKClxSEgVlRU7LPPPrWfZxItMY5ujBhC2LhxY1VV1QEHHNDArj7/+c+3b9/+D3/4wzHHHLPXXnuFEO65557KysoBA/4xznD77bcPGDDgyCOPzPzbAOJl8jFDa2yp2nZLXS88qLKycufOnSGE4uLidu3apXGs5e+9m8Z3FRT1sHAYQgQAgIyLQ0C88sor69z+zDPPhBA+//nPR59G65e7dOmyePHipUuXbty4cZ999unVq9cZZ5yRXJ681157jRs3bvbs2ePHj+/Xr9/777+/du3agQMHDh8+PISwbNmy11577ac//WlrvKss2bJlS/TBhRdeePHFF2f3ZCA3VVRURB988tFHdb4gWoP851caX4l8TPea92NNT6b2k4p8jJXqYewZQgQAgBYVh4BYp1WrVi1evDiEcPrpp0dbooC4fPny5cuXFxcX77333u+999577733pz/9aezYsaNGjYpe9tWvfnWfffa55557Xnzxxc9+9rNnn332WWedlUgkKisrf/vb3w4dOvTQQw9t5rl99NFHe/bsaeZOIlVVVdEH27dv3759e/N3+Le//S2zO4QY277htS92/H3t7bt3p7qHp9e8Vd+XBu/f0Lh0Fg38zGczsp+VG9/PyH4atezD00LY0TrHatTu3bt3p/7rg6aofmH/8ujz/Y/tm60zqays3LEjV37J0RIqKiqSf5PU7F1VZmQ/UAjKy8s3b96ckV1Ff4bK1N5CCIlEovpdsABiKYYBcefOnQsXLrz33nv37Nlz7rnnfuELX4i2RwGxtLR00qRJRx55ZHFx8fbt2+++++4HHnhgwYIF/fv37927d/TKI488svYi5UceeWTDhg31TTs2yZ49e5LhL1MytcO+ffs+/vjjIYSioqI2bdpkZJ8QM1VVVdEfHQf02T+VzJdeKWvgu3K2LTZJGu+iqVdy2YenNfUQ5K/+x/Zdvey1bJ8FAC2lqqoqs3+GyvifyADiLW4BcdmyZfPnz9+0aVNJScm4ceO+8pWvJL80cuTIwYMH9+jRY5999om2dOzYcdy4cR999NFTTz21aNGiH/3oR/XtdufOnXffffdJJ53UrVu3EMKOHTvuuOOOv/71r9u3bz/00EPPO++8nj17pn6SRUVFmfrPVbJFtmnTJiPPdencuXP0wZ133nnOOec0f4cQPytWrDjqqKNCCF277pXKz92RBxzY8AtWvr8h+h0hxZ/hv9bT0QY3dqB81+iVjKx8f0MIYdmmr+Xaw66qqqo8gKtFVb+8L//p9dYfQkz+x92/6BjL8A+yXymQsgw+ay5aDZbBaQm/7QOFID4BcevWrbfeeuuyZctCCMOGDTv//PP322+/6i/o1atXr169an/jV77ylaeeeuqtt+pdSBhCeOCBB3bs2BEFtZ07d/77v//7unXrevfuvf/++69aterSSy+9/vrr+/ZN9Q8qXbp0SfVdNaa8vDxaaLzXXns18HTp1HXo0KH5O4ECUVxclJEfmS/16NnAQ1RSv+fgqs2bam9szdsj5ohhvQ5JlH73yw2+5pfL/9RKZ1PNjh07iouLowd80RIGjxxU/U6Irz3zVms+TWXPnj2ffvppCKGoqKh9+/atdlxaWXl5eVFRUXoPvKqtOEM1BApBSUlJ165dM7KrrVu3hhD23nvvjOwNoEDEJCB+8MEHU6ZM2bx5c48ePSZOnHjYYYel/r37779/CGHLli31/ZXy1q1b77333lGjRkU3trj33nvXrVt38cUXR+ON77zzzg9+8INf/epXP//5zzP0bgD+V30FMMWwWOfLYlwVE6XfTeVltZ+RXUNWCiPN52kqAADQEuIQEHfs2HH11Vdv3rx55MiRZWVldQ537Nix43/+53/atGlz6qmn1qiEmzZtCiH06NGjvsnzRYsWFRUVnXHGGdGnf/vb3/bff//k4ugePXqccMIJDz/8cHl5ufE9oNU0JyzWfk08kmKK9TAVDRRGbTGPrFr6UmsOIQIAQFzFISA+9thj69atO/LIIydNmlTfazp06LBo0aK///3vBxxwwODBg6t/6Yknnggh1Pds5Q8++ODhhx8+77zz9tprr+TGGqkxun1Gph6sDNAcdabARqtiDJJiButhwxqeXpQXs84QIgAAZFwcAuIjjzwSQhg9enR9CS96wMhpp532u9/97qabbvr+978/aNCgEMKnn366ePHiRx55pFOnTvU9MOS3v/3tZz7zmVNPPTW55fDDD/+P//iPRx999KSTTgohrFu37vHHH+/Vq1fHjh0z/94AMiGNqljjq7ncE1stHaaigbw48/HHWvNMiBhCBACA5sv7gFhZWfnee++FEK688so6X3DggQfOmTMnhHDWWWeVl5ffd999V111VadOnTp06PDhhx9WVVV16tTpe9/7Xp0PNlmzZs2TTz55ySWXVF8W/X//7/996qmnbrnllkceeaS0tPTFF1/cs2dPWVlZy7w/gJZSowmm3hNzKibmVD1s2IUD/0/Hjh1r3+zC0GLGGUIEAIDMyvuA+OGHH6a4drioqGjs2LGHH374kiVL3njjja1bt/bp06dv377f/OY3O3fuXOe33H777T169BgxYkT1je3bt7/xxhvvuOOOlStXrl+//gtf+MJ555138MEHN/utAGRT7SxYX1LMkeHEPEqHDXO/xZZmCBEAAJop7wPiAQcc8OCDD6b++iFDhgwZMiTFF0+bNq3O7XvttddFF12U+kEB8lGKI4pZGU6MTT1smLaYNkOIAACQQXkfEAFoHan0xFaIiQWSDhtVX1sUFutkCBEAAJpDQAQgHdX7YKvFRPWwUcJikiFEAADIFAERgOZKPSamXRKlw2YSFg0hAgBA2gREADKp4ZiYXklUD1tOvMNijSFEDREAANIjIALQUhqIiSkucJYOsyXeYREAAGgSARGA1pCshCmOJUqHuSnvHgxtCBEAAJpPQASgVTVaEr902E9a+5zIhJwdWvQ0FQAAaCYBEYDsqL3A+dmPR4cQnv3/vamBYTfySK6FRUOIAADQVAIiANl3TPeDEqXf/dI/R6VfKomx1pph0RAiAAA0h4AIQJZVv91hFJVqJCQlsaC0Qlg0hAgAAE0iIAKQNfU9KSWZkOosiTJiYWpmWDSECAAAaRMQAciCFB+yXGdJlBGpLr2waAgRAABSJyAC0HpS7Ia11V7aLCPSsDp+bRwz9M5r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DDKECABAThEQoXA99NBD8+fPDyHMnDlz5syZ0cZ333132bJly5cvz+qpAXnJcua01R5C1BABAMgdAiIUqM2bN19wwQVt2rSZPXv25Zdfnty+YMGCYcOGnXLKKVk8NyB/Wc6cNguZAQDIWQIiFKiysrJNmzbdcccdZWVl2T4XIG4sZ84IQ4gAAOQIAREKUVVV1U9/+tP33nvv3HPPzfa5APFkOXMaLGQGACA3CYjkmW3btlVWVjbpW/bs2bNx48ZsHb2pMni2DUgkEj179tx///1b+kBJu3fv3r59e1VVVasdEcg6y5nTYCEzAAA5SEAkp82aNSuRSPTr1y+EcNddd/Xr169Tp07FxcX77rvviBEj5s2bVzvntW3bNpFIPPTQQyGEBx544IgjjigpKbn77rurv2b9+vWTJ0/u379/aWlpaWnpoYceOmHChJdeqjnlkcbRI08++WRZWdnxxx9/4IEHdurUqV+/fqeddtrixYtb7mzLy8v79OmTSCR69+5dXl5e4yj33ntv9KjlW265Jblx2bJl0caVK1dGW8rKyhKJxLRp00IIH3/8cfTVG264IY1LF0Lo1KlTIpF44IEHtm/fftFFF+2zzz6lpaUlJSX9+/c/77zz3njjjWZeOiBfWM7cTIYQAQDIOgGR/DB9+vQxY8a88sor0aebNm168sknx48ff+yxx27evLnOb5k7d+7pp5/+3HPP7d69u/r2JUuWDBo06Oabb3755Ze3b9++ffv211577dZbbx00aFDyScRpH72iouJb3/rWiBEjfvWrXy1duvT999/ftm3bK6+88vDDD5955pkjR46scTKZOtsOHTrMnz8/kUi8+eabUQFM+vvf//7d7343hHDcccdNnDixzqOnKI1LV15ePnz48Dlz5mzdujWEsGvXrpdffvmOO+7o37//448/Xv2VaV86IPdZztwkhhABAMg1AiJ5YO3atVdddVUIYfDgwT/+8Y/vvPPOSy+9tFu3biGEZ5555qyzzqr9LX/5y18uvvji/fbbb/r06QsXLjzzzDOj7UuWLPn617++adOm4uLisWPHzp07d8GCBePHj2/fvn1lZeWPfvSj3/72t805+k033RTtoVevXtOnT1+0aNHvf//7mTNnHnrooSGEpUuXzpgxo4XO9rjjjpswYUII4cYbb3zuueeS2y+77LL169d37Njx17/+dSKRaOA6z5o1q6KiYurUqSGEzp07V1RUVFRUXHbZZWlfuhDCFVdcsXLlyr59+86aNWv58uUPP/xwdMV27949ZsyYioqKZl46IF9YztwkNRqiIUQAALKrONsnAI2L1uSOHTt2zpw5bdu2DSGMGTPm8ssvP/300//0pz898cQTjz322MiRI6t/y/Tp04cOHXr//fd37do1ubGysnLKlCkhhK5du953333Dhw+Pto8dO/bf/u3fRo0a9cEHH0ydOvVf/uVf2rVrl97RZ8+eHULo3bv3ihUrunTpktzJxIkTjzjiiNdff/3xxx+/+uqra7zBTJ3t9ddfv2TJkrVr144bN+7ZZ58tLi5+6qmn5s2bF33pkEMOafg6t2nTJvnPRCJRVFTUzEsXQnjrrbeGDRv20EMP7b333tGWU0455dvf/vadd965YcOG1atXDxw4sDmXDsgvx3Q/KKqH0T+rTybSsFVLXzKZCABAtgiIWZDBR0kkB7h27txZfZgrbbt27Wr+TlpCjx49kv0ust9++9199929e/fetWvX1VdfXSMgVlRU3HzzzdV7XAjhrrvuWr16dQjhiiuuSCawyNFHH33NNdeUlZWtWbNmwYIFF110URpH37VrV0VFRffu3SdMmFA9gYUQSktLTzzxxNdff/2tt96q/e4ydbalpaXz5s07+eSTn3vuuZ///OeTJ08eP358VVXV8OHDL7744noubUrSvnRt2rSZNWtWsh5Gxo8ff+edd4YQ3njjjSggpn3psquyck9GfmT27NmT/CBnfwbJiMrKSo8SOmK//VdsWB99vGzt20MO/Fx2zydTkv9mM/WD3G9on789/Ur1LX5/yAVVVVUZ/L26snJPRvYDhWDXrl3btm3LyK4qKioSiUSm9hZCSCQSHTt2zNTeAHKTgJgFFRUVmfoDZPXukJF9JneYay655JLq/S5y0EEHfetb35o/f/6f//znTz/9tKSkJPmlo48+etCgQTVev2zZshBCp06dakSuyNixY6+88srNmzcvW7asxgtSPHq7du3eeeed+t7Chx9+WN+XMni2J5100rhx4+bPnz9t2rSXXnrp1Vdf7dix44IFCxpevNyotC/dUUcdlZwxTOrZs2f0QfIXbdqXLtuqMvIjk7wO0Z9Lm79DcpZ/xZHB+x8QQvjL+xtCCM+uX3fkAQdm+4wyoCV+kGv8l/3Fp14eMOzQjOyZ5sjoD3Kh/40CpG7Pnj0ZGZgI//9310ztLYTQzP/TBsgLAmIWdO7cOVO7Ki8v3759ewihQ4cO1fNZ2jKyk5YwZMiQOrcPHTp0/vz5VVVVa9asiR6XHKlzuW705N++ffvW+TeE7du379+//9NPP/3mm2828+iRqqqqDRs2rFmz5pVXXnn00UcXL15c37vL7NneeOON//mf/7l+/fo77rgjhPCTn/yk0cXLjUr7ZKI7GNYQrZJuQOqXLruKiooy8iNTWVm5c+fOaIc11oATJzt27CguLq79txEFa9jBvaKFzM9v+jDk/3LmPXv2fPrppyGEoqKi9u3bZ2Sfg0cOqnH3w1eXv2khc3aVl5dn8Pfq6ncLARpWUlJSY51K2qKH+9VYIgNAwzxEhfzQq1evOrcn01iNdNWjR4/aL44qWH27CiEcfPDBtXfV1KO//PLLkyZN+uIXv9ixY8du3boNGzbsggsuWLhwYX0HzfjZdu7cedasWdHHQ4YMKSsra+DQKUr7ZA444IDUj5LGpQPymqczN6p2LvRAFQAAWp8JRPJbcpYnetRJUp1zYY2u8i4uLg4hRCMk6R39Zz/72eWXX15ZWRl99Ytf/GKfPn0OPfTQoUOHPvjgg7feemud+8n42b7wwgvRB6tXr167dm1U95oj7ZNJfUFHepcOyHdRQ0w+WSXf5xABACCWTCCSH9asWVPn9mgyLoTQp0+fRncSvebtt99u+Ci1d5Xi0Z944okf/OAHlZWVAwYMeOCBB7Zu3frXv/514cKFP/7xj7/61a82dUVb2mf7wgsvXHfddSGENm3abN++ffz48U06bmZPJkWZvXRA3kl2w+XvvWsUsQZDiAAAZJ2ASH5YuXJlndufffbZ6IPevXs3upPoNa+++uqOHTtqf3X37t3Rg4b79u2b3tGjew62b9/+scceGzVqVI25wqbepzm9s929e/f555+/e/fuIUOG3HLLLSGERx999Pbbb2/SoTN1MqnL7KUD8pHlzA3QEAEAyC4Bkfzwi1/8onZFWr9+/YIFC0IIAwcOLC0tbXQnX/rSl0IIn3zyyZw5c2p/9Te/+c0HH3wQQjjmmGPSO/q6detCCAcffHDtG/9VVVUla2OK0jvbGTNmPPfcc8XFxbfddltZWdmxxx4bQvje9763cePGJh09IyeTusxeOiBPHdP9IKOIAACQgwRE8sPatWsnTJhQveJt2rTpnHPOiW66d+2116aykzFjxhx22GEhhOuuu27ZsmXVv7RixYqrrroqhNCzZ8/aa35TPHq0gHfNmjUbNmyo/u07d+685JJLogoW3eOvhc521apV06dPDyFMmTJl4MCBiURizpw5bdu23bJly6RJk1I8bqRGME370qUos5cOyGtGEetkCBEAgCzyEBXyQ4cOHebNm/fCCy+MHj26V69ef/3rX+++++533nknhDBs2LBRo0alspPi4uIbbrjhG9/4xpYtW0444YTzzz9/6NChbdq0Wb58+YIFC6IaOHPmzNqPNEnx6Keddtrs2bN37dp14oknXnnllYcffviWLVtefPHFm2+++Y033igtLd22bduGDRsWL1580kkn7b333pk92+Ti5b59+1555ZXRxgEDBkyZMuW6665btGjRueeem8qFih6Hsm3btkWLFh1++OGdO3fu1q1b2pcuRZm9dEC+82SVOg0aMaBGNFy19KXaYREAADJOQCQ/3Hfffeecc84zzzzzzDPPVN9+xhlnROuIUzRq1Khf/vKX3//+93ft2jV37ty5c+cmv9S5c+c5c+Z885vfTPvop5566oQJE2bPnv3yyy+fe+65ye2JRGLy5MkjR478+te/HkI488wzR44c+eijj2b2bKdPn/78888nEol58+ZVD3lXXHHFwoULX3/99QkTJgwfPrxz584NH/SII46IPoh2fv3110+ZMqWpJ9NUGb90QAwc0/2gZEMM/zyZCAAAtCZLmMkPw4YNW7169eTJkz//+c+XlJR07dp12LBht9122z333NPUebRJkya99NJLEydOPOywwzp27LjXXnv16dOnrKxs1apV9SWw1I8+a9asJUuWnHzyyT169GhXEvbaAAAgAElEQVTfvn2PHj3OP//8lStX3nTTTV/72tcmT57ctWvXkpKSnj17ZvZsV61aNWPGjBDChRdeeNxxx1XfQ0lJSXTjwnXr1kUpsGGnnHLKzJkze/bs2a5du8997nP77rtvcy5d6jJ+6YAYsJy5BguZAQDIikRVVVW2z4H0lZeXb9++PYRQWlqa9urR6q655ppp06aFEH73u9+dc845zd9hM82aNWvixIkhhG3btnXs2LGgjk7OWrFixVFHHRVC+NY5Q26f+63m77CysnLnzp0hhOLi4nbt2jV/h+Sm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0fm5e05OTkhIyKpVq/RfLuOw7du3t23b9rfffitWrJjNe6tWqyMjI9u2bRsbG/vVV1998803uvr//POPDA3btGkzaNAg41tbzopHl56eHhgYePLkSfnHrKysixcvXrx48eeff965c2e7du10Na1+dACAIosAEQAA61me8aVnPHBwdXf+34kqAAob86uVZ+z93bpmDUPG1ysKIbKOuYkz1rVXgOLj48ePHy+EaNy48bvvvlu9evVTp06tW7cuISHh6NGj3bt337Nnj8FLTpw4MWXKlLJlyw4ePLhmzZqtWrWS5Vu3bn3nnXeEEE5OTh9//HGLFi2cnJyOHDkSFRWVmZk5ZsyYypUr9+rVy+q7f//99zICq169er9+/Xx9fVUq1bVr11asWHH58uU//vhj2rRpEydOLIjetmnTZsCAAQsWLJg1a9ZHH33UsGFDWT5y5Mjbt2+7u7svX77c/PLhBQsWzJ8//+uvv/7666+9vLwePnwohHBwcLD60Qkhxo4de/36dT8/vyFDhjRu3PjRo0fLly//5ZdfsrOze/XqdfPmTScnp/w8OgBAUUaACAB4oTBrD0DB+ezlRs7OzrpTmA1YMXuxEEpPTxdChISELF68WM5B69Wr15dfftm1a9fDhw/v3bs3Ojq6ffv2+i+ZOnVqy5YtN23a5O3trSvUaDRyNa63t/fGjRsDAwNleUhISJ8+fTp37nzv3r0JEyZ88MEH+kvC83T3hQsXCiFq1qx5/PjxEiVK6BoZNGhQo0aNrl69umfPHuMUzFa9nTFjxtatW+Pj4/v27Xvs2DEnJ6f9+/cvXbpUXvLx8TH/nGVWKP9XpVLpLxm27tEJIa5fv966dett27YVL15clrz55puffPLJypUrExMT//rrr/r16+fn0QEAijICRAAo0ojbAMBWLDlr5bkIGatUqaLL76SyZcuuWbOmZs2aWVlZEydONAgQc3Jy5s6dq5/HCSFWr179119/CSHGjh2ri8CkZs2aTZo0KSwsLC4ubtmyZf3797fi7llZWTk5OZUqVRowYIB+BCaE8PDwCAoKunr16vXr143fna166+HhsXTp0o4dO54+fXr27NlDhgwJDQ3VarWBgYEDBw5UeLQWsfrROTg4LFiwQJceSqGhoStXrhRCXLt2TQaIVj86AEBRRoAIAEWaNnWevbtQVKhznzhmFNNq2FLq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8zoQI0aM0A10WFjYihUrZs6c+dprrwk9+QkQ89of+Qvl4+MjhKhdu/bChQuPHDmybdu2d999V9avXr26yadXvnz5kSNH/vLLLxEREW+++aYs9Pf3z87OljWVRtxW4wgAAPAiIUAEADvr37+//EdpQkJCftqRCYKTk1NQUNDjx4/1L1kXIEp9+/bV/Xtbq9UmJCQ0btxYXjp69KgszMnJqVWrlhCidOnSBrOBDh48KKcl1qlTx5JpO5YHiHv37pU1dWmayThAtzhx9+7d+i+PjY2VmVdISIh1lc0HiEKIKVOm6Jfrr0+fO3eu/iUZUQkhjh07ZqZxpQCxatWqQohatWolJyfrl//zzz9yqmPnzp31y818VJScP3/ewcFB5i9Xr17VlWs0mvDwcN370g8QZbmTk9OmTZv0m4qLi/P39xdCqNVqg4lpJukCxB9//DFCz8KFCydMmKALtjp27GicMObpySgNaHJystyqr2nTphqNRqvVypXCQohly5ZZfTszdBFY3759I5T9+eefupeYGdM8DcStW7dcXV1ldnblyhX9+voHN+UnQMzrB0P3C9W2bVuDByunQwohYmNjZUl6erqc21i7du34+Hj9yqNHj5aVzf8nB63txhEAAOBFQoAIAHamy0fkyQAGlHb4EkI0b95cv6ZMEBwcHM6fP2/QiNUBYpUqVbKysgzqX7lyRU6ve/PNN2WJLu/QX4SrM2vWLHl15cqVT30algeIJ06cMMgyTMYBMq1wdnbOzc01aGHcuHHBwcGTJ0+2rrL5ANHPz88gML148aKs//LLLxu0v3//fnlp3bp1Zho3GSBmZGRUrly5UqVKBqGkFBwcLISoW7eufqGZj4qS999/X976yJEjBpdyc3Pr1KljMBZxcXEych02bJhxa7///rusb7Au2CTdL4gZrVq1SktLM3hhXp+M0oBqtdqdO3fKS99//31aWlr16tXF/y5etuJ2Zuh+ocwbOnSo7iVKY5rXgQgNDZUl+umkju6EE6sDRCs+GLopvRcuXDCov2PHDll/165dskT3bRMdHW1QOTs7W8587N27tywxOeI2HEcAAIAXiZMl/w8VAFBw5L/8hRBPnjxRq9X5bK1Vq1YBAQH57tR/DB06VC681efr69u9e/c1a9bINdcqlUoeMFKiRIm+ffsaNxIaGjpx4sTU1NRDhw7JhZ82oTs3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" alt="Fluxo de tonicidade no Grupo Dissimilar de Baixa Frequência" width="864" />
<p class="caption">
Figura B.4: Fluxo de tonicidade no Grupo Dissimilar de Baixa Frequência
</p>
</div>
<!--chapter:end:B-graficos.Rmd-->
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
